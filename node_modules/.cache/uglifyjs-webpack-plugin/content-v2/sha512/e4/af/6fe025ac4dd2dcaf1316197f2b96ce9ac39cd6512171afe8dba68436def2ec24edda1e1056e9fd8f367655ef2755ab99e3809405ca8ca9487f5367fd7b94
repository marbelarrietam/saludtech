{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"parentHotUpdateCallback\",\"window\",\"chunkId\",\"moreModules\",\"hotAvailableFilesMap\",\"hotRequestedFilesMap\",\"moduleId\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"hotUpdate\",\"hotWaitingFiles\",\"hotChunksLoading\",\"hotUpdateDownloaded\",\"hotAddUpdateChunk\",\"hotCurrentChildModule\",\"hotApplyOnUpdate\",\"hotCurrentHash\",\"hotRequestTimeout\",\"hotCurrentModuleData\",\"hotCurrentParents\",\"hotCurrentParentsTemp\",\"hotCreateRequire\",\"me\",\"installedModules\",\"__webpack_require__\",\"fn\",\"request\",\"hot\",\"active\",\"parents\",\"includes\",\"push\",\"children\",\"console\",\"warn\",\"ObjectFactory\",\"name\",\"configurable\",\"enumerable\",\"get\",\"set\",\"value\",\"defineProperty\",\"e\",\"hotStatus\",\"hotSetStatus\",\"then\",\"finishChunkLoading\",\"err\",\"hotWaitingFilesMap\",\"hotEnsureUpdateChunk\",\"hotStatusHandlers\",\"newStatus\",\"i\",\"length\",\"hotDeferred\",\"hotUpdateNewHash\",\"toModuleId\",\"id\",\"hotCheck\",\"apply\",\"Error\",\"requestTimeout\",\"Promise\",\"resolve\",\"reject\",\"XMLHttpRequest\",\"requestPath\",\"p\",\"open\",\"timeout\",\"send\",\"onreadystatechange\",\"readyState\",\"status\",\"update\",\"JSON\",\"parse\",\"responseText\",\"hotDownloadManifest\",\"c\",\"h\",\"promise\",\"head\",\"document\",\"getElementsByTagName\",\"script\",\"createElement\",\"charset\",\"src\",\"appendChild\",\"hotDownloadUpdateChunk\",\"deferred\",\"hotApply\",\"result\",\"outdatedModules\",\"options\",\"cb\",\"j\",\"module\",\"getAffectedStuff\",\"updateModuleId\",\"outdatedDependencies\",\"queue\",\"slice\",\"map\",\"chain\",\"queueItem\",\"pop\",\"_selfAccepted\",\"_selfDeclined\",\"type\",\"_main\",\"parentId\",\"parent\",\"_declinedDependencies\",\"concat\",\"_acceptedDependencies\",\"addAllToSet\",\"a\",\"b\",\"item\",\"appliedUpdate\",\"warnUnexpectedRequire\",\"abortError\",\"doApply\",\"doDispose\",\"chainInfo\",\"join\",\"onDeclined\",\"ignoreDeclined\",\"onUnaccepted\",\"ignoreUnaccepted\",\"onAccepted\",\"onDisposed\",\"idx\",\"outdatedSelfAcceptedModules\",\"errorHandler\",\"keys\",\"forEach\",\"installedChunks\",\"hotDisposeChunk\",\"dependency\",\"moduleOutdatedDependencies\",\"data\",\"disposeHandlers\",\"_disposeHandlers\",\"child\",\"indexOf\",\"splice\",\"modules\",\"error\",\"callbacks\",\"onErrored\",\"dependencyId\",\"ignoreErrored\",\"err2\",\"originalError\",\"exports\",\"l\",\"accept\",\"dep\",\"callback\",\"decline\",\"dispose\",\"addDisposeHandler\",\"removeDisposeHandler\",\"check\",\"addStatusHandler\",\"removeStatusHandler\",\"undefined\",\"hotCreateModule\",\"m\",\"d\",\"getter\",\"o\",\"r\",\"n\",\"__esModule\",\"object\",\"property\",\"s\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\tfunction hotDisposeChunk(chunkId) {\\n \\t\\tdelete installedChunks[chunkId];\\n \\t}\\n \\tvar parentHotUpdateCallback = window[\\\"webpackHotUpdate\\\"];\\n \\twindow[\\\"webpackHotUpdate\\\"] = // eslint-disable-next-line no-unused-vars\\n \\tfunction webpackHotUpdateCallback(chunkId, moreModules) {\\n \\t\\thotAddUpdateChunk(chunkId, moreModules);\\n \\t\\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\\n \\t} ;\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotDownloadUpdateChunk(chunkId) {\\n \\t\\tvar head = document.getElementsByTagName(\\\"head\\\")[0];\\n \\t\\tvar script = document.createElement(\\\"script\\\");\\n \\t\\tscript.charset = \\\"utf-8\\\";\\n \\t\\tscript.src = __webpack_require__.p + \\\"\\\" + chunkId + \\\".\\\" + hotCurrentHash + \\\".hot-update.js\\\";\\n \\t\\t;\\n \\t\\thead.appendChild(script);\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotDownloadManifest(requestTimeout) {\\n \\t\\trequestTimeout = requestTimeout || 10000;\\n \\t\\treturn new Promise(function(resolve, reject) {\\n \\t\\t\\tif (typeof XMLHttpRequest === \\\"undefined\\\")\\n \\t\\t\\t\\treturn reject(new Error(\\\"No browser support\\\"));\\n \\t\\t\\ttry {\\n \\t\\t\\t\\tvar request = new XMLHttpRequest();\\n \\t\\t\\t\\tvar requestPath = __webpack_require__.p + \\\"\\\" + hotCurrentHash + \\\".hot-update.json\\\";\\n \\t\\t\\t\\trequest.open(\\\"GET\\\", requestPath, true);\\n \\t\\t\\t\\trequest.timeout = requestTimeout;\\n \\t\\t\\t\\trequest.send(null);\\n \\t\\t\\t} catch (err) {\\n \\t\\t\\t\\treturn reject(err);\\n \\t\\t\\t}\\n \\t\\t\\trequest.onreadystatechange = function() {\\n \\t\\t\\t\\tif (request.readyState !== 4) return;\\n \\t\\t\\t\\tif (request.status === 0) {\\n \\t\\t\\t\\t\\t// timeout\\n \\t\\t\\t\\t\\treject(\\n \\t\\t\\t\\t\\t\\tnew Error(\\\"Manifest request to \\\" + requestPath + \\\" timed out.\\\")\\n \\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t} else if (request.status === 404) {\\n \\t\\t\\t\\t\\t// no update available\\n \\t\\t\\t\\t\\tresolve();\\n \\t\\t\\t\\t} else if (request.status !== 200 && request.status !== 304) {\\n \\t\\t\\t\\t\\t// other failure\\n \\t\\t\\t\\t\\treject(new Error(\\\"Manifest request to \\\" + requestPath + \\\" failed.\\\"));\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\t// success\\n \\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\tvar update = JSON.parse(request.responseText);\\n \\t\\t\\t\\t\\t} catch (e) {\\n \\t\\t\\t\\t\\t\\treject(e);\\n \\t\\t\\t\\t\\t\\treturn;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tresolve(update);\\n \\t\\t\\t\\t}\\n \\t\\t\\t};\\n \\t\\t});\\n \\t}\\n\\n \\tvar hotApplyOnUpdate = true;\\n \\tvar hotCurrentHash = \\\"0982f4132528f5d72ffb\\\"; // eslint-disable-line no-unused-vars\\n \\tvar hotRequestTimeout = 10000;\\n \\tvar hotCurrentModuleData = {};\\n \\tvar hotCurrentChildModule; // eslint-disable-line no-unused-vars\\n \\tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\\n \\tvar hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotCreateRequire(moduleId) {\\n \\t\\tvar me = installedModules[moduleId];\\n \\t\\tif (!me) return __webpack_require__;\\n \\t\\tvar fn = function(request) {\\n \\t\\t\\tif (me.hot.active) {\\n \\t\\t\\t\\tif (installedModules[request]) {\\n \\t\\t\\t\\t\\tif (!installedModules[request].parents.includes(moduleId))\\n \\t\\t\\t\\t\\t\\tinstalledModules[request].parents.push(moduleId);\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\thotCurrentParents = [moduleId];\\n \\t\\t\\t\\t\\thotCurrentChildModule = request;\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (!me.children.includes(request)) me.children.push(request);\\n \\t\\t\\t} else {\\n \\t\\t\\t\\tconsole.warn(\\n \\t\\t\\t\\t\\t\\\"[HMR] unexpected require(\\\" +\\n \\t\\t\\t\\t\\t\\trequest +\\n \\t\\t\\t\\t\\t\\t\\\") from disposed module \\\" +\\n \\t\\t\\t\\t\\t\\tmoduleId\\n \\t\\t\\t\\t);\\n \\t\\t\\t\\thotCurrentParents = [];\\n \\t\\t\\t}\\n \\t\\t\\treturn __webpack_require__(request);\\n \\t\\t};\\n \\t\\tvar ObjectFactory = function ObjectFactory(name) {\\n \\t\\t\\treturn {\\n \\t\\t\\t\\tconfigurable: true,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: function() {\\n \\t\\t\\t\\t\\treturn __webpack_require__[name];\\n \\t\\t\\t\\t},\\n \\t\\t\\t\\tset: function(value) {\\n \\t\\t\\t\\t\\t__webpack_require__[name] = value;\\n \\t\\t\\t\\t}\\n \\t\\t\\t};\\n \\t\\t};\\n \\t\\tfor (var name in __webpack_require__) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\\n \\t\\t\\t\\tname !== \\\"e\\\"\\n \\t\\t\\t) {\\n \\t\\t\\t\\tObject.defineProperty(fn, name, ObjectFactory(name));\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\tfn.e = function(chunkId) {\\n \\t\\t\\tif (hotStatus === \\\"ready\\\") hotSetStatus(\\\"prepare\\\");\\n \\t\\t\\thotChunksLoading++;\\n \\t\\t\\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\\n \\t\\t\\t\\tfinishChunkLoading();\\n \\t\\t\\t\\tthrow err;\\n \\t\\t\\t});\\n\\n \\t\\t\\tfunction finishChunkLoading() {\\n \\t\\t\\t\\thotChunksLoading--;\\n \\t\\t\\t\\tif (hotStatus === \\\"prepare\\\") {\\n \\t\\t\\t\\t\\tif (!hotWaitingFilesMap[chunkId]) {\\n \\t\\t\\t\\t\\t\\thotEnsureUpdateChunk(chunkId);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\\n \\t\\t\\t\\t\\t\\thotUpdateDownloaded();\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t};\\n \\t\\treturn fn;\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotCreateModule(moduleId) {\\n \\t\\tvar hot = {\\n \\t\\t\\t// private stuff\\n \\t\\t\\t_acceptedDependencies: {},\\n \\t\\t\\t_declinedDependencies: {},\\n \\t\\t\\t_selfAccepted: false,\\n \\t\\t\\t_selfDeclined: false,\\n \\t\\t\\t_disposeHandlers: [],\\n \\t\\t\\t_main: hotCurrentChildModule !== moduleId,\\n\\n \\t\\t\\t// Module API\\n \\t\\t\\tactive: true,\\n \\t\\t\\taccept: function(dep, callback) {\\n \\t\\t\\t\\tif (typeof dep === \\\"undefined\\\") hot._selfAccepted = true;\\n \\t\\t\\t\\telse if (typeof dep === \\\"function\\\") hot._selfAccepted = dep;\\n \\t\\t\\t\\telse if (typeof dep === \\\"object\\\")\\n \\t\\t\\t\\t\\tfor (var i = 0; i < dep.length; i++)\\n \\t\\t\\t\\t\\t\\thot._acceptedDependencies[dep[i]] = callback || function() {};\\n \\t\\t\\t\\telse hot._acceptedDependencies[dep] = callback || function() {};\\n \\t\\t\\t},\\n \\t\\t\\tdecline: function(dep) {\\n \\t\\t\\t\\tif (typeof dep === \\\"undefined\\\") hot._selfDeclined = true;\\n \\t\\t\\t\\telse if (typeof dep === \\\"object\\\")\\n \\t\\t\\t\\t\\tfor (var i = 0; i < dep.length; i++)\\n \\t\\t\\t\\t\\t\\thot._declinedDependencies[dep[i]] = true;\\n \\t\\t\\t\\telse hot._declinedDependencies[dep] = true;\\n \\t\\t\\t},\\n \\t\\t\\tdispose: function(callback) {\\n \\t\\t\\t\\thot._disposeHandlers.push(callback);\\n \\t\\t\\t},\\n \\t\\t\\taddDisposeHandler: function(callback) {\\n \\t\\t\\t\\thot._disposeHandlers.push(callback);\\n \\t\\t\\t},\\n \\t\\t\\tremoveDisposeHandler: function(callback) {\\n \\t\\t\\t\\tvar idx = hot._disposeHandlers.indexOf(callback);\\n \\t\\t\\t\\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\\n \\t\\t\\t},\\n\\n \\t\\t\\t// Management API\\n \\t\\t\\tcheck: hotCheck,\\n \\t\\t\\tapply: hotApply,\\n \\t\\t\\tstatus: function(l) {\\n \\t\\t\\t\\tif (!l) return hotStatus;\\n \\t\\t\\t\\thotStatusHandlers.push(l);\\n \\t\\t\\t},\\n \\t\\t\\taddStatusHandler: function(l) {\\n \\t\\t\\t\\thotStatusHandlers.push(l);\\n \\t\\t\\t},\\n \\t\\t\\tremoveStatusHandler: function(l) {\\n \\t\\t\\t\\tvar idx = hotStatusHandlers.indexOf(l);\\n \\t\\t\\t\\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\\n \\t\\t\\t},\\n\\n \\t\\t\\t//inherit from previous dispose call\\n \\t\\t\\tdata: hotCurrentModuleData[moduleId]\\n \\t\\t};\\n \\t\\thotCurrentChildModule = undefined;\\n \\t\\treturn hot;\\n \\t}\\n\\n \\tvar hotStatusHandlers = [];\\n \\tvar hotStatus = \\\"idle\\\";\\n\\n \\tfunction hotSetStatus(newStatus) {\\n \\t\\thotStatus = newStatus;\\n \\t\\tfor (var i = 0; i < hotStatusHandlers.length; i++)\\n \\t\\t\\thotStatusHandlers[i].call(null, newStatus);\\n \\t}\\n\\n \\t// while downloading\\n \\tvar hotWaitingFiles = 0;\\n \\tvar hotChunksLoading = 0;\\n \\tvar hotWaitingFilesMap = {};\\n \\tvar hotRequestedFilesMap = {};\\n \\tvar hotAvailableFilesMap = {};\\n \\tvar hotDeferred;\\n\\n \\t// The update info\\n \\tvar hotUpdate, hotUpdateNewHash;\\n\\n \\tfunction toModuleId(id) {\\n \\t\\tvar isNumber = +id + \\\"\\\" === id;\\n \\t\\treturn isNumber ? +id : id;\\n \\t}\\n\\n \\tfunction hotCheck(apply) {\\n \\t\\tif (hotStatus !== \\\"idle\\\")\\n \\t\\t\\tthrow new Error(\\\"check() is only allowed in idle status\\\");\\n \\t\\thotApplyOnUpdate = apply;\\n \\t\\thotSetStatus(\\\"check\\\");\\n \\t\\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\\n \\t\\t\\tif (!update) {\\n \\t\\t\\t\\thotSetStatus(\\\"idle\\\");\\n \\t\\t\\t\\treturn null;\\n \\t\\t\\t}\\n \\t\\t\\thotRequestedFilesMap = {};\\n \\t\\t\\thotWaitingFilesMap = {};\\n \\t\\t\\thotAvailableFilesMap = update.c;\\n \\t\\t\\thotUpdateNewHash = update.h;\\n\\n \\t\\t\\thotSetStatus(\\\"prepare\\\");\\n \\t\\t\\tvar promise = new Promise(function(resolve, reject) {\\n \\t\\t\\t\\thotDeferred = {\\n \\t\\t\\t\\t\\tresolve: resolve,\\n \\t\\t\\t\\t\\treject: reject\\n \\t\\t\\t\\t};\\n \\t\\t\\t});\\n \\t\\t\\thotUpdate = {};\\n \\t\\t\\tvar chunkId = 0;\\n \\t\\t\\t{\\n \\t\\t\\t\\t// eslint-disable-line no-lone-blocks\\n \\t\\t\\t\\t/*globals chunkId */\\n \\t\\t\\t\\thotEnsureUpdateChunk(chunkId);\\n \\t\\t\\t}\\n \\t\\t\\tif (\\n \\t\\t\\t\\thotStatus === \\\"prepare\\\" &&\\n \\t\\t\\t\\thotChunksLoading === 0 &&\\n \\t\\t\\t\\thotWaitingFiles === 0\\n \\t\\t\\t) {\\n \\t\\t\\t\\thotUpdateDownloaded();\\n \\t\\t\\t}\\n \\t\\t\\treturn promise;\\n \\t\\t});\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotAddUpdateChunk(chunkId, moreModules) {\\n \\t\\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\\n \\t\\t\\treturn;\\n \\t\\thotRequestedFilesMap[chunkId] = false;\\n \\t\\tfor (var moduleId in moreModules) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\\n \\t\\t\\t\\thotUpdate[moduleId] = moreModules[moduleId];\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\\n \\t\\t\\thotUpdateDownloaded();\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotEnsureUpdateChunk(chunkId) {\\n \\t\\tif (!hotAvailableFilesMap[chunkId]) {\\n \\t\\t\\thotWaitingFilesMap[chunkId] = true;\\n \\t\\t} else {\\n \\t\\t\\thotRequestedFilesMap[chunkId] = true;\\n \\t\\t\\thotWaitingFiles++;\\n \\t\\t\\thotDownloadUpdateChunk(chunkId);\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotUpdateDownloaded() {\\n \\t\\thotSetStatus(\\\"ready\\\");\\n \\t\\tvar deferred = hotDeferred;\\n \\t\\thotDeferred = null;\\n \\t\\tif (!deferred) return;\\n \\t\\tif (hotApplyOnUpdate) {\\n \\t\\t\\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\\n \\t\\t\\t// avoid triggering uncaught exception warning in Chrome.\\n \\t\\t\\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\\n \\t\\t\\tPromise.resolve()\\n \\t\\t\\t\\t.then(function() {\\n \\t\\t\\t\\t\\treturn hotApply(hotApplyOnUpdate);\\n \\t\\t\\t\\t})\\n \\t\\t\\t\\t.then(\\n \\t\\t\\t\\t\\tfunction(result) {\\n \\t\\t\\t\\t\\t\\tdeferred.resolve(result);\\n \\t\\t\\t\\t\\t},\\n \\t\\t\\t\\t\\tfunction(err) {\\n \\t\\t\\t\\t\\t\\tdeferred.reject(err);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t);\\n \\t\\t} else {\\n \\t\\t\\tvar outdatedModules = [];\\n \\t\\t\\tfor (var id in hotUpdate) {\\n \\t\\t\\t\\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\\n \\t\\t\\t\\t\\toutdatedModules.push(toModuleId(id));\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t\\tdeferred.resolve(outdatedModules);\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotApply(options) {\\n \\t\\tif (hotStatus !== \\\"ready\\\")\\n \\t\\t\\tthrow new Error(\\\"apply() is only allowed in ready status\\\");\\n \\t\\toptions = options || {};\\n\\n \\t\\tvar cb;\\n \\t\\tvar i;\\n \\t\\tvar j;\\n \\t\\tvar module;\\n \\t\\tvar moduleId;\\n\\n \\t\\tfunction getAffectedStuff(updateModuleId) {\\n \\t\\t\\tvar outdatedModules = [updateModuleId];\\n \\t\\t\\tvar outdatedDependencies = {};\\n\\n \\t\\t\\tvar queue = outdatedModules.slice().map(function(id) {\\n \\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\tchain: [id],\\n \\t\\t\\t\\t\\tid: id\\n \\t\\t\\t\\t};\\n \\t\\t\\t});\\n \\t\\t\\twhile (queue.length > 0) {\\n \\t\\t\\t\\tvar queueItem = queue.pop();\\n \\t\\t\\t\\tvar moduleId = queueItem.id;\\n \\t\\t\\t\\tvar chain = queueItem.chain;\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (!module || module.hot._selfAccepted) continue;\\n \\t\\t\\t\\tif (module.hot._selfDeclined) {\\n \\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\ttype: \\\"self-declined\\\",\\n \\t\\t\\t\\t\\t\\tchain: chain,\\n \\t\\t\\t\\t\\t\\tmoduleId: moduleId\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (module.hot._main) {\\n \\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\ttype: \\\"unaccepted\\\",\\n \\t\\t\\t\\t\\t\\tchain: chain,\\n \\t\\t\\t\\t\\t\\tmoduleId: moduleId\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tfor (var i = 0; i < module.parents.length; i++) {\\n \\t\\t\\t\\t\\tvar parentId = module.parents[i];\\n \\t\\t\\t\\t\\tvar parent = installedModules[parentId];\\n \\t\\t\\t\\t\\tif (!parent) continue;\\n \\t\\t\\t\\t\\tif (parent.hot._declinedDependencies[moduleId]) {\\n \\t\\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\t\\ttype: \\\"declined\\\",\\n \\t\\t\\t\\t\\t\\t\\tchain: chain.concat([parentId]),\\n \\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\tparentId: parentId\\n \\t\\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (outdatedModules.includes(parentId)) continue;\\n \\t\\t\\t\\t\\tif (parent.hot._acceptedDependencies[moduleId]) {\\n \\t\\t\\t\\t\\t\\tif (!outdatedDependencies[parentId])\\n \\t\\t\\t\\t\\t\\t\\toutdatedDependencies[parentId] = [];\\n \\t\\t\\t\\t\\t\\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\\n \\t\\t\\t\\t\\t\\tcontinue;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tdelete outdatedDependencies[parentId];\\n \\t\\t\\t\\t\\toutdatedModules.push(parentId);\\n \\t\\t\\t\\t\\tqueue.push({\\n \\t\\t\\t\\t\\t\\tchain: chain.concat([parentId]),\\n \\t\\t\\t\\t\\t\\tid: parentId\\n \\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n\\n \\t\\t\\treturn {\\n \\t\\t\\t\\ttype: \\\"accepted\\\",\\n \\t\\t\\t\\tmoduleId: updateModuleId,\\n \\t\\t\\t\\toutdatedModules: outdatedModules,\\n \\t\\t\\t\\toutdatedDependencies: outdatedDependencies\\n \\t\\t\\t};\\n \\t\\t}\\n\\n \\t\\tfunction addAllToSet(a, b) {\\n \\t\\t\\tfor (var i = 0; i < b.length; i++) {\\n \\t\\t\\t\\tvar item = b[i];\\n \\t\\t\\t\\tif (!a.includes(item)) a.push(item);\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// at begin all updates modules are outdated\\n \\t\\t// the \\\"outdated\\\" status can propagate to parents if they don't accept the children\\n \\t\\tvar outdatedDependencies = {};\\n \\t\\tvar outdatedModules = [];\\n \\t\\tvar appliedUpdate = {};\\n\\n \\t\\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\\n \\t\\t\\tconsole.warn(\\n \\t\\t\\t\\t\\\"[HMR] unexpected require(\\\" + result.moduleId + \\\") to disposed module\\\"\\n \\t\\t\\t);\\n \\t\\t};\\n\\n \\t\\tfor (var id in hotUpdate) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\\n \\t\\t\\t\\tmoduleId = toModuleId(id);\\n \\t\\t\\t\\tvar result;\\n \\t\\t\\t\\tif (hotUpdate[id]) {\\n \\t\\t\\t\\t\\tresult = getAffectedStuff(moduleId);\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\tresult = {\\n \\t\\t\\t\\t\\t\\ttype: \\\"disposed\\\",\\n \\t\\t\\t\\t\\t\\tmoduleId: id\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tvar abortError = false;\\n \\t\\t\\t\\tvar doApply = false;\\n \\t\\t\\t\\tvar doDispose = false;\\n \\t\\t\\t\\tvar chainInfo = \\\"\\\";\\n \\t\\t\\t\\tif (result.chain) {\\n \\t\\t\\t\\t\\tchainInfo = \\\"\\\\nUpdate propagation: \\\" + result.chain.join(\\\" -> \\\");\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tswitch (result.type) {\\n \\t\\t\\t\\t\\tcase \\\"self-declined\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDeclined) options.onDeclined(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreDeclined)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because of self decline: \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.moduleId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tchainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"declined\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDeclined) options.onDeclined(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreDeclined)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because of declined dependency: \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.moduleId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\t\\\" in \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.parentId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tchainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"unaccepted\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onUnaccepted) options.onUnaccepted(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreUnaccepted)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because \\\" + moduleId + \\\" is not accepted\\\" + chainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"accepted\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onAccepted) options.onAccepted(result);\\n \\t\\t\\t\\t\\t\\tdoApply = true;\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"disposed\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDisposed) options.onDisposed(result);\\n \\t\\t\\t\\t\\t\\tdoDispose = true;\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tdefault:\\n \\t\\t\\t\\t\\t\\tthrow new Error(\\\"Unexception type \\\" + result.type);\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (abortError) {\\n \\t\\t\\t\\t\\thotSetStatus(\\\"abort\\\");\\n \\t\\t\\t\\t\\treturn Promise.reject(abortError);\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (doApply) {\\n \\t\\t\\t\\t\\tappliedUpdate[moduleId] = hotUpdate[moduleId];\\n \\t\\t\\t\\t\\taddAllToSet(outdatedModules, result.outdatedModules);\\n \\t\\t\\t\\t\\tfor (moduleId in result.outdatedDependencies) {\\n \\t\\t\\t\\t\\t\\tif (\\n \\t\\t\\t\\t\\t\\t\\tObject.prototype.hasOwnProperty.call(\\n \\t\\t\\t\\t\\t\\t\\t\\tresult.outdatedDependencies,\\n \\t\\t\\t\\t\\t\\t\\t\\tmoduleId\\n \\t\\t\\t\\t\\t\\t\\t)\\n \\t\\t\\t\\t\\t\\t) {\\n \\t\\t\\t\\t\\t\\t\\tif (!outdatedDependencies[moduleId])\\n \\t\\t\\t\\t\\t\\t\\t\\toutdatedDependencies[moduleId] = [];\\n \\t\\t\\t\\t\\t\\t\\taddAllToSet(\\n \\t\\t\\t\\t\\t\\t\\t\\toutdatedDependencies[moduleId],\\n \\t\\t\\t\\t\\t\\t\\t\\tresult.outdatedDependencies[moduleId]\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (doDispose) {\\n \\t\\t\\t\\t\\taddAllToSet(outdatedModules, [result.moduleId]);\\n \\t\\t\\t\\t\\tappliedUpdate[moduleId] = warnUnexpectedRequire;\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Store self accepted outdated modules to require them later by the module system\\n \\t\\tvar outdatedSelfAcceptedModules = [];\\n \\t\\tfor (i = 0; i < outdatedModules.length; i++) {\\n \\t\\t\\tmoduleId = outdatedModules[i];\\n \\t\\t\\tif (\\n \\t\\t\\t\\tinstalledModules[moduleId] &&\\n \\t\\t\\t\\tinstalledModules[moduleId].hot._selfAccepted\\n \\t\\t\\t)\\n \\t\\t\\t\\toutdatedSelfAcceptedModules.push({\\n \\t\\t\\t\\t\\tmodule: moduleId,\\n \\t\\t\\t\\t\\terrorHandler: installedModules[moduleId].hot._selfAccepted\\n \\t\\t\\t\\t});\\n \\t\\t}\\n\\n \\t\\t// Now in \\\"dispose\\\" phase\\n \\t\\thotSetStatus(\\\"dispose\\\");\\n \\t\\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\\n \\t\\t\\tif (hotAvailableFilesMap[chunkId] === false) {\\n \\t\\t\\t\\thotDisposeChunk(chunkId);\\n \\t\\t\\t}\\n \\t\\t});\\n\\n \\t\\tvar idx;\\n \\t\\tvar queue = outdatedModules.slice();\\n \\t\\twhile (queue.length > 0) {\\n \\t\\t\\tmoduleId = queue.pop();\\n \\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\tif (!module) continue;\\n\\n \\t\\t\\tvar data = {};\\n\\n \\t\\t\\t// Call dispose handlers\\n \\t\\t\\tvar disposeHandlers = module.hot._disposeHandlers;\\n \\t\\t\\tfor (j = 0; j < disposeHandlers.length; j++) {\\n \\t\\t\\t\\tcb = disposeHandlers[j];\\n \\t\\t\\t\\tcb(data);\\n \\t\\t\\t}\\n \\t\\t\\thotCurrentModuleData[moduleId] = data;\\n\\n \\t\\t\\t// disable module (this disables requires from this module)\\n \\t\\t\\tmodule.hot.active = false;\\n\\n \\t\\t\\t// remove module from cache\\n \\t\\t\\tdelete installedModules[moduleId];\\n\\n \\t\\t\\t// when disposing there is no need to call dispose handler\\n \\t\\t\\tdelete outdatedDependencies[moduleId];\\n\\n \\t\\t\\t// remove \\\"parents\\\" references from all children\\n \\t\\t\\tfor (j = 0; j < module.children.length; j++) {\\n \\t\\t\\t\\tvar child = installedModules[module.children[j]];\\n \\t\\t\\t\\tif (!child) continue;\\n \\t\\t\\t\\tidx = child.parents.indexOf(moduleId);\\n \\t\\t\\t\\tif (idx >= 0) {\\n \\t\\t\\t\\t\\tchild.parents.splice(idx, 1);\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// remove outdated dependency from module children\\n \\t\\tvar dependency;\\n \\t\\tvar moduleOutdatedDependencies;\\n \\t\\tfor (moduleId in outdatedDependencies) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\\n \\t\\t\\t) {\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (module) {\\n \\t\\t\\t\\t\\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\\n \\t\\t\\t\\t\\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\\n \\t\\t\\t\\t\\t\\tdependency = moduleOutdatedDependencies[j];\\n \\t\\t\\t\\t\\t\\tidx = module.children.indexOf(dependency);\\n \\t\\t\\t\\t\\t\\tif (idx >= 0) module.children.splice(idx, 1);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Not in \\\"apply\\\" phase\\n \\t\\thotSetStatus(\\\"apply\\\");\\n\\n \\t\\thotCurrentHash = hotUpdateNewHash;\\n\\n \\t\\t// insert new code\\n \\t\\tfor (moduleId in appliedUpdate) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\\n \\t\\t\\t\\tmodules[moduleId] = appliedUpdate[moduleId];\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// call accept handlers\\n \\t\\tvar error = null;\\n \\t\\tfor (moduleId in outdatedDependencies) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\\n \\t\\t\\t) {\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (module) {\\n \\t\\t\\t\\t\\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\\n \\t\\t\\t\\t\\tvar callbacks = [];\\n \\t\\t\\t\\t\\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\\n \\t\\t\\t\\t\\t\\tdependency = moduleOutdatedDependencies[i];\\n \\t\\t\\t\\t\\t\\tcb = module.hot._acceptedDependencies[dependency];\\n \\t\\t\\t\\t\\t\\tif (cb) {\\n \\t\\t\\t\\t\\t\\t\\tif (callbacks.includes(cb)) continue;\\n \\t\\t\\t\\t\\t\\t\\tcallbacks.push(cb);\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tfor (i = 0; i < callbacks.length; i++) {\\n \\t\\t\\t\\t\\t\\tcb = callbacks[i];\\n \\t\\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\t\\tcb(moduleOutdatedDependencies);\\n \\t\\t\\t\\t\\t\\t} catch (err) {\\n \\t\\t\\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"accept-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tdependencyId: moduleOutdatedDependencies[i],\\n \\t\\t\\t\\t\\t\\t\\t\\t\\terror: err\\n \\t\\t\\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Load self accepted modules\\n \\t\\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\\n \\t\\t\\tvar item = outdatedSelfAcceptedModules[i];\\n \\t\\t\\tmoduleId = item.module;\\n \\t\\t\\thotCurrentParents = [moduleId];\\n \\t\\t\\ttry {\\n \\t\\t\\t\\t__webpack_require__(moduleId);\\n \\t\\t\\t} catch (err) {\\n \\t\\t\\t\\tif (typeof item.errorHandler === \\\"function\\\") {\\n \\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\titem.errorHandler(err);\\n \\t\\t\\t\\t\\t} catch (err2) {\\n \\t\\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"self-accept-error-handler-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\t\\terror: err2,\\n \\t\\t\\t\\t\\t\\t\\t\\toriginalError: err\\n \\t\\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\t\\tif (!error) error = err2;\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\ttype: \\\"self-accept-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\terror: err\\n \\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// handle errors in accept handlers and self accepted module load\\n \\t\\tif (error) {\\n \\t\\t\\thotSetStatus(\\\"fail\\\");\\n \\t\\t\\treturn Promise.reject(error);\\n \\t\\t}\\n\\n \\t\\thotSetStatus(\\\"idle\\\");\\n \\t\\treturn new Promise(function(resolve) {\\n \\t\\t\\tresolve(outdatedModules);\\n \\t\\t});\\n \\t}\\n\\n \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {},\\n \\t\\t\\thot: hotCreateModule(moduleId),\\n \\t\\t\\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\\n \\t\\t\\tchildren: []\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"/dist/\\\";\\n\\n \\t// __webpack_hash__\\n \\t__webpack_require__.h = function() { return hotCurrentHash; };\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn hotCreateRequire(52)(__webpack_require__.s = 52);\\n\"]}","code":"!function(c){var n=window.webpackHotUpdate;window.webpackHotUpdate=function(c,g){!function(c,n){if(!o[c]||!F[c])return;for(var g in F[c]=!1,n)Object.prototype.hasOwnProperty.call(n,g)&&(X[g]=n[g]);0==--G&&0===Q&&m()}(c,g),n&&n(c,g)};var g,I=!0,l=\"0982f4132528f5d72ffb\",r=1e4,e={},t=[],B=[];function b(c){var n=U[c];if(!n)return V;var I=function(I){return n.hot.active?(U[I]?U[I].parents.includes(c)||U[I].parents.push(c):(t=[c],g=I),n.children.includes(I)||n.children.push(I)):(console.warn(\"[HMR] unexpected require(\"+I+\") from disposed module \"+c),t=[]),V(I)},l=function(c){return{configurable:!0,enumerable:!0,get:function(){return V[c]},set:function(n){V[c]=n}}};for(var r in V)Object.prototype.hasOwnProperty.call(V,r)&&\"e\"!==r&&Object.defineProperty(I,r,l(r));return I.e=function(c){return\"ready\"===C&&d(\"prepare\"),Q++,V.e(c).then(n,function(c){throw n(),c});function n(){Q--,\"prepare\"===C&&(u[c]||Z(c),0===Q&&0===G&&m())}},I}var i=[],C=\"idle\";function d(c){C=c;for(var n=0;n<i.length;n++)i[n].call(null,c)}var a,X,s,G=0,Q=0,u={},F={},o={};function A(c){return+c+\"\"===c?+c:c}function y(c){if(\"idle\"!==C)throw new Error(\"check() is only allowed in idle status\");return I=c,d(\"check\"),function(c){return c=c||1e4,new Promise(function(n,g){if(\"undefined\"==typeof XMLHttpRequest)return g(new Error(\"No browser support\"));try{var I=new XMLHttpRequest,r=V.p+\"\"+l+\".hot-update.json\";I.open(\"GET\",r,!0),I.timeout=c,I.send(null)}catch(c){return g(c)}I.onreadystatechange=function(){if(4===I.readyState)if(0===I.status)g(new Error(\"Manifest request to \"+r+\" timed out.\"));else if(404===I.status)n();else if(200!==I.status&&304!==I.status)g(new Error(\"Manifest request to \"+r+\" failed.\"));else{try{var c=JSON.parse(I.responseText)}catch(c){return void g(c)}n(c)}}})}(r).then(function(c){if(!c)return d(\"idle\"),null;F={},u={},o=c.c,s=c.h,d(\"prepare\");var n=new Promise(function(c,n){a={resolve:c,reject:n}});X={};return Z(0),\"prepare\"===C&&0===Q&&0===G&&m(),n})}function Z(c){o[c]?(F[c]=!0,G++,function(c){var n=document.getElementsByTagName(\"head\")[0],g=document.createElement(\"script\");g.charset=\"utf-8\",g.src=V.p+\"\"+c+\".\"+l+\".hot-update.js\",n.appendChild(g)}(c)):u[c]=!0}function m(){d(\"ready\");var c=a;if(a=null,c)if(I)Promise.resolve().then(function(){return x(I)}).then(function(n){c.resolve(n)},function(n){c.reject(n)});else{var n=[];for(var g in X)Object.prototype.hasOwnProperty.call(X,g)&&n.push(A(g));c.resolve(n)}}function x(n){if(\"ready\"!==C)throw new Error(\"apply() is only allowed in ready status\");var g,I,r,B,b;function i(c){for(var n=[c],g={},I=n.slice().map(function(c){return{chain:[c],id:c}});I.length>0;){var l=I.pop(),r=l.id,e=l.chain;if((B=U[r])&&!B.hot._selfAccepted){if(B.hot._selfDeclined)return{type:\"self-declined\",chain:e,moduleId:r};if(B.hot._main)return{type:\"unaccepted\",chain:e,moduleId:r};for(var t=0;t<B.parents.length;t++){var b=B.parents[t],i=U[b];if(i){if(i.hot._declinedDependencies[r])return{type:\"declined\",chain:e.concat([b]),moduleId:r,parentId:b};n.includes(b)||(i.hot._acceptedDependencies[r]?(g[b]||(g[b]=[]),a(g[b],[r])):(delete g[b],n.push(b),I.push({chain:e.concat([b]),id:b})))}}}}return{type:\"accepted\",moduleId:c,outdatedModules:n,outdatedDependencies:g}}function a(c,n){for(var g=0;g<n.length;g++){var I=n[g];c.includes(I)||c.push(I)}}n=n||{};var G={},Q=[],u={},F=function(){console.warn(\"[HMR] unexpected require(\"+Z.moduleId+\") to disposed module\")};for(var y in X)if(Object.prototype.hasOwnProperty.call(X,y)){var Z;b=A(y);var m=!1,x=!1,H=!1,W=\"\";switch((Z=X[y]?i(b):{type:\"disposed\",moduleId:y}).chain&&(W=\"\\nUpdate propagation: \"+Z.chain.join(\" -> \")),Z.type){case\"self-declined\":n.onDeclined&&n.onDeclined(Z),n.ignoreDeclined||(m=new Error(\"Aborted because of self decline: \"+Z.moduleId+W));break;case\"declined\":n.onDeclined&&n.onDeclined(Z),n.ignoreDeclined||(m=new Error(\"Aborted because of declined dependency: \"+Z.moduleId+\" in \"+Z.parentId+W));break;case\"unaccepted\":n.onUnaccepted&&n.onUnaccepted(Z),n.ignoreUnaccepted||(m=new Error(\"Aborted because \"+b+\" is not accepted\"+W));break;case\"accepted\":n.onAccepted&&n.onAccepted(Z),x=!0;break;case\"disposed\":n.onDisposed&&n.onDisposed(Z),H=!0;break;default:throw new Error(\"Unexception type \"+Z.type)}if(m)return d(\"abort\"),Promise.reject(m);if(x)for(b in u[b]=X[b],a(Q,Z.outdatedModules),Z.outdatedDependencies)Object.prototype.hasOwnProperty.call(Z.outdatedDependencies,b)&&(G[b]||(G[b]=[]),a(G[b],Z.outdatedDependencies[b]));H&&(a(Q,[Z.moduleId]),u[b]=F)}var p,h=[];for(I=0;I<Q.length;I++)b=Q[I],U[b]&&U[b].hot._selfAccepted&&h.push({module:b,errorHandler:U[b].hot._selfAccepted});d(\"dispose\"),Object.keys(o).forEach(function(c){!1===o[c]&&function(c){delete installedChunks[c]}(c)});for(var J,N,R=Q.slice();R.length>0;)if(b=R.pop(),B=U[b]){var v={},Y=B.hot._disposeHandlers;for(r=0;r<Y.length;r++)(g=Y[r])(v);for(e[b]=v,B.hot.active=!1,delete U[b],delete G[b],r=0;r<B.children.length;r++){var S=U[B.children[r]];S&&((p=S.parents.indexOf(b))>=0&&S.parents.splice(p,1))}}for(b in G)if(Object.prototype.hasOwnProperty.call(G,b)&&(B=U[b]))for(N=G[b],r=0;r<N.length;r++)J=N[r],(p=B.children.indexOf(J))>=0&&B.children.splice(p,1);for(b in d(\"apply\"),l=s,u)Object.prototype.hasOwnProperty.call(u,b)&&(c[b]=u[b]);var w=null;for(b in G)if(Object.prototype.hasOwnProperty.call(G,b)&&(B=U[b])){N=G[b];var O=[];for(I=0;I<N.length;I++)if(J=N[I],g=B.hot._acceptedDependencies[J]){if(O.includes(g))continue;O.push(g)}for(I=0;I<O.length;I++){g=O[I];try{g(N)}catch(c){n.onErrored&&n.onErrored({type:\"accept-errored\",moduleId:b,dependencyId:N[I],error:c}),n.ignoreErrored||w||(w=c)}}}for(I=0;I<h.length;I++){var k=h[I];b=k.module,t=[b];try{V(b)}catch(c){if(\"function\"==typeof k.errorHandler)try{k.errorHandler(c)}catch(g){n.onErrored&&n.onErrored({type:\"self-accept-error-handler-errored\",moduleId:b,error:g,originalError:c}),n.ignoreErrored||w||(w=g),w||(w=c)}else n.onErrored&&n.onErrored({type:\"self-accept-errored\",moduleId:b,error:c}),n.ignoreErrored||w||(w=c)}}return w?(d(\"fail\"),Promise.reject(w)):(d(\"idle\"),new Promise(function(c){c(Q)}))}var U={};function V(n){if(U[n])return U[n].exports;var I=U[n]={i:n,l:!1,exports:{},hot:function(c){var n={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:g!==c,active:!0,accept:function(c,g){if(void 0===c)n._selfAccepted=!0;else if(\"function\"==typeof c)n._selfAccepted=c;else if(\"object\"==typeof c)for(var I=0;I<c.length;I++)n._acceptedDependencies[c[I]]=g||function(){};else n._acceptedDependencies[c]=g||function(){}},decline:function(c){if(void 0===c)n._selfDeclined=!0;else if(\"object\"==typeof c)for(var g=0;g<c.length;g++)n._declinedDependencies[c[g]]=!0;else n._declinedDependencies[c]=!0},dispose:function(c){n._disposeHandlers.push(c)},addDisposeHandler:function(c){n._disposeHandlers.push(c)},removeDisposeHandler:function(c){var g=n._disposeHandlers.indexOf(c);g>=0&&n._disposeHandlers.splice(g,1)},check:y,apply:x,status:function(c){if(!c)return C;i.push(c)},addStatusHandler:function(c){i.push(c)},removeStatusHandler:function(c){var n=i.indexOf(c);n>=0&&i.splice(n,1)},data:e[c]};return g=void 0,n}(n),parents:(B=t,t=[],B),children:[]};return c[n].call(I.exports,I,I.exports,b(n)),I.l=!0,I.exports}V.m=c,V.c=U,V.d=function(c,n,g){V.o(c,n)||Object.defineProperty(c,n,{configurable:!1,enumerable:!0,get:g})},V.r=function(c){Object.defineProperty(c,\"__esModule\",{value:!0})},V.n=function(c){var n=c&&c.__esModule?function(){return c.default}:function(){return c};return V.d(n,\"a\",n),n},V.o=function(c,n){return Object.prototype.hasOwnProperty.call(c,n)},V.p=\"/dist/\",V.h=function(){return l},b(52)(V.s=52)}([function(module,exports){eval(\"var Vue // late bind\\r\\nvar version\\r\\nvar map = Object.create(null)\\r\\nif (typeof window !== 'undefined') {\\r\\n  window.__VUE_HOT_MAP__ = map\\r\\n}\\r\\nvar installed = false\\r\\nvar isBrowserify = false\\r\\nvar initHookName = 'beforeCreate'\\r\\n\\r\\nexports.install = function (vue, browserify) {\\r\\n  if (installed) { return }\\r\\n  installed = true\\r\\n\\r\\n  Vue = vue.__esModule ? vue.default : vue\\r\\n  version = Vue.version.split('.').map(Number)\\r\\n  isBrowserify = browserify\\r\\n\\r\\n  // compat with < 2.0.0-alpha.7\\r\\n  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {\\r\\n    initHookName = 'init'\\r\\n  }\\r\\n\\r\\n  exports.compatible = version[0] >= 2\\r\\n  if (!exports.compatible) {\\r\\n    console.warn(\\r\\n      '[HMR] You are using a version of vue-hot-reload-api that is ' +\\r\\n        'only compatible with Vue.js core ^2.0.0.'\\r\\n    )\\r\\n    return\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Create a record for a hot module, which keeps track of its constructor\\r\\n * and instances\\r\\n *\\r\\n * @param {String} id\\r\\n * @param {Object} options\\r\\n */\\r\\n\\r\\nexports.createRecord = function (id, options) {\\r\\n  if(map[id]) { return }\\r\\n\\r\\n  var Ctor = null\\r\\n  if (typeof options === 'function') {\\r\\n    Ctor = options\\r\\n    options = Ctor.options\\r\\n  }\\r\\n  makeOptionsHot(id, options)\\r\\n  map[id] = {\\r\\n    Ctor: Ctor,\\r\\n    options: options,\\r\\n    instances: []\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if module is recorded\\r\\n *\\r\\n * @param {String} id\\r\\n */\\r\\n\\r\\nexports.isRecorded = function (id) {\\r\\n  return typeof map[id] !== 'undefined'\\r\\n}\\r\\n\\r\\n/**\\r\\n * Make a Component options object hot.\\r\\n *\\r\\n * @param {String} id\\r\\n * @param {Object} options\\r\\n */\\r\\n\\r\\nfunction makeOptionsHot(id, options) {\\r\\n  if (options.functional) {\\r\\n    var render = options.render\\r\\n    options.render = function (h, ctx) {\\r\\n      var instances = map[id].instances\\r\\n      if (ctx && instances.indexOf(ctx.parent) < 0) {\\r\\n        instances.push(ctx.parent)\\r\\n      }\\r\\n      return render(h, ctx)\\r\\n    }\\r\\n  } else {\\r\\n    injectHook(options, initHookName, function() {\\r\\n      var record = map[id]\\r\\n      if (!record.Ctor) {\\r\\n        record.Ctor = this.constructor\\r\\n      }\\r\\n      record.instances.push(this)\\r\\n    })\\r\\n    injectHook(options, 'beforeDestroy', function() {\\r\\n      var instances = map[id].instances\\r\\n      instances.splice(instances.indexOf(this), 1)\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Inject a hook to a hot reloadable component so that\\r\\n * we can keep track of it.\\r\\n *\\r\\n * @param {Object} options\\r\\n * @param {String} name\\r\\n * @param {Function} hook\\r\\n */\\r\\n\\r\\nfunction injectHook(options, name, hook) {\\r\\n  var existing = options[name]\\r\\n  options[name] = existing\\r\\n    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]\\r\\n    : [hook]\\r\\n}\\r\\n\\r\\nfunction tryWrap(fn) {\\r\\n  return function (id, arg) {\\r\\n    try {\\r\\n      fn(id, arg)\\r\\n    } catch (e) {\\r\\n      console.error(e)\\r\\n      console.warn(\\r\\n        'Something went wrong during Vue component hot-reload. Full reload required.'\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction updateOptions (oldOptions, newOptions) {\\r\\n  for (var key in oldOptions) {\\r\\n    if (!(key in newOptions)) {\\r\\n      delete oldOptions[key]\\r\\n    }\\r\\n  }\\r\\n  for (var key$1 in newOptions) {\\r\\n    oldOptions[key$1] = newOptions[key$1]\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.rerender = tryWrap(function (id, options) {\\r\\n  var record = map[id]\\r\\n  if (!options) {\\r\\n    record.instances.slice().forEach(function (instance) {\\r\\n      instance.$forceUpdate()\\r\\n    })\\r\\n    return\\r\\n  }\\r\\n  if (typeof options === 'function') {\\r\\n    options = options.options\\r\\n  }\\r\\n  if (record.Ctor) {\\r\\n    record.Ctor.options.render = options.render\\r\\n    record.Ctor.options.staticRenderFns = options.staticRenderFns\\r\\n    record.instances.slice().forEach(function (instance) {\\r\\n      instance.$options.render = options.render\\r\\n      instance.$options.staticRenderFns = options.staticRenderFns\\r\\n      // reset static trees\\r\\n      // pre 2.5, all static trees are cached together on the instance\\r\\n      if (instance._staticTrees) {\\r\\n        instance._staticTrees = []\\r\\n      }\\r\\n      // 2.5.0\\r\\n      if (Array.isArray(record.Ctor.options.cached)) {\\r\\n        record.Ctor.options.cached = []\\r\\n      }\\r\\n      // 2.5.3\\r\\n      if (Array.isArray(instance.$options.cached)) {\\r\\n        instance.$options.cached = []\\r\\n      }\\r\\n      // post 2.5.4: v-once trees are cached on instance._staticTrees.\\r\\n      // Pure static trees are cached on the staticRenderFns array\\r\\n      // (both already reset above)\\r\\n      instance.$forceUpdate()\\r\\n    })\\r\\n  } else {\\r\\n    // functional or no instance created yet\\r\\n    record.options.render = options.render\\r\\n    record.options.staticRenderFns = options.staticRenderFns\\r\\n\\r\\n    // handle functional component re-render\\r\\n    if (record.options.functional) {\\r\\n      // rerender with full options\\r\\n      if (Object.keys(options).length > 2) {\\r\\n        updateOptions(record.options, options)\\r\\n      } else {\\r\\n        // template-only rerender.\\r\\n        // need to inject the style injection code for CSS modules\\r\\n        // to work properly.\\r\\n        var injectStyles = record.options._injectStyles\\r\\n        if (injectStyles) {\\r\\n          var render = options.render\\r\\n          record.options.render = function (h, ctx) {\\r\\n            injectStyles.call(ctx)\\r\\n            return render(h, ctx)\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      record.options._Ctor = null\\r\\n      // 2.5.3\\r\\n      if (Array.isArray(record.options.cached)) {\\r\\n        record.options.cached = []\\r\\n      }\\r\\n      record.instances.slice().forEach(function (instance) {\\r\\n        instance.$forceUpdate()\\r\\n      })\\r\\n    }\\r\\n  }\\r\\n})\\r\\n\\r\\nexports.reload = tryWrap(function (id, options) {\\r\\n  var record = map[id]\\r\\n  if (options) {\\r\\n    if (typeof options === 'function') {\\r\\n      options = options.options\\r\\n    }\\r\\n    makeOptionsHot(id, options)\\r\\n    if (record.Ctor) {\\r\\n      if (version[1] < 2) {\\r\\n        // preserve pre 2.2 behavior for global mixin handling\\r\\n        record.Ctor.extendOptions = options\\r\\n      }\\r\\n      var newCtor = record.Ctor.super.extend(options)\\r\\n      record.Ctor.options = newCtor.options\\r\\n      record.Ctor.cid = newCtor.cid\\r\\n      record.Ctor.prototype = newCtor.prototype\\r\\n      if (newCtor.release) {\\r\\n        // temporary global mixin strategy used in < 2.0.0-alpha.6\\r\\n        newCtor.release()\\r\\n      }\\r\\n    } else {\\r\\n      updateOptions(record.options, options)\\r\\n    }\\r\\n  }\\r\\n  record.instances.slice().forEach(function (instance) {\\r\\n    if (instance.$vnode && instance.$vnode.context) {\\r\\n      instance.$vnode.context.$forceUpdate()\\r\\n    } else {\\r\\n      console.warn(\\r\\n        'Root or manually mounted instance modified. Full reload required.'\\r\\n      )\\r\\n    }\\r\\n  })\\r\\n})\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanM/NjQzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBWdWUgLy8gbGF0ZSBiaW5kXHJcbnZhciB2ZXJzaW9uXHJcbnZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHdpbmRvdy5fX1ZVRV9IT1RfTUFQX18gPSBtYXBcclxufVxyXG52YXIgaW5zdGFsbGVkID0gZmFsc2VcclxudmFyIGlzQnJvd3NlcmlmeSA9IGZhbHNlXHJcbnZhciBpbml0SG9va05hbWUgPSAnYmVmb3JlQ3JlYXRlJ1xyXG5cclxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKHZ1ZSwgYnJvd3NlcmlmeSkge1xyXG4gIGlmIChpbnN0YWxsZWQpIHsgcmV0dXJuIH1cclxuICBpbnN0YWxsZWQgPSB0cnVlXHJcblxyXG4gIFZ1ZSA9IHZ1ZS5fX2VzTW9kdWxlID8gdnVlLmRlZmF1bHQgOiB2dWVcclxuICB2ZXJzaW9uID0gVnVlLnZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKVxyXG4gIGlzQnJvd3NlcmlmeSA9IGJyb3dzZXJpZnlcclxuXHJcbiAgLy8gY29tcGF0IHdpdGggPCAyLjAuMC1hbHBoYS43XHJcbiAgaWYgKFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xKSB7XHJcbiAgICBpbml0SG9va05hbWUgPSAnaW5pdCdcclxuICB9XHJcblxyXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9IHZlcnNpb25bMF0gPj0gMlxyXG4gIGlmICghZXhwb3J0cy5jb21wYXRpYmxlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICdbSE1SXSBZb3UgYXJlIHVzaW5nIGEgdmVyc2lvbiBvZiB2dWUtaG90LXJlbG9hZC1hcGkgdGhhdCBpcyAnICtcclxuICAgICAgICAnb25seSBjb21wYXRpYmxlIHdpdGggVnVlLmpzIGNvcmUgXjIuMC4wLidcclxuICAgIClcclxuICAgIHJldHVyblxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWN0b3JcclxuICogYW5kIGluc3RhbmNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICovXHJcblxyXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG4gIGlmKG1hcFtpZF0pIHsgcmV0dXJuIH1cclxuXHJcbiAgdmFyIEN0b3IgPSBudWxsXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBDdG9yID0gb3B0aW9uc1xyXG4gICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9uc1xyXG4gIH1cclxuICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcclxuICBtYXBbaWRdID0ge1xyXG4gICAgQ3RvcjogQ3RvcixcclxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICBpbnN0YW5jZXM6IFtdXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgbW9kdWxlIGlzIHJlY29yZGVkXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxyXG4gKi9cclxuXHJcbmV4cG9ydHMuaXNSZWNvcmRlZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gIHJldHVybiB0eXBlb2YgbWFwW2lkXSAhPT0gJ3VuZGVmaW5lZCdcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBDb21wb25lbnQgb3B0aW9ucyBvYmplY3QgaG90LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICovXHJcblxyXG5mdW5jdGlvbiBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucykge1xyXG4gIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcclxuICAgIHZhciByZW5kZXIgPSBvcHRpb25zLnJlbmRlclxyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XHJcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xyXG4gICAgICBpZiAoY3R4ICYmIGluc3RhbmNlcy5pbmRleE9mKGN0eC5wYXJlbnQpIDwgMCkge1xyXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKGN0eC5wYXJlbnQpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlbmRlcihoLCBjdHgpXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGluamVjdEhvb2sob3B0aW9ucywgaW5pdEhvb2tOYW1lLCBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHJlY29yZCA9IG1hcFtpZF1cclxuICAgICAgaWYgKCFyZWNvcmQuQ3Rvcikge1xyXG4gICAgICAgIHJlY29yZC5DdG9yID0gdGhpcy5jb25zdHJ1Y3RvclxyXG4gICAgICB9XHJcbiAgICAgIHJlY29yZC5pbnN0YW5jZXMucHVzaCh0aGlzKVxyXG4gICAgfSlcclxuICAgIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGluc3RhbmNlcyA9IG1hcFtpZF0uaW5zdGFuY2VzXHJcbiAgICAgIGluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VzLmluZGV4T2YodGhpcyksIDEpXHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEluamVjdCBhIGhvb2sgdG8gYSBob3QgcmVsb2FkYWJsZSBjb21wb25lbnQgc28gdGhhdFxyXG4gKiB3ZSBjYW4ga2VlcCB0cmFjayBvZiBpdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGluamVjdEhvb2sob3B0aW9ucywgbmFtZSwgaG9vaykge1xyXG4gIHZhciBleGlzdGluZyA9IG9wdGlvbnNbbmFtZV1cclxuICBvcHRpb25zW25hbWVdID0gZXhpc3RpbmdcclxuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZykgPyBleGlzdGluZy5jb25jYXQoaG9vaykgOiBbZXhpc3RpbmcsIGhvb2tdXHJcbiAgICA6IFtob29rXVxyXG59XHJcblxyXG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgYXJnKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBmbihpZCwgYXJnKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGUpXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zIChvbGRPcHRpb25zLCBuZXdPcHRpb25zKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIG9sZE9wdGlvbnMpIHtcclxuICAgIGlmICghKGtleSBpbiBuZXdPcHRpb25zKSkge1xyXG4gICAgICBkZWxldGUgb2xkT3B0aW9uc1trZXldXHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAodmFyIGtleSQxIGluIG5ld09wdGlvbnMpIHtcclxuICAgIG9sZE9wdGlvbnNba2V5JDFdID0gbmV3T3B0aW9uc1trZXkkMV1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMucmVyZW5kZXIgPSB0cnlXcmFwKGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXHJcbiAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcclxuICAgIH0pXHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXHJcbiAgfVxyXG4gIGlmIChyZWNvcmQuQ3Rvcikge1xyXG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxyXG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xyXG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXHJcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXHJcbiAgICAgIC8vIHJlc2V0IHN0YXRpYyB0cmVlc1xyXG4gICAgICAvLyBwcmUgMi41LCBhbGwgc3RhdGljIHRyZWVzIGFyZSBjYWNoZWQgdG9nZXRoZXIgb24gdGhlIGluc3RhbmNlXHJcbiAgICAgIGlmIChpbnN0YW5jZS5fc3RhdGljVHJlZXMpIHtcclxuICAgICAgICBpbnN0YW5jZS5fc3RhdGljVHJlZXMgPSBbXVxyXG4gICAgICB9XHJcbiAgICAgIC8vIDIuNS4wXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkKSkge1xyXG4gICAgICAgIHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkID0gW11cclxuICAgICAgfVxyXG4gICAgICAvLyAyLjUuM1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnN0YW5jZS4kb3B0aW9ucy5jYWNoZWQpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkID0gW11cclxuICAgICAgfVxyXG4gICAgICAvLyBwb3N0IDIuNS40OiB2LW9uY2UgdHJlZXMgYXJlIGNhY2hlZCBvbiBpbnN0YW5jZS5fc3RhdGljVHJlZXMuXHJcbiAgICAgIC8vIFB1cmUgc3RhdGljIHRyZWVzIGFyZSBjYWNoZWQgb24gdGhlIHN0YXRpY1JlbmRlckZucyBhcnJheVxyXG4gICAgICAvLyAoYm90aCBhbHJlYWR5IHJlc2V0IGFib3ZlKVxyXG4gICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxyXG4gICAgfSlcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZnVuY3Rpb25hbCBvciBubyBpbnN0YW5jZSBjcmVhdGVkIHlldFxyXG4gICAgcmVjb3JkLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcclxuICAgIHJlY29yZC5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXHJcblxyXG4gICAgLy8gaGFuZGxlIGZ1bmN0aW9uYWwgY29tcG9uZW50IHJlLXJlbmRlclxyXG4gICAgaWYgKHJlY29yZC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcclxuICAgICAgLy8gcmVyZW5kZXIgd2l0aCBmdWxsIG9wdGlvbnNcclxuICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHRlbXBsYXRlLW9ubHkgcmVyZW5kZXIuXHJcbiAgICAgICAgLy8gbmVlZCB0byBpbmplY3QgdGhlIHN0eWxlIGluamVjdGlvbiBjb2RlIGZvciBDU1MgbW9kdWxlc1xyXG4gICAgICAgIC8vIHRvIHdvcmsgcHJvcGVybHkuXHJcbiAgICAgICAgdmFyIGluamVjdFN0eWxlcyA9IHJlY29yZC5vcHRpb25zLl9pbmplY3RTdHlsZXNcclxuICAgICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XHJcbiAgICAgICAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcclxuICAgICAgICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcclxuICAgICAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoY3R4KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmVjb3JkLm9wdGlvbnMuX0N0b3IgPSBudWxsXHJcbiAgICAgIC8vIDIuNS4zXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5vcHRpb25zLmNhY2hlZCkpIHtcclxuICAgICAgICByZWNvcmQub3B0aW9ucy5jYWNoZWQgPSBbXVxyXG4gICAgICB9XHJcbiAgICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuZXhwb3J0cy5yZWxvYWQgPSB0cnlXcmFwKGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXHJcbiAgICB9XHJcbiAgICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcclxuICAgIGlmIChyZWNvcmQuQ3Rvcikge1xyXG4gICAgICBpZiAodmVyc2lvblsxXSA8IDIpIHtcclxuICAgICAgICAvLyBwcmVzZXJ2ZSBwcmUgMi4yIGJlaGF2aW9yIGZvciBnbG9iYWwgbWl4aW4gaGFuZGxpbmdcclxuICAgICAgICByZWNvcmQuQ3Rvci5leHRlbmRPcHRpb25zID0gb3B0aW9uc1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBuZXdDdG9yID0gcmVjb3JkLkN0b3Iuc3VwZXIuZXh0ZW5kKG9wdGlvbnMpXHJcbiAgICAgIHJlY29yZC5DdG9yLm9wdGlvbnMgPSBuZXdDdG9yLm9wdGlvbnNcclxuICAgICAgcmVjb3JkLkN0b3IuY2lkID0gbmV3Q3Rvci5jaWRcclxuICAgICAgcmVjb3JkLkN0b3IucHJvdG90eXBlID0gbmV3Q3Rvci5wcm90b3R5cGVcclxuICAgICAgaWYgKG5ld0N0b3IucmVsZWFzZSkge1xyXG4gICAgICAgIC8vIHRlbXBvcmFyeSBnbG9iYWwgbWl4aW4gc3RyYXRlZ3kgdXNlZCBpbiA8IDIuMC4wLWFscGhhLjZcclxuICAgICAgICBuZXdDdG9yLnJlbGVhc2UoKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxyXG4gICAgfVxyXG4gIH1cclxuICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZS4kdm5vZGUgJiYgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQpIHtcclxuICAgICAgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQuJGZvcmNlVXBkYXRlKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9KVxyXG59KVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///0\\n\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\\r\\n * Vue.js v2.5.18\\r\\n * (c) 2014-2018 Evan You\\r\\n * Released under the MIT License.\\r\\n */\\r\\n/*  */\\r\\n\\r\\nvar emptyObject = Object.freeze({});\\r\\n\\r\\n// These helpers produce better VM code in JS engines due to their\\r\\n// explicitness and function inlining.\\r\\nfunction isUndef (v) {\\r\\n  return v === undefined || v === null\\r\\n}\\r\\n\\r\\nfunction isDef (v) {\\r\\n  return v !== undefined && v !== null\\r\\n}\\r\\n\\r\\nfunction isTrue (v) {\\r\\n  return v === true\\r\\n}\\r\\n\\r\\nfunction isFalse (v) {\\r\\n  return v === false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if value is primitive.\\r\\n */\\r\\nfunction isPrimitive (value) {\\r\\n  return (\\r\\n    typeof value === 'string' ||\\r\\n    typeof value === 'number' ||\\r\\n    // $flow-disable-line\\r\\n    typeof value === 'symbol' ||\\r\\n    typeof value === 'boolean'\\r\\n  )\\r\\n}\\r\\n\\r\\n/**\\r\\n * Quick object check - this is primarily used to tell\\r\\n * Objects from primitive values when we know the value\\r\\n * is a JSON-compliant type.\\r\\n */\\r\\nfunction isObject (obj) {\\r\\n  return obj !== null && typeof obj === 'object'\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get the raw type string of a value, e.g., [object Object].\\r\\n */\\r\\nvar _toString = Object.prototype.toString;\\r\\n\\r\\nfunction toRawType (value) {\\r\\n  return _toString.call(value).slice(8, -1)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Strict object type check. Only returns true\\r\\n * for plain JavaScript objects.\\r\\n */\\r\\nfunction isPlainObject (obj) {\\r\\n  return _toString.call(obj) === '[object Object]'\\r\\n}\\r\\n\\r\\nfunction isRegExp (v) {\\r\\n  return _toString.call(v) === '[object RegExp]'\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if val is a valid array index.\\r\\n */\\r\\nfunction isValidArrayIndex (val) {\\r\\n  var n = parseFloat(String(val));\\r\\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Convert a value to a string that is actually rendered.\\r\\n */\\r\\nfunction toString (val) {\\r\\n  return val == null\\r\\n    ? ''\\r\\n    : typeof val === 'object'\\r\\n      ? JSON.stringify(val, null, 2)\\r\\n      : String(val)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Convert an input value to a number for persistence.\\r\\n * If the conversion fails, return original string.\\r\\n */\\r\\nfunction toNumber (val) {\\r\\n  var n = parseFloat(val);\\r\\n  return isNaN(n) ? val : n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Make a map and return a function for checking if a key\\r\\n * is in that map.\\r\\n */\\r\\nfunction makeMap (\\r\\n  str,\\r\\n  expectsLowerCase\\r\\n) {\\r\\n  var map = Object.create(null);\\r\\n  var list = str.split(',');\\r\\n  for (var i = 0; i < list.length; i++) {\\r\\n    map[list[i]] = true;\\r\\n  }\\r\\n  return expectsLowerCase\\r\\n    ? function (val) { return map[val.toLowerCase()]; }\\r\\n    : function (val) { return map[val]; }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if a tag is a built-in tag.\\r\\n */\\r\\nvar isBuiltInTag = makeMap('slot,component', true);\\r\\n\\r\\n/**\\r\\n * Check if an attribute is a reserved attribute.\\r\\n */\\r\\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\\r\\n\\r\\n/**\\r\\n * Remove an item from an array.\\r\\n */\\r\\nfunction remove (arr, item) {\\r\\n  if (arr.length) {\\r\\n    var index = arr.indexOf(item);\\r\\n    if (index > -1) {\\r\\n      return arr.splice(index, 1)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check whether an object has the property.\\r\\n */\\r\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\r\\nfunction hasOwn (obj, key) {\\r\\n  return hasOwnProperty.call(obj, key)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Create a cached version of a pure function.\\r\\n */\\r\\nfunction cached (fn) {\\r\\n  var cache = Object.create(null);\\r\\n  return (function cachedFn (str) {\\r\\n    var hit = cache[str];\\r\\n    return hit || (cache[str] = fn(str))\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * Camelize a hyphen-delimited string.\\r\\n */\\r\\nvar camelizeRE = /-(\\\\w)/g;\\r\\nvar camelize = cached(function (str) {\\r\\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\\r\\n});\\r\\n\\r\\n/**\\r\\n * Capitalize a string.\\r\\n */\\r\\nvar capitalize = cached(function (str) {\\r\\n  return str.charAt(0).toUpperCase() + str.slice(1)\\r\\n});\\r\\n\\r\\n/**\\r\\n * Hyphenate a camelCase string.\\r\\n */\\r\\nvar hyphenateRE = /\\\\B([A-Z])/g;\\r\\nvar hyphenate = cached(function (str) {\\r\\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\\r\\n});\\r\\n\\r\\n/**\\r\\n * Simple bind polyfill for environments that do not support it,\\r\\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\\r\\n * since native bind is now performant enough in most browsers.\\r\\n * But removing it would mean breaking code that was able to run in\\r\\n * PhantomJS 1.x, so this must be kept for backward compatibility.\\r\\n */\\r\\n\\r\\n/* istanbul ignore next */\\r\\nfunction polyfillBind (fn, ctx) {\\r\\n  function boundFn (a) {\\r\\n    var l = arguments.length;\\r\\n    return l\\r\\n      ? l > 1\\r\\n        ? fn.apply(ctx, arguments)\\r\\n        : fn.call(ctx, a)\\r\\n      : fn.call(ctx)\\r\\n  }\\r\\n\\r\\n  boundFn._length = fn.length;\\r\\n  return boundFn\\r\\n}\\r\\n\\r\\nfunction nativeBind (fn, ctx) {\\r\\n  return fn.bind(ctx)\\r\\n}\\r\\n\\r\\nvar bind = Function.prototype.bind\\r\\n  ? nativeBind\\r\\n  : polyfillBind;\\r\\n\\r\\n/**\\r\\n * Convert an Array-like object to a real Array.\\r\\n */\\r\\nfunction toArray (list, start) {\\r\\n  start = start || 0;\\r\\n  var i = list.length - start;\\r\\n  var ret = new Array(i);\\r\\n  while (i--) {\\r\\n    ret[i] = list[i + start];\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\n/**\\r\\n * Mix properties into target object.\\r\\n */\\r\\nfunction extend (to, _from) {\\r\\n  for (var key in _from) {\\r\\n    to[key] = _from[key];\\r\\n  }\\r\\n  return to\\r\\n}\\r\\n\\r\\n/**\\r\\n * Merge an Array of Objects into a single Object.\\r\\n */\\r\\nfunction toObject (arr) {\\r\\n  var res = {};\\r\\n  for (var i = 0; i < arr.length; i++) {\\r\\n    if (arr[i]) {\\r\\n      extend(res, arr[i]);\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\n/* eslint-disable no-unused-vars */\\r\\n\\r\\n/**\\r\\n * Perform no operation.\\r\\n * Stubbing args to make Flow happy without leaving useless transpiled code\\r\\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\\r\\n */\\r\\nfunction noop (a, b, c) {}\\r\\n\\r\\n/**\\r\\n * Always return false.\\r\\n */\\r\\nvar no = function (a, b, c) { return false; };\\r\\n\\r\\n/* eslint-enable no-unused-vars */\\r\\n\\r\\n/**\\r\\n * Return the same value.\\r\\n */\\r\\nvar identity = function (_) { return _; };\\r\\n\\r\\n/**\\r\\n * Generate a string containing static keys from compiler modules.\\r\\n */\\r\\nfunction genStaticKeys (modules) {\\r\\n  return modules.reduce(function (keys, m) {\\r\\n    return keys.concat(m.staticKeys || [])\\r\\n  }, []).join(',')\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if two values are loosely equal - that is,\\r\\n * if they are plain objects, do they have the same shape?\\r\\n */\\r\\nfunction looseEqual (a, b) {\\r\\n  if (a === b) { return true }\\r\\n  var isObjectA = isObject(a);\\r\\n  var isObjectB = isObject(b);\\r\\n  if (isObjectA && isObjectB) {\\r\\n    try {\\r\\n      var isArrayA = Array.isArray(a);\\r\\n      var isArrayB = Array.isArray(b);\\r\\n      if (isArrayA && isArrayB) {\\r\\n        return a.length === b.length && a.every(function (e, i) {\\r\\n          return looseEqual(e, b[i])\\r\\n        })\\r\\n      } else if (a instanceof Date && b instanceof Date) {\\r\\n        return a.getTime() === b.getTime()\\r\\n      } else if (!isArrayA && !isArrayB) {\\r\\n        var keysA = Object.keys(a);\\r\\n        var keysB = Object.keys(b);\\r\\n        return keysA.length === keysB.length && keysA.every(function (key) {\\r\\n          return looseEqual(a[key], b[key])\\r\\n        })\\r\\n      } else {\\r\\n        /* istanbul ignore next */\\r\\n        return false\\r\\n      }\\r\\n    } catch (e) {\\r\\n      /* istanbul ignore next */\\r\\n      return false\\r\\n    }\\r\\n  } else if (!isObjectA && !isObjectB) {\\r\\n    return String(a) === String(b)\\r\\n  } else {\\r\\n    return false\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Return the first index at which a loosely equal value can be\\r\\n * found in the array (if value is a plain object, the array must\\r\\n * contain an object of the same shape), or -1 if it is not present.\\r\\n */\\r\\nfunction looseIndexOf (arr, val) {\\r\\n  for (var i = 0; i < arr.length; i++) {\\r\\n    if (looseEqual(arr[i], val)) { return i }\\r\\n  }\\r\\n  return -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Ensure a function is called only once.\\r\\n */\\r\\nfunction once (fn) {\\r\\n  var called = false;\\r\\n  return function () {\\r\\n    if (!called) {\\r\\n      called = true;\\r\\n      fn.apply(this, arguments);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar SSR_ATTR = 'data-server-rendered';\\r\\n\\r\\nvar ASSET_TYPES = [\\r\\n  'component',\\r\\n  'directive',\\r\\n  'filter'\\r\\n];\\r\\n\\r\\nvar LIFECYCLE_HOOKS = [\\r\\n  'beforeCreate',\\r\\n  'created',\\r\\n  'beforeMount',\\r\\n  'mounted',\\r\\n  'beforeUpdate',\\r\\n  'updated',\\r\\n  'beforeDestroy',\\r\\n  'destroyed',\\r\\n  'activated',\\r\\n  'deactivated',\\r\\n  'errorCaptured'\\r\\n];\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nvar config = ({\\r\\n  /**\\r\\n   * Option merge strategies (used in core/util/options)\\r\\n   */\\r\\n  // $flow-disable-line\\r\\n  optionMergeStrategies: Object.create(null),\\r\\n\\r\\n  /**\\r\\n   * Whether to suppress warnings.\\r\\n   */\\r\\n  silent: false,\\r\\n\\r\\n  /**\\r\\n   * Show production mode tip message on boot?\\r\\n   */\\r\\n  productionTip: \\\"production\\\" !== 'production',\\r\\n\\r\\n  /**\\r\\n   * Whether to enable devtools\\r\\n   */\\r\\n  devtools: \\\"production\\\" !== 'production',\\r\\n\\r\\n  /**\\r\\n   * Whether to record perf\\r\\n   */\\r\\n  performance: false,\\r\\n\\r\\n  /**\\r\\n   * Error handler for watcher errors\\r\\n   */\\r\\n  errorHandler: null,\\r\\n\\r\\n  /**\\r\\n   * Warn handler for watcher warns\\r\\n   */\\r\\n  warnHandler: null,\\r\\n\\r\\n  /**\\r\\n   * Ignore certain custom elements\\r\\n   */\\r\\n  ignoredElements: [],\\r\\n\\r\\n  /**\\r\\n   * Custom user key aliases for v-on\\r\\n   */\\r\\n  // $flow-disable-line\\r\\n  keyCodes: Object.create(null),\\r\\n\\r\\n  /**\\r\\n   * Check if a tag is reserved so that it cannot be registered as a\\r\\n   * component. This is platform-dependent and may be overwritten.\\r\\n   */\\r\\n  isReservedTag: no,\\r\\n\\r\\n  /**\\r\\n   * Check if an attribute is reserved so that it cannot be used as a component\\r\\n   * prop. This is platform-dependent and may be overwritten.\\r\\n   */\\r\\n  isReservedAttr: no,\\r\\n\\r\\n  /**\\r\\n   * Check if a tag is an unknown element.\\r\\n   * Platform-dependent.\\r\\n   */\\r\\n  isUnknownElement: no,\\r\\n\\r\\n  /**\\r\\n   * Get the namespace of an element\\r\\n   */\\r\\n  getTagNamespace: noop,\\r\\n\\r\\n  /**\\r\\n   * Parse the real tag name for the specific platform.\\r\\n   */\\r\\n  parsePlatformTagName: identity,\\r\\n\\r\\n  /**\\r\\n   * Check if an attribute must be bound using property, e.g. value\\r\\n   * Platform-dependent.\\r\\n   */\\r\\n  mustUseProp: no,\\r\\n\\r\\n  /**\\r\\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\\r\\n   * This will significantly reduce performance if set to false.\\r\\n   */\\r\\n  async: true,\\r\\n\\r\\n  /**\\r\\n   * Exposed for legacy reasons\\r\\n   */\\r\\n  _lifecycleHooks: LIFECYCLE_HOOKS\\r\\n});\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Check if a string starts with $ or _\\r\\n */\\r\\nfunction isReserved (str) {\\r\\n  var c = (str + '').charCodeAt(0);\\r\\n  return c === 0x24 || c === 0x5F\\r\\n}\\r\\n\\r\\n/**\\r\\n * Define a property.\\r\\n */\\r\\nfunction def (obj, key, val, enumerable) {\\r\\n  Object.defineProperty(obj, key, {\\r\\n    value: val,\\r\\n    enumerable: !!enumerable,\\r\\n    writable: true,\\r\\n    configurable: true\\r\\n  });\\r\\n}\\r\\n\\r\\n/**\\r\\n * Parse simple path.\\r\\n */\\r\\nvar bailRE = /[^\\\\w.$]/;\\r\\nfunction parsePath (path) {\\r\\n  if (bailRE.test(path)) {\\r\\n    return\\r\\n  }\\r\\n  var segments = path.split('.');\\r\\n  return function (obj) {\\r\\n    for (var i = 0; i < segments.length; i++) {\\r\\n      if (!obj) { return }\\r\\n      obj = obj[segments[i]];\\r\\n    }\\r\\n    return obj\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// can we use __proto__?\\r\\nvar hasProto = '__proto__' in {};\\r\\n\\r\\n// Browser environment sniffing\\r\\nvar inBrowser = typeof window !== 'undefined';\\r\\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\\r\\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\\r\\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\\r\\nvar isIE = UA && /msie|trident/.test(UA);\\r\\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\\r\\nvar isEdge = UA && UA.indexOf('edge/') > 0;\\r\\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\\r\\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\\r\\nvar isChrome = UA && /chrome\\\\/\\\\d+/.test(UA) && !isEdge;\\r\\n\\r\\n// Firefox has a \\\"watch\\\" function on Object.prototype...\\r\\nvar nativeWatch = ({}).watch;\\r\\n\\r\\nvar supportsPassive = false;\\r\\nif (inBrowser) {\\r\\n  try {\\r\\n    var opts = {};\\r\\n    Object.defineProperty(opts, 'passive', ({\\r\\n      get: function get () {\\r\\n        /* istanbul ignore next */\\r\\n        supportsPassive = true;\\r\\n      }\\r\\n    })); // https://github.com/facebook/flow/issues/285\\r\\n    window.addEventListener('test-passive', null, opts);\\r\\n  } catch (e) {}\\r\\n}\\r\\n\\r\\n// this needs to be lazy-evaled because vue may be required before\\r\\n// vue-server-renderer can set VUE_ENV\\r\\nvar _isServer;\\r\\nvar isServerRendering = function () {\\r\\n  if (_isServer === undefined) {\\r\\n    /* istanbul ignore if */\\r\\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\\r\\n      // detect presence of vue-server-renderer and avoid\\r\\n      // Webpack shimming the process\\r\\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\\r\\n    } else {\\r\\n      _isServer = false;\\r\\n    }\\r\\n  }\\r\\n  return _isServer\\r\\n};\\r\\n\\r\\n// detect devtools\\r\\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\\r\\n\\r\\n/* istanbul ignore next */\\r\\nfunction isNative (Ctor) {\\r\\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\\r\\n}\\r\\n\\r\\nvar hasSymbol =\\r\\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\\r\\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\\r\\n\\r\\nvar _Set;\\r\\n/* istanbul ignore if */ // $flow-disable-line\\r\\nif (typeof Set !== 'undefined' && isNative(Set)) {\\r\\n  // use native Set when available.\\r\\n  _Set = Set;\\r\\n} else {\\r\\n  // a non-standard Set polyfill that only works with primitive keys.\\r\\n  _Set = /*@__PURE__*/(function () {\\r\\n    function Set () {\\r\\n      this.set = Object.create(null);\\r\\n    }\\r\\n    Set.prototype.has = function has (key) {\\r\\n      return this.set[key] === true\\r\\n    };\\r\\n    Set.prototype.add = function add (key) {\\r\\n      this.set[key] = true;\\r\\n    };\\r\\n    Set.prototype.clear = function clear () {\\r\\n      this.set = Object.create(null);\\r\\n    };\\r\\n\\r\\n    return Set;\\r\\n  }());\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar warn = noop;\\r\\nvar tip = noop;\\r\\nvar generateComponentTrace = (noop); // work around flow check\\r\\nvar formatComponentName = (noop);\\r\\n\\r\\nif (false) { var repeat, classify, classifyRE, hasConsole; }\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar uid = 0;\\r\\n\\r\\n/**\\r\\n * A dep is an observable that can have multiple\\r\\n * directives subscribing to it.\\r\\n */\\r\\nvar Dep = function Dep () {\\r\\n  this.id = uid++;\\r\\n  this.subs = [];\\r\\n};\\r\\n\\r\\nDep.prototype.addSub = function addSub (sub) {\\r\\n  this.subs.push(sub);\\r\\n};\\r\\n\\r\\nDep.prototype.removeSub = function removeSub (sub) {\\r\\n  remove(this.subs, sub);\\r\\n};\\r\\n\\r\\nDep.prototype.depend = function depend () {\\r\\n  if (Dep.target) {\\r\\n    Dep.target.addDep(this);\\r\\n  }\\r\\n};\\r\\n\\r\\nDep.prototype.notify = function notify () {\\r\\n  // stabilize the subscriber list first\\r\\n  var subs = this.subs.slice();\\r\\n  if (false) {}\\r\\n  for (var i = 0, l = subs.length; i < l; i++) {\\r\\n    subs[i].update();\\r\\n  }\\r\\n};\\r\\n\\r\\n// the current target watcher being evaluated.\\r\\n// this is globally unique because there could be only one\\r\\n// watcher being evaluated at any time.\\r\\nDep.target = null;\\r\\nvar targetStack = [];\\r\\n\\r\\nfunction pushTarget (target) {\\r\\n  targetStack.push(target);\\r\\n  Dep.target = target;\\r\\n}\\r\\n\\r\\nfunction popTarget () {\\r\\n  targetStack.pop();\\r\\n  Dep.target = targetStack[targetStack.length - 1];\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar VNode = function VNode (\\r\\n  tag,\\r\\n  data,\\r\\n  children,\\r\\n  text,\\r\\n  elm,\\r\\n  context,\\r\\n  componentOptions,\\r\\n  asyncFactory\\r\\n) {\\r\\n  this.tag = tag;\\r\\n  this.data = data;\\r\\n  this.children = children;\\r\\n  this.text = text;\\r\\n  this.elm = elm;\\r\\n  this.ns = undefined;\\r\\n  this.context = context;\\r\\n  this.fnContext = undefined;\\r\\n  this.fnOptions = undefined;\\r\\n  this.fnScopeId = undefined;\\r\\n  this.key = data && data.key;\\r\\n  this.componentOptions = componentOptions;\\r\\n  this.componentInstance = undefined;\\r\\n  this.parent = undefined;\\r\\n  this.raw = false;\\r\\n  this.isStatic = false;\\r\\n  this.isRootInsert = true;\\r\\n  this.isComment = false;\\r\\n  this.isCloned = false;\\r\\n  this.isOnce = false;\\r\\n  this.asyncFactory = asyncFactory;\\r\\n  this.asyncMeta = undefined;\\r\\n  this.isAsyncPlaceholder = false;\\r\\n};\\r\\n\\r\\nvar prototypeAccessors = { child: { configurable: true } };\\r\\n\\r\\n// DEPRECATED: alias for componentInstance for backwards compat.\\r\\n/* istanbul ignore next */\\r\\nprototypeAccessors.child.get = function () {\\r\\n  return this.componentInstance\\r\\n};\\r\\n\\r\\nObject.defineProperties( VNode.prototype, prototypeAccessors );\\r\\n\\r\\nvar createEmptyVNode = function (text) {\\r\\n  if ( text === void 0 ) text = '';\\r\\n\\r\\n  var node = new VNode();\\r\\n  node.text = text;\\r\\n  node.isComment = true;\\r\\n  return node\\r\\n};\\r\\n\\r\\nfunction createTextVNode (val) {\\r\\n  return new VNode(undefined, undefined, undefined, String(val))\\r\\n}\\r\\n\\r\\n// optimized shallow clone\\r\\n// used for static nodes and slot nodes because they may be reused across\\r\\n// multiple renders, cloning them avoids errors when DOM manipulations rely\\r\\n// on their elm reference.\\r\\nfunction cloneVNode (vnode) {\\r\\n  var cloned = new VNode(\\r\\n    vnode.tag,\\r\\n    vnode.data,\\r\\n    // #7975\\r\\n    // clone children array to avoid mutating original in case of cloning\\r\\n    // a child.\\r\\n    vnode.children && vnode.children.slice(),\\r\\n    vnode.text,\\r\\n    vnode.elm,\\r\\n    vnode.context,\\r\\n    vnode.componentOptions,\\r\\n    vnode.asyncFactory\\r\\n  );\\r\\n  cloned.ns = vnode.ns;\\r\\n  cloned.isStatic = vnode.isStatic;\\r\\n  cloned.key = vnode.key;\\r\\n  cloned.isComment = vnode.isComment;\\r\\n  cloned.fnContext = vnode.fnContext;\\r\\n  cloned.fnOptions = vnode.fnOptions;\\r\\n  cloned.fnScopeId = vnode.fnScopeId;\\r\\n  cloned.asyncMeta = vnode.asyncMeta;\\r\\n  cloned.isCloned = true;\\r\\n  return cloned\\r\\n}\\r\\n\\r\\n/*\\r\\n * not type checking this file because flow doesn't play well with\\r\\n * dynamically accessing methods on Array prototype\\r\\n */\\r\\n\\r\\nvar arrayProto = Array.prototype;\\r\\nvar arrayMethods = Object.create(arrayProto);\\r\\n\\r\\nvar methodsToPatch = [\\r\\n  'push',\\r\\n  'pop',\\r\\n  'shift',\\r\\n  'unshift',\\r\\n  'splice',\\r\\n  'sort',\\r\\n  'reverse'\\r\\n];\\r\\n\\r\\n/**\\r\\n * Intercept mutating methods and emit events\\r\\n */\\r\\nmethodsToPatch.forEach(function (method) {\\r\\n  // cache original method\\r\\n  var original = arrayProto[method];\\r\\n  def(arrayMethods, method, function mutator () {\\r\\n    var args = [], len = arguments.length;\\r\\n    while ( len-- ) args[ len ] = arguments[ len ];\\r\\n\\r\\n    var result = original.apply(this, args);\\r\\n    var ob = this.__ob__;\\r\\n    var inserted;\\r\\n    switch (method) {\\r\\n      case 'push':\\r\\n      case 'unshift':\\r\\n        inserted = args;\\r\\n        break\\r\\n      case 'splice':\\r\\n        inserted = args.slice(2);\\r\\n        break\\r\\n    }\\r\\n    if (inserted) { ob.observeArray(inserted); }\\r\\n    // notify change\\r\\n    ob.dep.notify();\\r\\n    return result\\r\\n  });\\r\\n});\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\\r\\n\\r\\n/**\\r\\n * In some cases we may want to disable observation inside a component's\\r\\n * update computation.\\r\\n */\\r\\nvar shouldObserve = true;\\r\\n\\r\\nfunction toggleObserving (value) {\\r\\n  shouldObserve = value;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Observer class that is attached to each observed\\r\\n * object. Once attached, the observer converts the target\\r\\n * object's property keys into getter/setters that\\r\\n * collect dependencies and dispatch updates.\\r\\n */\\r\\nvar Observer = function Observer (value) {\\r\\n  this.value = value;\\r\\n  this.dep = new Dep();\\r\\n  this.vmCount = 0;\\r\\n  def(value, '__ob__', this);\\r\\n  if (Array.isArray(value)) {\\r\\n    if (hasProto) {\\r\\n      protoAugment(value, arrayMethods);\\r\\n    } else {\\r\\n      copyAugment(value, arrayMethods, arrayKeys);\\r\\n    }\\r\\n    this.observeArray(value);\\r\\n  } else {\\r\\n    this.walk(value);\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Walk through all properties and convert them into\\r\\n * getter/setters. This method should only be called when\\r\\n * value type is Object.\\r\\n */\\r\\nObserver.prototype.walk = function walk (obj) {\\r\\n  var keys = Object.keys(obj);\\r\\n  for (var i = 0; i < keys.length; i++) {\\r\\n    defineReactive$$1(obj, keys[i]);\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Observe a list of Array items.\\r\\n */\\r\\nObserver.prototype.observeArray = function observeArray (items) {\\r\\n  for (var i = 0, l = items.length; i < l; i++) {\\r\\n    observe(items[i]);\\r\\n  }\\r\\n};\\r\\n\\r\\n// helpers\\r\\n\\r\\n/**\\r\\n * Augment a target Object or Array by intercepting\\r\\n * the prototype chain using __proto__\\r\\n */\\r\\nfunction protoAugment (target, src) {\\r\\n  /* eslint-disable no-proto */\\r\\n  target.__proto__ = src;\\r\\n  /* eslint-enable no-proto */\\r\\n}\\r\\n\\r\\n/**\\r\\n * Augment a target Object or Array by defining\\r\\n * hidden properties.\\r\\n */\\r\\n/* istanbul ignore next */\\r\\nfunction copyAugment (target, src, keys) {\\r\\n  for (var i = 0, l = keys.length; i < l; i++) {\\r\\n    var key = keys[i];\\r\\n    def(target, key, src[key]);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Attempt to create an observer instance for a value,\\r\\n * returns the new observer if successfully observed,\\r\\n * or the existing observer if the value already has one.\\r\\n */\\r\\nfunction observe (value, asRootData) {\\r\\n  if (!isObject(value) || value instanceof VNode) {\\r\\n    return\\r\\n  }\\r\\n  var ob;\\r\\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\\r\\n    ob = value.__ob__;\\r\\n  } else if (\\r\\n    shouldObserve &&\\r\\n    !isServerRendering() &&\\r\\n    (Array.isArray(value) || isPlainObject(value)) &&\\r\\n    Object.isExtensible(value) &&\\r\\n    !value._isVue\\r\\n  ) {\\r\\n    ob = new Observer(value);\\r\\n  }\\r\\n  if (asRootData && ob) {\\r\\n    ob.vmCount++;\\r\\n  }\\r\\n  return ob\\r\\n}\\r\\n\\r\\n/**\\r\\n * Define a reactive property on an Object.\\r\\n */\\r\\nfunction defineReactive$$1 (\\r\\n  obj,\\r\\n  key,\\r\\n  val,\\r\\n  customSetter,\\r\\n  shallow\\r\\n) {\\r\\n  var dep = new Dep();\\r\\n\\r\\n  var property = Object.getOwnPropertyDescriptor(obj, key);\\r\\n  if (property && property.configurable === false) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  // cater for pre-defined getter/setters\\r\\n  var getter = property && property.get;\\r\\n  var setter = property && property.set;\\r\\n  if ((!getter || setter) && arguments.length === 2) {\\r\\n    val = obj[key];\\r\\n  }\\r\\n\\r\\n  var childOb = !shallow && observe(val);\\r\\n  Object.defineProperty(obj, key, {\\r\\n    enumerable: true,\\r\\n    configurable: true,\\r\\n    get: function reactiveGetter () {\\r\\n      var value = getter ? getter.call(obj) : val;\\r\\n      if (Dep.target) {\\r\\n        dep.depend();\\r\\n        if (childOb) {\\r\\n          childOb.dep.depend();\\r\\n          if (Array.isArray(value)) {\\r\\n            dependArray(value);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      return value\\r\\n    },\\r\\n    set: function reactiveSetter (newVal) {\\r\\n      var value = getter ? getter.call(obj) : val;\\r\\n      /* eslint-disable no-self-compare */\\r\\n      if (newVal === value || (newVal !== newVal && value !== value)) {\\r\\n        return\\r\\n      }\\r\\n      /* eslint-enable no-self-compare */\\r\\n      if (false) {}\\r\\n      // #7981: for accessor properties without setter\\r\\n      if (getter && !setter) { return }\\r\\n      if (setter) {\\r\\n        setter.call(obj, newVal);\\r\\n      } else {\\r\\n        val = newVal;\\r\\n      }\\r\\n      childOb = !shallow && observe(newVal);\\r\\n      dep.notify();\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n/**\\r\\n * Set a property on an object. Adds the new property and\\r\\n * triggers change notification if the property doesn't\\r\\n * already exist.\\r\\n */\\r\\nfunction set (target, key, val) {\\r\\n  if (false\\r\\n  ) {}\\r\\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\\r\\n    target.length = Math.max(target.length, key);\\r\\n    target.splice(key, 1, val);\\r\\n    return val\\r\\n  }\\r\\n  if (key in target && !(key in Object.prototype)) {\\r\\n    target[key] = val;\\r\\n    return val\\r\\n  }\\r\\n  var ob = (target).__ob__;\\r\\n  if (target._isVue || (ob && ob.vmCount)) {\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\\r\\n      'at runtime - declare it upfront in the data option.'\\r\\n    );\\r\\n    return val\\r\\n  }\\r\\n  if (!ob) {\\r\\n    target[key] = val;\\r\\n    return val\\r\\n  }\\r\\n  defineReactive$$1(ob.value, key, val);\\r\\n  ob.dep.notify();\\r\\n  return val\\r\\n}\\r\\n\\r\\n/**\\r\\n * Delete a property and trigger change if necessary.\\r\\n */\\r\\nfunction del (target, key) {\\r\\n  if (false\\r\\n  ) {}\\r\\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\\r\\n    target.splice(key, 1);\\r\\n    return\\r\\n  }\\r\\n  var ob = (target).__ob__;\\r\\n  if (target._isVue || (ob && ob.vmCount)) {\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      'Avoid deleting properties on a Vue instance or its root $data ' +\\r\\n      '- just set it to null.'\\r\\n    );\\r\\n    return\\r\\n  }\\r\\n  if (!hasOwn(target, key)) {\\r\\n    return\\r\\n  }\\r\\n  delete target[key];\\r\\n  if (!ob) {\\r\\n    return\\r\\n  }\\r\\n  ob.dep.notify();\\r\\n}\\r\\n\\r\\n/**\\r\\n * Collect dependencies on array elements when the array is touched, since\\r\\n * we cannot intercept array element access like property getters.\\r\\n */\\r\\nfunction dependArray (value) {\\r\\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\\r\\n    e = value[i];\\r\\n    e && e.__ob__ && e.__ob__.dep.depend();\\r\\n    if (Array.isArray(e)) {\\r\\n      dependArray(e);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Option overwriting strategies are functions that handle\\r\\n * how to merge a parent option value and a child option\\r\\n * value into the final value.\\r\\n */\\r\\nvar strats = config.optionMergeStrategies;\\r\\n\\r\\n/**\\r\\n * Options with restrictions\\r\\n */\\r\\nif (false) {}\\r\\n\\r\\n/**\\r\\n * Helper that recursively merges two data objects together.\\r\\n */\\r\\nfunction mergeData (to, from) {\\r\\n  if (!from) { return to }\\r\\n  var key, toVal, fromVal;\\r\\n  var keys = Object.keys(from);\\r\\n  for (var i = 0; i < keys.length; i++) {\\r\\n    key = keys[i];\\r\\n    toVal = to[key];\\r\\n    fromVal = from[key];\\r\\n    if (!hasOwn(to, key)) {\\r\\n      set(to, key, fromVal);\\r\\n    } else if (\\r\\n      toVal !== fromVal &&\\r\\n      isPlainObject(toVal) &&\\r\\n      isPlainObject(fromVal)\\r\\n    ) {\\r\\n      mergeData(toVal, fromVal);\\r\\n    }\\r\\n  }\\r\\n  return to\\r\\n}\\r\\n\\r\\n/**\\r\\n * Data\\r\\n */\\r\\nfunction mergeDataOrFn (\\r\\n  parentVal,\\r\\n  childVal,\\r\\n  vm\\r\\n) {\\r\\n  if (!vm) {\\r\\n    // in a Vue.extend merge, both should be functions\\r\\n    if (!childVal) {\\r\\n      return parentVal\\r\\n    }\\r\\n    if (!parentVal) {\\r\\n      return childVal\\r\\n    }\\r\\n    // when parentVal & childVal are both present,\\r\\n    // we need to return a function that returns the\\r\\n    // merged result of both functions... no need to\\r\\n    // check if parentVal is a function here because\\r\\n    // it has to be a function to pass previous merges.\\r\\n    return function mergedDataFn () {\\r\\n      return mergeData(\\r\\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\\r\\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\\r\\n      )\\r\\n    }\\r\\n  } else {\\r\\n    return function mergedInstanceDataFn () {\\r\\n      // instance merge\\r\\n      var instanceData = typeof childVal === 'function'\\r\\n        ? childVal.call(vm, vm)\\r\\n        : childVal;\\r\\n      var defaultData = typeof parentVal === 'function'\\r\\n        ? parentVal.call(vm, vm)\\r\\n        : parentVal;\\r\\n      if (instanceData) {\\r\\n        return mergeData(instanceData, defaultData)\\r\\n      } else {\\r\\n        return defaultData\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nstrats.data = function (\\r\\n  parentVal,\\r\\n  childVal,\\r\\n  vm\\r\\n) {\\r\\n  if (!vm) {\\r\\n    if (childVal && typeof childVal !== 'function') {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        'The \\\"data\\\" option should be a function ' +\\r\\n        'that returns a per-instance value in component ' +\\r\\n        'definitions.',\\r\\n        vm\\r\\n      );\\r\\n\\r\\n      return parentVal\\r\\n    }\\r\\n    return mergeDataOrFn(parentVal, childVal)\\r\\n  }\\r\\n\\r\\n  return mergeDataOrFn(parentVal, childVal, vm)\\r\\n};\\r\\n\\r\\n/**\\r\\n * Hooks and props are merged as arrays.\\r\\n */\\r\\nfunction mergeHook (\\r\\n  parentVal,\\r\\n  childVal\\r\\n) {\\r\\n  return childVal\\r\\n    ? parentVal\\r\\n      ? parentVal.concat(childVal)\\r\\n      : Array.isArray(childVal)\\r\\n        ? childVal\\r\\n        : [childVal]\\r\\n    : parentVal\\r\\n}\\r\\n\\r\\nLIFECYCLE_HOOKS.forEach(function (hook) {\\r\\n  strats[hook] = mergeHook;\\r\\n});\\r\\n\\r\\n/**\\r\\n * Assets\\r\\n *\\r\\n * When a vm is present (instance creation), we need to do\\r\\n * a three-way merge between constructor options, instance\\r\\n * options and parent options.\\r\\n */\\r\\nfunction mergeAssets (\\r\\n  parentVal,\\r\\n  childVal,\\r\\n  vm,\\r\\n  key\\r\\n) {\\r\\n  var res = Object.create(parentVal || null);\\r\\n  if (childVal) {\\r\\n    \\\"production\\\" !== 'production' && assertObjectType(key, childVal, vm);\\r\\n    return extend(res, childVal)\\r\\n  } else {\\r\\n    return res\\r\\n  }\\r\\n}\\r\\n\\r\\nASSET_TYPES.forEach(function (type) {\\r\\n  strats[type + 's'] = mergeAssets;\\r\\n});\\r\\n\\r\\n/**\\r\\n * Watchers.\\r\\n *\\r\\n * Watchers hashes should not overwrite one\\r\\n * another, so we merge them as arrays.\\r\\n */\\r\\nstrats.watch = function (\\r\\n  parentVal,\\r\\n  childVal,\\r\\n  vm,\\r\\n  key\\r\\n) {\\r\\n  // work around Firefox's Object.prototype.watch...\\r\\n  if (parentVal === nativeWatch) { parentVal = undefined; }\\r\\n  if (childVal === nativeWatch) { childVal = undefined; }\\r\\n  /* istanbul ignore if */\\r\\n  if (!childVal) { return Object.create(parentVal || null) }\\r\\n  if (false) {}\\r\\n  if (!parentVal) { return childVal }\\r\\n  var ret = {};\\r\\n  extend(ret, parentVal);\\r\\n  for (var key$1 in childVal) {\\r\\n    var parent = ret[key$1];\\r\\n    var child = childVal[key$1];\\r\\n    if (parent && !Array.isArray(parent)) {\\r\\n      parent = [parent];\\r\\n    }\\r\\n    ret[key$1] = parent\\r\\n      ? parent.concat(child)\\r\\n      : Array.isArray(child) ? child : [child];\\r\\n  }\\r\\n  return ret\\r\\n};\\r\\n\\r\\n/**\\r\\n * Other object hashes.\\r\\n */\\r\\nstrats.props =\\r\\nstrats.methods =\\r\\nstrats.inject =\\r\\nstrats.computed = function (\\r\\n  parentVal,\\r\\n  childVal,\\r\\n  vm,\\r\\n  key\\r\\n) {\\r\\n  if (childVal && \\\"production\\\" !== 'production') {\\r\\n    assertObjectType(key, childVal, vm);\\r\\n  }\\r\\n  if (!parentVal) { return childVal }\\r\\n  var ret = Object.create(null);\\r\\n  extend(ret, parentVal);\\r\\n  if (childVal) { extend(ret, childVal); }\\r\\n  return ret\\r\\n};\\r\\nstrats.provide = mergeDataOrFn;\\r\\n\\r\\n/**\\r\\n * Default strategy.\\r\\n */\\r\\nvar defaultStrat = function (parentVal, childVal) {\\r\\n  return childVal === undefined\\r\\n    ? parentVal\\r\\n    : childVal\\r\\n};\\r\\n\\r\\n/**\\r\\n * Validate component names\\r\\n */\\r\\nfunction checkComponents (options) {\\r\\n  for (var key in options.components) {\\r\\n    validateComponentName(key);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction validateComponentName (name) {\\r\\n  if (!/^[a-zA-Z][\\\\w-]*$/.test(name)) {\\r\\n    warn(\\r\\n      'Invalid component name: \\\"' + name + '\\\". Component names ' +\\r\\n      'can only contain alphanumeric characters and the hyphen, ' +\\r\\n      'and must start with a letter.'\\r\\n    );\\r\\n  }\\r\\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\\r\\n    warn(\\r\\n      'Do not use built-in or reserved HTML elements as component ' +\\r\\n      'id: ' + name\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Ensure all props option syntax are normalized into the\\r\\n * Object-based format.\\r\\n */\\r\\nfunction normalizeProps (options, vm) {\\r\\n  var props = options.props;\\r\\n  if (!props) { return }\\r\\n  var res = {};\\r\\n  var i, val, name;\\r\\n  if (Array.isArray(props)) {\\r\\n    i = props.length;\\r\\n    while (i--) {\\r\\n      val = props[i];\\r\\n      if (typeof val === 'string') {\\r\\n        name = camelize(val);\\r\\n        res[name] = { type: null };\\r\\n      } else if (false) {}\\r\\n    }\\r\\n  } else if (isPlainObject(props)) {\\r\\n    for (var key in props) {\\r\\n      val = props[key];\\r\\n      name = camelize(key);\\r\\n      res[name] = isPlainObject(val)\\r\\n        ? val\\r\\n        : { type: val };\\r\\n    }\\r\\n  } else if (false) {}\\r\\n  options.props = res;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Normalize all injections into Object-based format\\r\\n */\\r\\nfunction normalizeInject (options, vm) {\\r\\n  var inject = options.inject;\\r\\n  if (!inject) { return }\\r\\n  var normalized = options.inject = {};\\r\\n  if (Array.isArray(inject)) {\\r\\n    for (var i = 0; i < inject.length; i++) {\\r\\n      normalized[inject[i]] = { from: inject[i] };\\r\\n    }\\r\\n  } else if (isPlainObject(inject)) {\\r\\n    for (var key in inject) {\\r\\n      var val = inject[key];\\r\\n      normalized[key] = isPlainObject(val)\\r\\n        ? extend({ from: key }, val)\\r\\n        : { from: val };\\r\\n    }\\r\\n  } else if (false) {}\\r\\n}\\r\\n\\r\\n/**\\r\\n * Normalize raw function directives into object format.\\r\\n */\\r\\nfunction normalizeDirectives (options) {\\r\\n  var dirs = options.directives;\\r\\n  if (dirs) {\\r\\n    for (var key in dirs) {\\r\\n      var def = dirs[key];\\r\\n      if (typeof def === 'function') {\\r\\n        dirs[key] = { bind: def, update: def };\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction assertObjectType (name, value, vm) {\\r\\n  if (!isPlainObject(value)) {\\r\\n    warn(\\r\\n      \\\"Invalid value for option \\\\\\\"\\\" + name + \\\"\\\\\\\": expected an Object, \\\" +\\r\\n      \\\"but got \\\" + (toRawType(value)) + \\\".\\\",\\r\\n      vm\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Merge two option objects into a new one.\\r\\n * Core utility used in both instantiation and inheritance.\\r\\n */\\r\\nfunction mergeOptions (\\r\\n  parent,\\r\\n  child,\\r\\n  vm\\r\\n) {\\r\\n  if (false) {}\\r\\n\\r\\n  if (typeof child === 'function') {\\r\\n    child = child.options;\\r\\n  }\\r\\n\\r\\n  normalizeProps(child, vm);\\r\\n  normalizeInject(child, vm);\\r\\n  normalizeDirectives(child);\\r\\n  \\r\\n  // Apply extends and mixins on the child options,\\r\\n  // but only if it is a raw options object that isn't\\r\\n  // the result of another mergeOptions call.\\r\\n  // Only merged options has the _base property.\\r\\n  if (!child._base) {\\r\\n    if (child.extends) {\\r\\n      parent = mergeOptions(parent, child.extends, vm);\\r\\n    }\\r\\n    if (child.mixins) {\\r\\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\\r\\n        parent = mergeOptions(parent, child.mixins[i], vm);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var options = {};\\r\\n  var key;\\r\\n  for (key in parent) {\\r\\n    mergeField(key);\\r\\n  }\\r\\n  for (key in child) {\\r\\n    if (!hasOwn(parent, key)) {\\r\\n      mergeField(key);\\r\\n    }\\r\\n  }\\r\\n  function mergeField (key) {\\r\\n    var strat = strats[key] || defaultStrat;\\r\\n    options[key] = strat(parent[key], child[key], vm, key);\\r\\n  }\\r\\n  return options\\r\\n}\\r\\n\\r\\n/**\\r\\n * Resolve an asset.\\r\\n * This function is used because child instances need access\\r\\n * to assets defined in its ancestor chain.\\r\\n */\\r\\nfunction resolveAsset (\\r\\n  options,\\r\\n  type,\\r\\n  id,\\r\\n  warnMissing\\r\\n) {\\r\\n  /* istanbul ignore if */\\r\\n  if (typeof id !== 'string') {\\r\\n    return\\r\\n  }\\r\\n  var assets = options[type];\\r\\n  // check local registration variations first\\r\\n  if (hasOwn(assets, id)) { return assets[id] }\\r\\n  var camelizedId = camelize(id);\\r\\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\\r\\n  var PascalCaseId = capitalize(camelizedId);\\r\\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\\r\\n  // fallback to prototype chain\\r\\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\\r\\n  if (false) {}\\r\\n  return res\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nfunction validateProp (\\r\\n  key,\\r\\n  propOptions,\\r\\n  propsData,\\r\\n  vm\\r\\n) {\\r\\n  var prop = propOptions[key];\\r\\n  var absent = !hasOwn(propsData, key);\\r\\n  var value = propsData[key];\\r\\n  // boolean casting\\r\\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\\r\\n  if (booleanIndex > -1) {\\r\\n    if (absent && !hasOwn(prop, 'default')) {\\r\\n      value = false;\\r\\n    } else if (value === '' || value === hyphenate(key)) {\\r\\n      // only cast empty string / same name to boolean if\\r\\n      // boolean has higher priority\\r\\n      var stringIndex = getTypeIndex(String, prop.type);\\r\\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\\r\\n        value = true;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  // check default value\\r\\n  if (value === undefined) {\\r\\n    value = getPropDefaultValue(vm, prop, key);\\r\\n    // since the default value is a fresh copy,\\r\\n    // make sure to observe it.\\r\\n    var prevShouldObserve = shouldObserve;\\r\\n    toggleObserving(true);\\r\\n    observe(value);\\r\\n    toggleObserving(prevShouldObserve);\\r\\n  }\\r\\n  if (\\r\\n    false\\r\\n  ) {}\\r\\n  return value\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get the default value of a prop.\\r\\n */\\r\\nfunction getPropDefaultValue (vm, prop, key) {\\r\\n  // no default, return undefined\\r\\n  if (!hasOwn(prop, 'default')) {\\r\\n    return undefined\\r\\n  }\\r\\n  var def = prop.default;\\r\\n  // warn against non-factory defaults for Object & Array\\r\\n  if (false) {}\\r\\n  // the raw prop value was also undefined from previous render,\\r\\n  // return previous default value to avoid unnecessary watcher trigger\\r\\n  if (vm && vm.$options.propsData &&\\r\\n    vm.$options.propsData[key] === undefined &&\\r\\n    vm._props[key] !== undefined\\r\\n  ) {\\r\\n    return vm._props[key]\\r\\n  }\\r\\n  // call factory function for non-Function types\\r\\n  // a value is Function if its prototype is function even across different execution context\\r\\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\\r\\n    ? def.call(vm)\\r\\n    : def\\r\\n}\\r\\n\\r\\n/**\\r\\n * Assert whether a prop is valid.\\r\\n */\\r\\nfunction assertProp (\\r\\n  prop,\\r\\n  name,\\r\\n  value,\\r\\n  vm,\\r\\n  absent\\r\\n) {\\r\\n  if (prop.required && absent) {\\r\\n    warn(\\r\\n      'Missing required prop: \\\"' + name + '\\\"',\\r\\n      vm\\r\\n    );\\r\\n    return\\r\\n  }\\r\\n  if (value == null && !prop.required) {\\r\\n    return\\r\\n  }\\r\\n  var type = prop.type;\\r\\n  var valid = !type || type === true;\\r\\n  var expectedTypes = [];\\r\\n  if (type) {\\r\\n    if (!Array.isArray(type)) {\\r\\n      type = [type];\\r\\n    }\\r\\n    for (var i = 0; i < type.length && !valid; i++) {\\r\\n      var assertedType = assertType(value, type[i]);\\r\\n      expectedTypes.push(assertedType.expectedType || '');\\r\\n      valid = assertedType.valid;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (!valid) {\\r\\n    warn(\\r\\n      getInvalidTypeMessage(name, value, expectedTypes),\\r\\n      vm\\r\\n    );\\r\\n    return\\r\\n  }\\r\\n  var validator = prop.validator;\\r\\n  if (validator) {\\r\\n    if (!validator(value)) {\\r\\n      warn(\\r\\n        'Invalid prop: custom validator check failed for prop \\\"' + name + '\\\".',\\r\\n        vm\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\\r\\n\\r\\nfunction assertType (value, type) {\\r\\n  var valid;\\r\\n  var expectedType = getType(type);\\r\\n  if (simpleCheckRE.test(expectedType)) {\\r\\n    var t = typeof value;\\r\\n    valid = t === expectedType.toLowerCase();\\r\\n    // for primitive wrapper objects\\r\\n    if (!valid && t === 'object') {\\r\\n      valid = value instanceof type;\\r\\n    }\\r\\n  } else if (expectedType === 'Object') {\\r\\n    valid = isPlainObject(value);\\r\\n  } else if (expectedType === 'Array') {\\r\\n    valid = Array.isArray(value);\\r\\n  } else {\\r\\n    valid = value instanceof type;\\r\\n  }\\r\\n  return {\\r\\n    valid: valid,\\r\\n    expectedType: expectedType\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Use function string name to check built-in types,\\r\\n * because a simple equality check will fail when running\\r\\n * across different vms / iframes.\\r\\n */\\r\\nfunction getType (fn) {\\r\\n  var match = fn && fn.toString().match(/^\\\\s*function (\\\\w+)/);\\r\\n  return match ? match[1] : ''\\r\\n}\\r\\n\\r\\nfunction isSameType (a, b) {\\r\\n  return getType(a) === getType(b)\\r\\n}\\r\\n\\r\\nfunction getTypeIndex (type, expectedTypes) {\\r\\n  if (!Array.isArray(expectedTypes)) {\\r\\n    return isSameType(expectedTypes, type) ? 0 : -1\\r\\n  }\\r\\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\\r\\n    if (isSameType(expectedTypes[i], type)) {\\r\\n      return i\\r\\n    }\\r\\n  }\\r\\n  return -1\\r\\n}\\r\\n\\r\\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\\r\\n  var message = \\\"Invalid prop: type check failed for prop \\\\\\\"\\\" + name + \\\"\\\\\\\".\\\" +\\r\\n    \\\" Expected \\\" + (expectedTypes.map(capitalize).join(', '));\\r\\n  var expectedType = expectedTypes[0];\\r\\n  var receivedType = toRawType(value);\\r\\n  var expectedValue = styleValue(value, expectedType);\\r\\n  var receivedValue = styleValue(value, receivedType);\\r\\n  // check if we need to specify expected value\\r\\n  if (expectedTypes.length === 1 &&\\r\\n      isExplicable(expectedType) &&\\r\\n      !isBoolean(expectedType, receivedType)) {\\r\\n    message += \\\" with value \\\" + expectedValue;\\r\\n  }\\r\\n  message += \\\", got \\\" + receivedType + \\\" \\\";\\r\\n  // check if we need to specify received value\\r\\n  if (isExplicable(receivedType)) {\\r\\n    message += \\\"with value \\\" + receivedValue + \\\".\\\";\\r\\n  }\\r\\n  return message\\r\\n}\\r\\n\\r\\nfunction styleValue (value, type) {\\r\\n  if (type === 'String') {\\r\\n    return (\\\"\\\\\\\"\\\" + value + \\\"\\\\\\\"\\\")\\r\\n  } else if (type === 'Number') {\\r\\n    return (\\\"\\\" + (Number(value)))\\r\\n  } else {\\r\\n    return (\\\"\\\" + value)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isExplicable (value) {\\r\\n  var explicitTypes = ['string', 'number', 'boolean'];\\r\\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\\r\\n}\\r\\n\\r\\nfunction isBoolean () {\\r\\n  var args = [], len = arguments.length;\\r\\n  while ( len-- ) args[ len ] = arguments[ len ];\\r\\n\\r\\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction handleError (err, vm, info) {\\r\\n  if (vm) {\\r\\n    var cur = vm;\\r\\n    while ((cur = cur.$parent)) {\\r\\n      var hooks = cur.$options.errorCaptured;\\r\\n      if (hooks) {\\r\\n        for (var i = 0; i < hooks.length; i++) {\\r\\n          try {\\r\\n            var capture = hooks[i].call(cur, err, vm, info) === false;\\r\\n            if (capture) { return }\\r\\n          } catch (e) {\\r\\n            globalHandleError(e, cur, 'errorCaptured hook');\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  globalHandleError(err, vm, info);\\r\\n}\\r\\n\\r\\nfunction globalHandleError (err, vm, info) {\\r\\n  if (config.errorHandler) {\\r\\n    try {\\r\\n      return config.errorHandler.call(null, err, vm, info)\\r\\n    } catch (e) {\\r\\n      logError(e, null, 'config.errorHandler');\\r\\n    }\\r\\n  }\\r\\n  logError(err, vm, info);\\r\\n}\\r\\n\\r\\nfunction logError (err, vm, info) {\\r\\n  if (false) {}\\r\\n  /* istanbul ignore else */\\r\\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\\r\\n    console.error(err);\\r\\n  } else {\\r\\n    throw err\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar callbacks = [];\\r\\nvar pending = false;\\r\\n\\r\\nfunction flushCallbacks () {\\r\\n  pending = false;\\r\\n  var copies = callbacks.slice(0);\\r\\n  callbacks.length = 0;\\r\\n  for (var i = 0; i < copies.length; i++) {\\r\\n    copies[i]();\\r\\n  }\\r\\n}\\r\\n\\r\\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\\r\\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\\r\\n// microtasks have too high a priority and fire in between supposedly\\r\\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\\r\\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\\r\\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\\r\\n// Here we use microtask by default, but expose a way to force (macro) task when\\r\\n// needed (e.g. in event handlers attached by v-on).\\r\\nvar microTimerFunc;\\r\\nvar macroTimerFunc;\\r\\nvar useMacroTask = false;\\r\\n\\r\\n// Determine (macro) task defer implementation.\\r\\n// Technically setImmediate should be the ideal choice, but it's only available\\r\\n// in IE. The only polyfill that consistently queues the callback after all DOM\\r\\n// events triggered in the same loop is by using MessageChannel.\\r\\n/* istanbul ignore if */\\r\\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\\r\\n  macroTimerFunc = function () {\\r\\n    setImmediate(flushCallbacks);\\r\\n  };\\r\\n} else if (typeof MessageChannel !== 'undefined' && (\\r\\n  isNative(MessageChannel) ||\\r\\n  // PhantomJS\\r\\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\\r\\n)) {\\r\\n  var channel = new MessageChannel();\\r\\n  var port = channel.port2;\\r\\n  channel.port1.onmessage = flushCallbacks;\\r\\n  macroTimerFunc = function () {\\r\\n    port.postMessage(1);\\r\\n  };\\r\\n} else {\\r\\n  /* istanbul ignore next */\\r\\n  macroTimerFunc = function () {\\r\\n    setTimeout(flushCallbacks, 0);\\r\\n  };\\r\\n}\\r\\n\\r\\n// Determine microtask defer implementation.\\r\\n/* istanbul ignore next, $flow-disable-line */\\r\\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\\r\\n  var p = Promise.resolve();\\r\\n  microTimerFunc = function () {\\r\\n    p.then(flushCallbacks);\\r\\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\\r\\n    // it can get stuck in a weird state where callbacks are pushed into the\\r\\n    // microtask queue but the queue isn't being flushed, until the browser\\r\\n    // needs to do some other work, e.g. handle a timer. Therefore we can\\r\\n    // \\\"force\\\" the microtask queue to be flushed by adding an empty timer.\\r\\n    if (isIOS) { setTimeout(noop); }\\r\\n  };\\r\\n} else {\\r\\n  // fallback to macro\\r\\n  microTimerFunc = macroTimerFunc;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Wrap a function so that if any code inside triggers state change,\\r\\n * the changes are queued using a (macro) task instead of a microtask.\\r\\n */\\r\\nfunction withMacroTask (fn) {\\r\\n  return fn._withTask || (fn._withTask = function () {\\r\\n    useMacroTask = true;\\r\\n    try {\\r\\n      return fn.apply(null, arguments)\\r\\n    } finally {\\r\\n      useMacroTask = false;    \\r\\n    }\\r\\n  })\\r\\n}\\r\\n\\r\\nfunction nextTick (cb, ctx) {\\r\\n  var _resolve;\\r\\n  callbacks.push(function () {\\r\\n    if (cb) {\\r\\n      try {\\r\\n        cb.call(ctx);\\r\\n      } catch (e) {\\r\\n        handleError(e, ctx, 'nextTick');\\r\\n      }\\r\\n    } else if (_resolve) {\\r\\n      _resolve(ctx);\\r\\n    }\\r\\n  });\\r\\n  if (!pending) {\\r\\n    pending = true;\\r\\n    if (useMacroTask) {\\r\\n      macroTimerFunc();\\r\\n    } else {\\r\\n      microTimerFunc();\\r\\n    }\\r\\n  }\\r\\n  // $flow-disable-line\\r\\n  if (!cb && typeof Promise !== 'undefined') {\\r\\n    return new Promise(function (resolve) {\\r\\n      _resolve = resolve;\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar mark;\\r\\nvar measure;\\r\\n\\r\\nif (false) { var perf; }\\r\\n\\r\\n/* not type checking this file because flow doesn't play well with Proxy */\\r\\n\\r\\nvar initProxy;\\r\\n\\r\\nif (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar seenObjects = new _Set();\\r\\n\\r\\n/**\\r\\n * Recursively traverse an object to evoke all converted\\r\\n * getters, so that every nested property inside the object\\r\\n * is collected as a \\\"deep\\\" dependency.\\r\\n */\\r\\nfunction traverse (val) {\\r\\n  _traverse(val, seenObjects);\\r\\n  seenObjects.clear();\\r\\n}\\r\\n\\r\\nfunction _traverse (val, seen) {\\r\\n  var i, keys;\\r\\n  var isA = Array.isArray(val);\\r\\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\\r\\n    return\\r\\n  }\\r\\n  if (val.__ob__) {\\r\\n    var depId = val.__ob__.dep.id;\\r\\n    if (seen.has(depId)) {\\r\\n      return\\r\\n    }\\r\\n    seen.add(depId);\\r\\n  }\\r\\n  if (isA) {\\r\\n    i = val.length;\\r\\n    while (i--) { _traverse(val[i], seen); }\\r\\n  } else {\\r\\n    keys = Object.keys(val);\\r\\n    i = keys.length;\\r\\n    while (i--) { _traverse(val[keys[i]], seen); }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar normalizeEvent = cached(function (name) {\\r\\n  var passive = name.charAt(0) === '&';\\r\\n  name = passive ? name.slice(1) : name;\\r\\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\\r\\n  name = once$$1 ? name.slice(1) : name;\\r\\n  var capture = name.charAt(0) === '!';\\r\\n  name = capture ? name.slice(1) : name;\\r\\n  return {\\r\\n    name: name,\\r\\n    once: once$$1,\\r\\n    capture: capture,\\r\\n    passive: passive\\r\\n  }\\r\\n});\\r\\n\\r\\nfunction createFnInvoker (fns) {\\r\\n  function invoker () {\\r\\n    var arguments$1 = arguments;\\r\\n\\r\\n    var fns = invoker.fns;\\r\\n    if (Array.isArray(fns)) {\\r\\n      var cloned = fns.slice();\\r\\n      for (var i = 0; i < cloned.length; i++) {\\r\\n        cloned[i].apply(null, arguments$1);\\r\\n      }\\r\\n    } else {\\r\\n      // return handler return value for single handlers\\r\\n      return fns.apply(null, arguments)\\r\\n    }\\r\\n  }\\r\\n  invoker.fns = fns;\\r\\n  return invoker\\r\\n}\\r\\n\\r\\nfunction updateListeners (\\r\\n  on,\\r\\n  oldOn,\\r\\n  add,\\r\\n  remove$$1,\\r\\n  createOnceHandler,\\r\\n  vm\\r\\n) {\\r\\n  var name, def$$1, cur, old, event;\\r\\n  for (name in on) {\\r\\n    def$$1 = cur = on[name];\\r\\n    old = oldOn[name];\\r\\n    event = normalizeEvent(name);\\r\\n    if (isUndef(cur)) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        \\\"Invalid handler for event \\\\\\\"\\\" + (event.name) + \\\"\\\\\\\": got \\\" + String(cur),\\r\\n        vm\\r\\n      );\\r\\n    } else if (isUndef(old)) {\\r\\n      if (isUndef(cur.fns)) {\\r\\n        cur = on[name] = createFnInvoker(cur);\\r\\n      }\\r\\n      if (isTrue(event.once)) {\\r\\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\\r\\n      }\\r\\n      add(event.name, cur, event.capture, event.passive, event.params);\\r\\n    } else if (cur !== old) {\\r\\n      old.fns = cur;\\r\\n      on[name] = old;\\r\\n    }\\r\\n  }\\r\\n  for (name in oldOn) {\\r\\n    if (isUndef(on[name])) {\\r\\n      event = normalizeEvent(name);\\r\\n      remove$$1(event.name, oldOn[name], event.capture);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction mergeVNodeHook (def, hookKey, hook) {\\r\\n  if (def instanceof VNode) {\\r\\n    def = def.data.hook || (def.data.hook = {});\\r\\n  }\\r\\n  var invoker;\\r\\n  var oldHook = def[hookKey];\\r\\n\\r\\n  function wrappedHook () {\\r\\n    hook.apply(this, arguments);\\r\\n    // important: remove merged hook to ensure it's called only once\\r\\n    // and prevent memory leak\\r\\n    remove(invoker.fns, wrappedHook);\\r\\n  }\\r\\n\\r\\n  if (isUndef(oldHook)) {\\r\\n    // no existing hook\\r\\n    invoker = createFnInvoker([wrappedHook]);\\r\\n  } else {\\r\\n    /* istanbul ignore if */\\r\\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\\r\\n      // already a merged invoker\\r\\n      invoker = oldHook;\\r\\n      invoker.fns.push(wrappedHook);\\r\\n    } else {\\r\\n      // existing plain hook\\r\\n      invoker = createFnInvoker([oldHook, wrappedHook]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  invoker.merged = true;\\r\\n  def[hookKey] = invoker;\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction extractPropsFromVNodeData (\\r\\n  data,\\r\\n  Ctor,\\r\\n  tag\\r\\n) {\\r\\n  // we are only extracting raw values here.\\r\\n  // validation and default values are handled in the child\\r\\n  // component itself.\\r\\n  var propOptions = Ctor.options.props;\\r\\n  if (isUndef(propOptions)) {\\r\\n    return\\r\\n  }\\r\\n  var res = {};\\r\\n  var attrs = data.attrs;\\r\\n  var props = data.props;\\r\\n  if (isDef(attrs) || isDef(props)) {\\r\\n    for (var key in propOptions) {\\r\\n      var altKey = hyphenate(key);\\r\\n      if (false) { var keyInLowerCase; }\\r\\n      checkProp(res, props, key, altKey, true) ||\\r\\n      checkProp(res, attrs, key, altKey, false);\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction checkProp (\\r\\n  res,\\r\\n  hash,\\r\\n  key,\\r\\n  altKey,\\r\\n  preserve\\r\\n) {\\r\\n  if (isDef(hash)) {\\r\\n    if (hasOwn(hash, key)) {\\r\\n      res[key] = hash[key];\\r\\n      if (!preserve) {\\r\\n        delete hash[key];\\r\\n      }\\r\\n      return true\\r\\n    } else if (hasOwn(hash, altKey)) {\\r\\n      res[key] = hash[altKey];\\r\\n      if (!preserve) {\\r\\n        delete hash[altKey];\\r\\n      }\\r\\n      return true\\r\\n    }\\r\\n  }\\r\\n  return false\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// The template compiler attempts to minimize the need for normalization by\\r\\n// statically analyzing the template at compile time.\\r\\n//\\r\\n// For plain HTML markup, normalization can be completely skipped because the\\r\\n// generated render function is guaranteed to return Array<VNode>. There are\\r\\n// two cases where extra normalization is needed:\\r\\n\\r\\n// 1. When the children contains components - because a functional component\\r\\n// may return an Array instead of a single root. In this case, just a simple\\r\\n// normalization is needed - if any child is an Array, we flatten the whole\\r\\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\\r\\n// because functional components already normalize their own children.\\r\\nfunction simpleNormalizeChildren (children) {\\r\\n  for (var i = 0; i < children.length; i++) {\\r\\n    if (Array.isArray(children[i])) {\\r\\n      return Array.prototype.concat.apply([], children)\\r\\n    }\\r\\n  }\\r\\n  return children\\r\\n}\\r\\n\\r\\n// 2. When the children contains constructs that always generated nested Arrays,\\r\\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\\r\\n// with hand-written render functions / JSX. In such cases a full normalization\\r\\n// is needed to cater to all possible types of children values.\\r\\nfunction normalizeChildren (children) {\\r\\n  return isPrimitive(children)\\r\\n    ? [createTextVNode(children)]\\r\\n    : Array.isArray(children)\\r\\n      ? normalizeArrayChildren(children)\\r\\n      : undefined\\r\\n}\\r\\n\\r\\nfunction isTextNode (node) {\\r\\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\\r\\n}\\r\\n\\r\\nfunction normalizeArrayChildren (children, nestedIndex) {\\r\\n  var res = [];\\r\\n  var i, c, lastIndex, last;\\r\\n  for (i = 0; i < children.length; i++) {\\r\\n    c = children[i];\\r\\n    if (isUndef(c) || typeof c === 'boolean') { continue }\\r\\n    lastIndex = res.length - 1;\\r\\n    last = res[lastIndex];\\r\\n    //  nested\\r\\n    if (Array.isArray(c)) {\\r\\n      if (c.length > 0) {\\r\\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \\\"_\\\" + i));\\r\\n        // merge adjacent text nodes\\r\\n        if (isTextNode(c[0]) && isTextNode(last)) {\\r\\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\\r\\n          c.shift();\\r\\n        }\\r\\n        res.push.apply(res, c);\\r\\n      }\\r\\n    } else if (isPrimitive(c)) {\\r\\n      if (isTextNode(last)) {\\r\\n        // merge adjacent text nodes\\r\\n        // this is necessary for SSR hydration because text nodes are\\r\\n        // essentially merged when rendered to HTML strings\\r\\n        res[lastIndex] = createTextVNode(last.text + c);\\r\\n      } else if (c !== '') {\\r\\n        // convert primitive to vnode\\r\\n        res.push(createTextVNode(c));\\r\\n      }\\r\\n    } else {\\r\\n      if (isTextNode(c) && isTextNode(last)) {\\r\\n        // merge adjacent text nodes\\r\\n        res[lastIndex] = createTextVNode(last.text + c.text);\\r\\n      } else {\\r\\n        // default key for nested array children (likely generated by v-for)\\r\\n        if (isTrue(children._isVList) &&\\r\\n          isDef(c.tag) &&\\r\\n          isUndef(c.key) &&\\r\\n          isDef(nestedIndex)) {\\r\\n          c.key = \\\"__vlist\\\" + nestedIndex + \\\"_\\\" + i + \\\"__\\\";\\r\\n        }\\r\\n        res.push(c);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction ensureCtor (comp, base) {\\r\\n  if (\\r\\n    comp.__esModule ||\\r\\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\\r\\n  ) {\\r\\n    comp = comp.default;\\r\\n  }\\r\\n  return isObject(comp)\\r\\n    ? base.extend(comp)\\r\\n    : comp\\r\\n}\\r\\n\\r\\nfunction createAsyncPlaceholder (\\r\\n  factory,\\r\\n  data,\\r\\n  context,\\r\\n  children,\\r\\n  tag\\r\\n) {\\r\\n  var node = createEmptyVNode();\\r\\n  node.asyncFactory = factory;\\r\\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\\r\\n  return node\\r\\n}\\r\\n\\r\\nfunction resolveAsyncComponent (\\r\\n  factory,\\r\\n  baseCtor,\\r\\n  context\\r\\n) {\\r\\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\\r\\n    return factory.errorComp\\r\\n  }\\r\\n\\r\\n  if (isDef(factory.resolved)) {\\r\\n    return factory.resolved\\r\\n  }\\r\\n\\r\\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\\r\\n    return factory.loadingComp\\r\\n  }\\r\\n\\r\\n  if (isDef(factory.contexts)) {\\r\\n    // already pending\\r\\n    factory.contexts.push(context);\\r\\n  } else {\\r\\n    var contexts = factory.contexts = [context];\\r\\n    var sync = true;\\r\\n\\r\\n    var forceRender = function (renderCompleted) {\\r\\n      for (var i = 0, l = contexts.length; i < l; i++) {\\r\\n        contexts[i].$forceUpdate();\\r\\n      }\\r\\n\\r\\n      if (renderCompleted) {\\r\\n        contexts.length = 0;\\r\\n      }\\r\\n    };\\r\\n\\r\\n    var resolve = once(function (res) {\\r\\n      // cache resolved\\r\\n      factory.resolved = ensureCtor(res, baseCtor);\\r\\n      // invoke callbacks only if this is not a synchronous resolve\\r\\n      // (async resolves are shimmed as synchronous during SSR)\\r\\n      if (!sync) {\\r\\n        forceRender(true);\\r\\n      }\\r\\n    });\\r\\n\\r\\n    var reject = once(function (reason) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        \\\"Failed to resolve async component: \\\" + (String(factory)) +\\r\\n        (reason ? (\\\"\\\\nReason: \\\" + reason) : '')\\r\\n      );\\r\\n      if (isDef(factory.errorComp)) {\\r\\n        factory.error = true;\\r\\n        forceRender(true);\\r\\n      }\\r\\n    });\\r\\n\\r\\n    var res = factory(resolve, reject);\\r\\n\\r\\n    if (isObject(res)) {\\r\\n      if (typeof res.then === 'function') {\\r\\n        // () => Promise\\r\\n        if (isUndef(factory.resolved)) {\\r\\n          res.then(resolve, reject);\\r\\n        }\\r\\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\\r\\n        res.component.then(resolve, reject);\\r\\n\\r\\n        if (isDef(res.error)) {\\r\\n          factory.errorComp = ensureCtor(res.error, baseCtor);\\r\\n        }\\r\\n\\r\\n        if (isDef(res.loading)) {\\r\\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\\r\\n          if (res.delay === 0) {\\r\\n            factory.loading = true;\\r\\n          } else {\\r\\n            setTimeout(function () {\\r\\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\\r\\n                factory.loading = true;\\r\\n                forceRender(false);\\r\\n              }\\r\\n            }, res.delay || 200);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (isDef(res.timeout)) {\\r\\n          setTimeout(function () {\\r\\n            if (isUndef(factory.resolved)) {\\r\\n              reject(\\r\\n                 false\\r\\n                  ? (undefined)\\r\\n                  : null\\r\\n              );\\r\\n            }\\r\\n          }, res.timeout);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    sync = false;\\r\\n    // return in case resolved synchronously\\r\\n    return factory.loading\\r\\n      ? factory.loadingComp\\r\\n      : factory.resolved\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction isAsyncPlaceholder (node) {\\r\\n  return node.isComment && node.asyncFactory\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction getFirstComponentChild (children) {\\r\\n  if (Array.isArray(children)) {\\r\\n    for (var i = 0; i < children.length; i++) {\\r\\n      var c = children[i];\\r\\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\\r\\n        return c\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initEvents (vm) {\\r\\n  vm._events = Object.create(null);\\r\\n  vm._hasHookEvent = false;\\r\\n  // init parent attached events\\r\\n  var listeners = vm.$options._parentListeners;\\r\\n  if (listeners) {\\r\\n    updateComponentListeners(vm, listeners);\\r\\n  }\\r\\n}\\r\\n\\r\\nvar target;\\r\\n\\r\\nfunction add (event, fn) {\\r\\n  target.$on(event, fn);\\r\\n}\\r\\n\\r\\nfunction remove$1 (event, fn) {\\r\\n  target.$off(event, fn);\\r\\n}\\r\\n\\r\\nfunction createOnceHandler (event, fn) {\\r\\n  var _target = target;\\r\\n  return function onceHandler () {\\r\\n    var res = fn.apply(null, arguments);\\r\\n    if (res !== null) {\\r\\n      _target.$off(event, onceHandler);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction updateComponentListeners (\\r\\n  vm,\\r\\n  listeners,\\r\\n  oldListeners\\r\\n) {\\r\\n  target = vm;\\r\\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\\r\\n  target = undefined;\\r\\n}\\r\\n\\r\\nfunction eventsMixin (Vue) {\\r\\n  var hookRE = /^hook:/;\\r\\n  Vue.prototype.$on = function (event, fn) {\\r\\n    var vm = this;\\r\\n    if (Array.isArray(event)) {\\r\\n      for (var i = 0, l = event.length; i < l; i++) {\\r\\n        vm.$on(event[i], fn);\\r\\n      }\\r\\n    } else {\\r\\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\\r\\n      // optimize hook:event cost by using a boolean flag marked at registration\\r\\n      // instead of a hash lookup\\r\\n      if (hookRE.test(event)) {\\r\\n        vm._hasHookEvent = true;\\r\\n      }\\r\\n    }\\r\\n    return vm\\r\\n  };\\r\\n\\r\\n  Vue.prototype.$once = function (event, fn) {\\r\\n    var vm = this;\\r\\n    function on () {\\r\\n      vm.$off(event, on);\\r\\n      fn.apply(vm, arguments);\\r\\n    }\\r\\n    on.fn = fn;\\r\\n    vm.$on(event, on);\\r\\n    return vm\\r\\n  };\\r\\n\\r\\n  Vue.prototype.$off = function (event, fn) {\\r\\n    var vm = this;\\r\\n    // all\\r\\n    if (!arguments.length) {\\r\\n      vm._events = Object.create(null);\\r\\n      return vm\\r\\n    }\\r\\n    // array of events\\r\\n    if (Array.isArray(event)) {\\r\\n      for (var i = 0, l = event.length; i < l; i++) {\\r\\n        vm.$off(event[i], fn);\\r\\n      }\\r\\n      return vm\\r\\n    }\\r\\n    // specific event\\r\\n    var cbs = vm._events[event];\\r\\n    if (!cbs) {\\r\\n      return vm\\r\\n    }\\r\\n    if (!fn) {\\r\\n      vm._events[event] = null;\\r\\n      return vm\\r\\n    }\\r\\n    if (fn) {\\r\\n      // specific handler\\r\\n      var cb;\\r\\n      var i$1 = cbs.length;\\r\\n      while (i$1--) {\\r\\n        cb = cbs[i$1];\\r\\n        if (cb === fn || cb.fn === fn) {\\r\\n          cbs.splice(i$1, 1);\\r\\n          break\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return vm\\r\\n  };\\r\\n\\r\\n  Vue.prototype.$emit = function (event) {\\r\\n    var vm = this;\\r\\n    if (false) { var lowerCaseEvent; }\\r\\n    var cbs = vm._events[event];\\r\\n    if (cbs) {\\r\\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\\r\\n      var args = toArray(arguments, 1);\\r\\n      for (var i = 0, l = cbs.length; i < l; i++) {\\r\\n        try {\\r\\n          cbs[i].apply(vm, args);\\r\\n        } catch (e) {\\r\\n          handleError(e, vm, (\\\"event handler for \\\\\\\"\\\" + event + \\\"\\\\\\\"\\\"));\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return vm\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * Runtime helper for resolving raw children VNodes into a slot object.\\r\\n */\\r\\nfunction resolveSlots (\\r\\n  children,\\r\\n  context\\r\\n) {\\r\\n  var slots = {};\\r\\n  if (!children) {\\r\\n    return slots\\r\\n  }\\r\\n  for (var i = 0, l = children.length; i < l; i++) {\\r\\n    var child = children[i];\\r\\n    var data = child.data;\\r\\n    // remove slot attribute if the node is resolved as a Vue slot node\\r\\n    if (data && data.attrs && data.attrs.slot) {\\r\\n      delete data.attrs.slot;\\r\\n    }\\r\\n    // named slots should only be respected if the vnode was rendered in the\\r\\n    // same context.\\r\\n    if ((child.context === context || child.fnContext === context) &&\\r\\n      data && data.slot != null\\r\\n    ) {\\r\\n      var name = data.slot;\\r\\n      var slot = (slots[name] || (slots[name] = []));\\r\\n      if (child.tag === 'template') {\\r\\n        slot.push.apply(slot, child.children || []);\\r\\n      } else {\\r\\n        slot.push(child);\\r\\n      }\\r\\n    } else {\\r\\n      (slots.default || (slots.default = [])).push(child);\\r\\n    }\\r\\n  }\\r\\n  // ignore slots that contains only whitespace\\r\\n  for (var name$1 in slots) {\\r\\n    if (slots[name$1].every(isWhitespace)) {\\r\\n      delete slots[name$1];\\r\\n    }\\r\\n  }\\r\\n  return slots\\r\\n}\\r\\n\\r\\nfunction isWhitespace (node) {\\r\\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\\r\\n}\\r\\n\\r\\nfunction resolveScopedSlots (\\r\\n  fns, // see flow/vnode\\r\\n  res\\r\\n) {\\r\\n  res = res || {};\\r\\n  for (var i = 0; i < fns.length; i++) {\\r\\n    if (Array.isArray(fns[i])) {\\r\\n      resolveScopedSlots(fns[i], res);\\r\\n    } else {\\r\\n      res[fns[i].key] = fns[i].fn;\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar activeInstance = null;\\r\\nvar isUpdatingChildComponent = false;\\r\\n\\r\\nfunction setActiveInstance(vm) {\\r\\n  var prevActiveInstance = activeInstance;\\r\\n  activeInstance = vm;\\r\\n  return function () {\\r\\n    activeInstance = prevActiveInstance;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initLifecycle (vm) {\\r\\n  var options = vm.$options;\\r\\n\\r\\n  // locate first non-abstract parent\\r\\n  var parent = options.parent;\\r\\n  if (parent && !options.abstract) {\\r\\n    while (parent.$options.abstract && parent.$parent) {\\r\\n      parent = parent.$parent;\\r\\n    }\\r\\n    parent.$children.push(vm);\\r\\n  }\\r\\n\\r\\n  vm.$parent = parent;\\r\\n  vm.$root = parent ? parent.$root : vm;\\r\\n\\r\\n  vm.$children = [];\\r\\n  vm.$refs = {};\\r\\n\\r\\n  vm._watcher = null;\\r\\n  vm._inactive = null;\\r\\n  vm._directInactive = false;\\r\\n  vm._isMounted = false;\\r\\n  vm._isDestroyed = false;\\r\\n  vm._isBeingDestroyed = false;\\r\\n}\\r\\n\\r\\nfunction lifecycleMixin (Vue) {\\r\\n  Vue.prototype._update = function (vnode, hydrating) {\\r\\n    var vm = this;\\r\\n    var prevEl = vm.$el;\\r\\n    var prevVnode = vm._vnode;\\r\\n    var restoreActiveInstance = setActiveInstance(vm);\\r\\n    vm._vnode = vnode;\\r\\n    // Vue.prototype.__patch__ is injected in entry points\\r\\n    // based on the rendering backend used.\\r\\n    if (!prevVnode) {\\r\\n      // initial render\\r\\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\\r\\n    } else {\\r\\n      // updates\\r\\n      vm.$el = vm.__patch__(prevVnode, vnode);\\r\\n    }\\r\\n    restoreActiveInstance();\\r\\n    // update __vue__ reference\\r\\n    if (prevEl) {\\r\\n      prevEl.__vue__ = null;\\r\\n    }\\r\\n    if (vm.$el) {\\r\\n      vm.$el.__vue__ = vm;\\r\\n    }\\r\\n    // if parent is an HOC, update its $el as well\\r\\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\\r\\n      vm.$parent.$el = vm.$el;\\r\\n    }\\r\\n    // updated hook is called by the scheduler to ensure that children are\\r\\n    // updated in a parent's updated hook.\\r\\n  };\\r\\n\\r\\n  Vue.prototype.$forceUpdate = function () {\\r\\n    var vm = this;\\r\\n    if (vm._watcher) {\\r\\n      vm._watcher.update();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Vue.prototype.$destroy = function () {\\r\\n    var vm = this;\\r\\n    if (vm._isBeingDestroyed) {\\r\\n      return\\r\\n    }\\r\\n    callHook(vm, 'beforeDestroy');\\r\\n    vm._isBeingDestroyed = true;\\r\\n    // remove self from parent\\r\\n    var parent = vm.$parent;\\r\\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\\r\\n      remove(parent.$children, vm);\\r\\n    }\\r\\n    // teardown watchers\\r\\n    if (vm._watcher) {\\r\\n      vm._watcher.teardown();\\r\\n    }\\r\\n    var i = vm._watchers.length;\\r\\n    while (i--) {\\r\\n      vm._watchers[i].teardown();\\r\\n    }\\r\\n    // remove reference from data ob\\r\\n    // frozen object may not have observer.\\r\\n    if (vm._data.__ob__) {\\r\\n      vm._data.__ob__.vmCount--;\\r\\n    }\\r\\n    // call the last hook...\\r\\n    vm._isDestroyed = true;\\r\\n    // invoke destroy hooks on current rendered tree\\r\\n    vm.__patch__(vm._vnode, null);\\r\\n    // fire destroyed hook\\r\\n    callHook(vm, 'destroyed');\\r\\n    // turn off all instance listeners.\\r\\n    vm.$off();\\r\\n    // remove __vue__ reference\\r\\n    if (vm.$el) {\\r\\n      vm.$el.__vue__ = null;\\r\\n    }\\r\\n    // release circular reference (#6759)\\r\\n    if (vm.$vnode) {\\r\\n      vm.$vnode.parent = null;\\r\\n    }\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction mountComponent (\\r\\n  vm,\\r\\n  el,\\r\\n  hydrating\\r\\n) {\\r\\n  vm.$el = el;\\r\\n  if (!vm.$options.render) {\\r\\n    vm.$options.render = createEmptyVNode;\\r\\n    if (false) {}\\r\\n  }\\r\\n  callHook(vm, 'beforeMount');\\r\\n\\r\\n  var updateComponent;\\r\\n  /* istanbul ignore if */\\r\\n  if (false) {} else {\\r\\n    updateComponent = function () {\\r\\n      vm._update(vm._render(), hydrating);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  // we set this to vm._watcher inside the watcher's constructor\\r\\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\\r\\n  // component's mounted hook), which relies on vm._watcher being already defined\\r\\n  new Watcher(vm, updateComponent, noop, {\\r\\n    before: function before () {\\r\\n      if (vm._isMounted) {\\r\\n        callHook(vm, 'beforeUpdate');\\r\\n      }\\r\\n    }\\r\\n  }, true /* isRenderWatcher */);\\r\\n  hydrating = false;\\r\\n\\r\\n  // manually mounted instance, call mounted on self\\r\\n  // mounted is called for render-created child components in its inserted hook\\r\\n  if (vm.$vnode == null) {\\r\\n    vm._isMounted = true;\\r\\n    callHook(vm, 'mounted');\\r\\n  }\\r\\n  return vm\\r\\n}\\r\\n\\r\\nfunction updateChildComponent (\\r\\n  vm,\\r\\n  propsData,\\r\\n  listeners,\\r\\n  parentVnode,\\r\\n  renderChildren\\r\\n) {\\r\\n  if (false) {}\\r\\n\\r\\n  // determine whether component has slot children\\r\\n  // we need to do this before overwriting $options._renderChildren\\r\\n  var hasChildren = !!(\\r\\n    renderChildren ||               // has new static slots\\r\\n    vm.$options._renderChildren ||  // has old static slots\\r\\n    parentVnode.data.scopedSlots || // has new scoped slots\\r\\n    vm.$scopedSlots !== emptyObject // has old scoped slots\\r\\n  );\\r\\n\\r\\n  vm.$options._parentVnode = parentVnode;\\r\\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\\r\\n\\r\\n  if (vm._vnode) { // update child tree's parent\\r\\n    vm._vnode.parent = parentVnode;\\r\\n  }\\r\\n  vm.$options._renderChildren = renderChildren;\\r\\n\\r\\n  // update $attrs and $listeners hash\\r\\n  // these are also reactive so they may trigger child update if the child\\r\\n  // used them during render\\r\\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\\r\\n  vm.$listeners = listeners || emptyObject;\\r\\n\\r\\n  // update props\\r\\n  if (propsData && vm.$options.props) {\\r\\n    toggleObserving(false);\\r\\n    var props = vm._props;\\r\\n    var propKeys = vm.$options._propKeys || [];\\r\\n    for (var i = 0; i < propKeys.length; i++) {\\r\\n      var key = propKeys[i];\\r\\n      var propOptions = vm.$options.props; // wtf flow?\\r\\n      props[key] = validateProp(key, propOptions, propsData, vm);\\r\\n    }\\r\\n    toggleObserving(true);\\r\\n    // keep a copy of raw propsData\\r\\n    vm.$options.propsData = propsData;\\r\\n  }\\r\\n\\r\\n  // update listeners\\r\\n  listeners = listeners || emptyObject;\\r\\n  var oldListeners = vm.$options._parentListeners;\\r\\n  vm.$options._parentListeners = listeners;\\r\\n  updateComponentListeners(vm, listeners, oldListeners);\\r\\n\\r\\n  // resolve slots + force update if has children\\r\\n  if (hasChildren) {\\r\\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\\r\\n    vm.$forceUpdate();\\r\\n  }\\r\\n\\r\\n  if (false) {}\\r\\n}\\r\\n\\r\\nfunction isInInactiveTree (vm) {\\r\\n  while (vm && (vm = vm.$parent)) {\\r\\n    if (vm._inactive) { return true }\\r\\n  }\\r\\n  return false\\r\\n}\\r\\n\\r\\nfunction activateChildComponent (vm, direct) {\\r\\n  if (direct) {\\r\\n    vm._directInactive = false;\\r\\n    if (isInInactiveTree(vm)) {\\r\\n      return\\r\\n    }\\r\\n  } else if (vm._directInactive) {\\r\\n    return\\r\\n  }\\r\\n  if (vm._inactive || vm._inactive === null) {\\r\\n    vm._inactive = false;\\r\\n    for (var i = 0; i < vm.$children.length; i++) {\\r\\n      activateChildComponent(vm.$children[i]);\\r\\n    }\\r\\n    callHook(vm, 'activated');\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction deactivateChildComponent (vm, direct) {\\r\\n  if (direct) {\\r\\n    vm._directInactive = true;\\r\\n    if (isInInactiveTree(vm)) {\\r\\n      return\\r\\n    }\\r\\n  }\\r\\n  if (!vm._inactive) {\\r\\n    vm._inactive = true;\\r\\n    for (var i = 0; i < vm.$children.length; i++) {\\r\\n      deactivateChildComponent(vm.$children[i]);\\r\\n    }\\r\\n    callHook(vm, 'deactivated');\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction callHook (vm, hook) {\\r\\n  // #7573 disable dep collection when invoking lifecycle hooks\\r\\n  pushTarget();\\r\\n  var handlers = vm.$options[hook];\\r\\n  if (handlers) {\\r\\n    for (var i = 0, j = handlers.length; i < j; i++) {\\r\\n      try {\\r\\n        handlers[i].call(vm);\\r\\n      } catch (e) {\\r\\n        handleError(e, vm, (hook + \\\" hook\\\"));\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  if (vm._hasHookEvent) {\\r\\n    vm.$emit('hook:' + hook);\\r\\n  }\\r\\n  popTarget();\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar MAX_UPDATE_COUNT = 100;\\r\\n\\r\\nvar queue = [];\\r\\nvar activatedChildren = [];\\r\\nvar has = {};\\r\\nvar circular = {};\\r\\nvar waiting = false;\\r\\nvar flushing = false;\\r\\nvar index = 0;\\r\\n\\r\\n/**\\r\\n * Reset the scheduler's state.\\r\\n */\\r\\nfunction resetSchedulerState () {\\r\\n  index = queue.length = activatedChildren.length = 0;\\r\\n  has = {};\\r\\n  if (false) {}\\r\\n  waiting = flushing = false;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Flush both queues and run the watchers.\\r\\n */\\r\\nfunction flushSchedulerQueue () {\\r\\n  flushing = true;\\r\\n  var watcher, id;\\r\\n\\r\\n  // Sort queue before flush.\\r\\n  // This ensures that:\\r\\n  // 1. Components are updated from parent to child. (because parent is always\\r\\n  //    created before the child)\\r\\n  // 2. A component's user watchers are run before its render watcher (because\\r\\n  //    user watchers are created before the render watcher)\\r\\n  // 3. If a component is destroyed during a parent component's watcher run,\\r\\n  //    its watchers can be skipped.\\r\\n  queue.sort(function (a, b) { return a.id - b.id; });\\r\\n\\r\\n  // do not cache length because more watchers might be pushed\\r\\n  // as we run existing watchers\\r\\n  for (index = 0; index < queue.length; index++) {\\r\\n    watcher = queue[index];\\r\\n    if (watcher.before) {\\r\\n      watcher.before();\\r\\n    }\\r\\n    id = watcher.id;\\r\\n    has[id] = null;\\r\\n    watcher.run();\\r\\n    // in dev build, check and stop circular updates.\\r\\n    if (false) {}\\r\\n  }\\r\\n\\r\\n  // keep copies of post queues before resetting state\\r\\n  var activatedQueue = activatedChildren.slice();\\r\\n  var updatedQueue = queue.slice();\\r\\n\\r\\n  resetSchedulerState();\\r\\n\\r\\n  // call component updated and activated hooks\\r\\n  callActivatedHooks(activatedQueue);\\r\\n  callUpdatedHooks(updatedQueue);\\r\\n\\r\\n  // devtool hook\\r\\n  /* istanbul ignore if */\\r\\n  if (devtools && config.devtools) {\\r\\n    devtools.emit('flush');\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction callUpdatedHooks (queue) {\\r\\n  var i = queue.length;\\r\\n  while (i--) {\\r\\n    var watcher = queue[i];\\r\\n    var vm = watcher.vm;\\r\\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\\r\\n      callHook(vm, 'updated');\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Queue a kept-alive component that was activated during patch.\\r\\n * The queue will be processed after the entire tree has been patched.\\r\\n */\\r\\nfunction queueActivatedComponent (vm) {\\r\\n  // setting _inactive to false here so that a render function can\\r\\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\\r\\n  vm._inactive = false;\\r\\n  activatedChildren.push(vm);\\r\\n}\\r\\n\\r\\nfunction callActivatedHooks (queue) {\\r\\n  for (var i = 0; i < queue.length; i++) {\\r\\n    queue[i]._inactive = true;\\r\\n    activateChildComponent(queue[i], true /* true */);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Push a watcher into the watcher queue.\\r\\n * Jobs with duplicate IDs will be skipped unless it's\\r\\n * pushed when the queue is being flushed.\\r\\n */\\r\\nfunction queueWatcher (watcher) {\\r\\n  var id = watcher.id;\\r\\n  if (has[id] == null) {\\r\\n    has[id] = true;\\r\\n    if (!flushing) {\\r\\n      queue.push(watcher);\\r\\n    } else {\\r\\n      // if already flushing, splice the watcher based on its id\\r\\n      // if already past its id, it will be run next immediately.\\r\\n      var i = queue.length - 1;\\r\\n      while (i > index && queue[i].id > watcher.id) {\\r\\n        i--;\\r\\n      }\\r\\n      queue.splice(i + 1, 0, watcher);\\r\\n    }\\r\\n    // queue the flush\\r\\n    if (!waiting) {\\r\\n      waiting = true;\\r\\n\\r\\n      if (false) {}\\r\\n      nextTick(flushSchedulerQueue);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nvar uid$1 = 0;\\r\\n\\r\\n/**\\r\\n * A watcher parses an expression, collects dependencies,\\r\\n * and fires callback when the expression value changes.\\r\\n * This is used for both the $watch() api and directives.\\r\\n */\\r\\nvar Watcher = function Watcher (\\r\\n  vm,\\r\\n  expOrFn,\\r\\n  cb,\\r\\n  options,\\r\\n  isRenderWatcher\\r\\n) {\\r\\n  this.vm = vm;\\r\\n  if (isRenderWatcher) {\\r\\n    vm._watcher = this;\\r\\n  }\\r\\n  vm._watchers.push(this);\\r\\n  // options\\r\\n  if (options) {\\r\\n    this.deep = !!options.deep;\\r\\n    this.user = !!options.user;\\r\\n    this.lazy = !!options.lazy;\\r\\n    this.sync = !!options.sync;\\r\\n    this.before = options.before;\\r\\n  } else {\\r\\n    this.deep = this.user = this.lazy = this.sync = false;\\r\\n  }\\r\\n  this.cb = cb;\\r\\n  this.id = ++uid$1; // uid for batching\\r\\n  this.active = true;\\r\\n  this.dirty = this.lazy; // for lazy watchers\\r\\n  this.deps = [];\\r\\n  this.newDeps = [];\\r\\n  this.depIds = new _Set();\\r\\n  this.newDepIds = new _Set();\\r\\n  this.expression =  false\\r\\n    ? undefined\\r\\n    : '';\\r\\n  // parse expression for getter\\r\\n  if (typeof expOrFn === 'function') {\\r\\n    this.getter = expOrFn;\\r\\n  } else {\\r\\n    this.getter = parsePath(expOrFn);\\r\\n    if (!this.getter) {\\r\\n      this.getter = noop;\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        \\\"Failed watching path: \\\\\\\"\\\" + expOrFn + \\\"\\\\\\\" \\\" +\\r\\n        'Watcher only accepts simple dot-delimited paths. ' +\\r\\n        'For full control, use a function instead.',\\r\\n        vm\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n  this.value = this.lazy\\r\\n    ? undefined\\r\\n    : this.get();\\r\\n};\\r\\n\\r\\n/**\\r\\n * Evaluate the getter, and re-collect dependencies.\\r\\n */\\r\\nWatcher.prototype.get = function get () {\\r\\n  pushTarget(this);\\r\\n  var value;\\r\\n  var vm = this.vm;\\r\\n  try {\\r\\n    value = this.getter.call(vm, vm);\\r\\n  } catch (e) {\\r\\n    if (this.user) {\\r\\n      handleError(e, vm, (\\\"getter for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\r\\n    } else {\\r\\n      throw e\\r\\n    }\\r\\n  } finally {\\r\\n    // \\\"touch\\\" every property so they are all tracked as\\r\\n    // dependencies for deep watching\\r\\n    if (this.deep) {\\r\\n      traverse(value);\\r\\n    }\\r\\n    popTarget();\\r\\n    this.cleanupDeps();\\r\\n  }\\r\\n  return value\\r\\n};\\r\\n\\r\\n/**\\r\\n * Add a dependency to this directive.\\r\\n */\\r\\nWatcher.prototype.addDep = function addDep (dep) {\\r\\n  var id = dep.id;\\r\\n  if (!this.newDepIds.has(id)) {\\r\\n    this.newDepIds.add(id);\\r\\n    this.newDeps.push(dep);\\r\\n    if (!this.depIds.has(id)) {\\r\\n      dep.addSub(this);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Clean up for dependency collection.\\r\\n */\\r\\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\\r\\n  var i = this.deps.length;\\r\\n  while (i--) {\\r\\n    var dep = this.deps[i];\\r\\n    if (!this.newDepIds.has(dep.id)) {\\r\\n      dep.removeSub(this);\\r\\n    }\\r\\n  }\\r\\n  var tmp = this.depIds;\\r\\n  this.depIds = this.newDepIds;\\r\\n  this.newDepIds = tmp;\\r\\n  this.newDepIds.clear();\\r\\n  tmp = this.deps;\\r\\n  this.deps = this.newDeps;\\r\\n  this.newDeps = tmp;\\r\\n  this.newDeps.length = 0;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Subscriber interface.\\r\\n * Will be called when a dependency changes.\\r\\n */\\r\\nWatcher.prototype.update = function update () {\\r\\n  /* istanbul ignore else */\\r\\n  if (this.lazy) {\\r\\n    this.dirty = true;\\r\\n  } else if (this.sync) {\\r\\n    this.run();\\r\\n  } else {\\r\\n    queueWatcher(this);\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Scheduler job interface.\\r\\n * Will be called by the scheduler.\\r\\n */\\r\\nWatcher.prototype.run = function run () {\\r\\n  if (this.active) {\\r\\n    var value = this.get();\\r\\n    if (\\r\\n      value !== this.value ||\\r\\n      // Deep watchers and watchers on Object/Arrays should fire even\\r\\n      // when the value is the same, because the value may\\r\\n      // have mutated.\\r\\n      isObject(value) ||\\r\\n      this.deep\\r\\n    ) {\\r\\n      // set new value\\r\\n      var oldValue = this.value;\\r\\n      this.value = value;\\r\\n      if (this.user) {\\r\\n        try {\\r\\n          this.cb.call(this.vm, value, oldValue);\\r\\n        } catch (e) {\\r\\n          handleError(e, this.vm, (\\\"callback for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\r\\n        }\\r\\n      } else {\\r\\n        this.cb.call(this.vm, value, oldValue);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Evaluate the value of the watcher.\\r\\n * This only gets called for lazy watchers.\\r\\n */\\r\\nWatcher.prototype.evaluate = function evaluate () {\\r\\n  this.value = this.get();\\r\\n  this.dirty = false;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Depend on all deps collected by this watcher.\\r\\n */\\r\\nWatcher.prototype.depend = function depend () {\\r\\n  var i = this.deps.length;\\r\\n  while (i--) {\\r\\n    this.deps[i].depend();\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Remove self from all dependencies' subscriber list.\\r\\n */\\r\\nWatcher.prototype.teardown = function teardown () {\\r\\n  if (this.active) {\\r\\n    // remove self from vm's watcher list\\r\\n    // this is a somewhat expensive operation so we skip it\\r\\n    // if the vm is being destroyed.\\r\\n    if (!this.vm._isBeingDestroyed) {\\r\\n      remove(this.vm._watchers, this);\\r\\n    }\\r\\n    var i = this.deps.length;\\r\\n    while (i--) {\\r\\n      this.deps[i].removeSub(this);\\r\\n    }\\r\\n    this.active = false;\\r\\n  }\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar sharedPropertyDefinition = {\\r\\n  enumerable: true,\\r\\n  configurable: true,\\r\\n  get: noop,\\r\\n  set: noop\\r\\n};\\r\\n\\r\\nfunction proxy (target, sourceKey, key) {\\r\\n  sharedPropertyDefinition.get = function proxyGetter () {\\r\\n    return this[sourceKey][key]\\r\\n  };\\r\\n  sharedPropertyDefinition.set = function proxySetter (val) {\\r\\n    this[sourceKey][key] = val;\\r\\n  };\\r\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\r\\n}\\r\\n\\r\\nfunction initState (vm) {\\r\\n  vm._watchers = [];\\r\\n  var opts = vm.$options;\\r\\n  if (opts.props) { initProps(vm, opts.props); }\\r\\n  if (opts.methods) { initMethods(vm, opts.methods); }\\r\\n  if (opts.data) {\\r\\n    initData(vm);\\r\\n  } else {\\r\\n    observe(vm._data = {}, true /* asRootData */);\\r\\n  }\\r\\n  if (opts.computed) { initComputed(vm, opts.computed); }\\r\\n  if (opts.watch && opts.watch !== nativeWatch) {\\r\\n    initWatch(vm, opts.watch);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initProps (vm, propsOptions) {\\r\\n  var propsData = vm.$options.propsData || {};\\r\\n  var props = vm._props = {};\\r\\n  // cache prop keys so that future props updates can iterate using Array\\r\\n  // instead of dynamic object key enumeration.\\r\\n  var keys = vm.$options._propKeys = [];\\r\\n  var isRoot = !vm.$parent;\\r\\n  // root instance props should be converted\\r\\n  if (!isRoot) {\\r\\n    toggleObserving(false);\\r\\n  }\\r\\n  var loop = function ( key ) {\\r\\n    keys.push(key);\\r\\n    var value = validateProp(key, propsOptions, propsData, vm);\\r\\n    /* istanbul ignore else */\\r\\n    if (false) { var hyphenatedKey; } else {\\r\\n      defineReactive$$1(props, key, value);\\r\\n    }\\r\\n    // static props are already proxied on the component's prototype\\r\\n    // during Vue.extend(). We only need to proxy props defined at\\r\\n    // instantiation here.\\r\\n    if (!(key in vm)) {\\r\\n      proxy(vm, \\\"_props\\\", key);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  for (var key in propsOptions) loop( key );\\r\\n  toggleObserving(true);\\r\\n}\\r\\n\\r\\nfunction initData (vm) {\\r\\n  var data = vm.$options.data;\\r\\n  data = vm._data = typeof data === 'function'\\r\\n    ? getData(data, vm)\\r\\n    : data || {};\\r\\n  if (!isPlainObject(data)) {\\r\\n    data = {};\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      'data functions should return an object:\\\\n' +\\r\\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\\r\\n      vm\\r\\n    );\\r\\n  }\\r\\n  // proxy data on instance\\r\\n  var keys = Object.keys(data);\\r\\n  var props = vm.$options.props;\\r\\n  var methods = vm.$options.methods;\\r\\n  var i = keys.length;\\r\\n  while (i--) {\\r\\n    var key = keys[i];\\r\\n    if (false) {}\\r\\n    if (props && hasOwn(props, key)) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        \\\"The data property \\\\\\\"\\\" + key + \\\"\\\\\\\" is already declared as a prop. \\\" +\\r\\n        \\\"Use prop default value instead.\\\",\\r\\n        vm\\r\\n      );\\r\\n    } else if (!isReserved(key)) {\\r\\n      proxy(vm, \\\"_data\\\", key);\\r\\n    }\\r\\n  }\\r\\n  // observe data\\r\\n  observe(data, true /* asRootData */);\\r\\n}\\r\\n\\r\\nfunction getData (data, vm) {\\r\\n  // #7573 disable dep collection when invoking data getters\\r\\n  pushTarget();\\r\\n  try {\\r\\n    return data.call(vm, vm)\\r\\n  } catch (e) {\\r\\n    handleError(e, vm, \\\"data()\\\");\\r\\n    return {}\\r\\n  } finally {\\r\\n    popTarget();\\r\\n  }\\r\\n}\\r\\n\\r\\nvar computedWatcherOptions = { lazy: true };\\r\\n\\r\\nfunction initComputed (vm, computed) {\\r\\n  // $flow-disable-line\\r\\n  var watchers = vm._computedWatchers = Object.create(null);\\r\\n  // computed properties are just getters during SSR\\r\\n  var isSSR = isServerRendering();\\r\\n\\r\\n  for (var key in computed) {\\r\\n    var userDef = computed[key];\\r\\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\\r\\n    if (false) {}\\r\\n\\r\\n    if (!isSSR) {\\r\\n      // create internal watcher for the computed property.\\r\\n      watchers[key] = new Watcher(\\r\\n        vm,\\r\\n        getter || noop,\\r\\n        noop,\\r\\n        computedWatcherOptions\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // component-defined computed properties are already defined on the\\r\\n    // component prototype. We only need to define computed properties defined\\r\\n    // at instantiation here.\\r\\n    if (!(key in vm)) {\\r\\n      defineComputed(vm, key, userDef);\\r\\n    } else if (false) {}\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction defineComputed (\\r\\n  target,\\r\\n  key,\\r\\n  userDef\\r\\n) {\\r\\n  var shouldCache = !isServerRendering();\\r\\n  if (typeof userDef === 'function') {\\r\\n    sharedPropertyDefinition.get = shouldCache\\r\\n      ? createComputedGetter(key)\\r\\n      : createGetterInvoker(userDef);\\r\\n    sharedPropertyDefinition.set = noop;\\r\\n  } else {\\r\\n    sharedPropertyDefinition.get = userDef.get\\r\\n      ? shouldCache && userDef.cache !== false\\r\\n        ? createComputedGetter(key)\\r\\n        : createGetterInvoker(userDef.get)\\r\\n      : noop;\\r\\n    sharedPropertyDefinition.set = userDef.set || noop;\\r\\n  }\\r\\n  if (false) {}\\r\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\r\\n}\\r\\n\\r\\nfunction createComputedGetter (key) {\\r\\n  return function computedGetter () {\\r\\n    var watcher = this._computedWatchers && this._computedWatchers[key];\\r\\n    if (watcher) {\\r\\n      if (watcher.dirty) {\\r\\n        watcher.evaluate();\\r\\n      }\\r\\n      if (Dep.target) {\\r\\n        watcher.depend();\\r\\n      }\\r\\n      return watcher.value\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createGetterInvoker(fn) {\\r\\n  return function computedGetter () {\\r\\n    return fn.call(this, this)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initMethods (vm, methods) {\\r\\n  var props = vm.$options.props;\\r\\n  for (var key in methods) {\\r\\n    if (false) {}\\r\\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initWatch (vm, watch) {\\r\\n  for (var key in watch) {\\r\\n    var handler = watch[key];\\r\\n    if (Array.isArray(handler)) {\\r\\n      for (var i = 0; i < handler.length; i++) {\\r\\n        createWatcher(vm, key, handler[i]);\\r\\n      }\\r\\n    } else {\\r\\n      createWatcher(vm, key, handler);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createWatcher (\\r\\n  vm,\\r\\n  expOrFn,\\r\\n  handler,\\r\\n  options\\r\\n) {\\r\\n  if (isPlainObject(handler)) {\\r\\n    options = handler;\\r\\n    handler = handler.handler;\\r\\n  }\\r\\n  if (typeof handler === 'string') {\\r\\n    handler = vm[handler];\\r\\n  }\\r\\n  return vm.$watch(expOrFn, handler, options)\\r\\n}\\r\\n\\r\\nfunction stateMixin (Vue) {\\r\\n  // flow somehow has problems with directly declared definition object\\r\\n  // when using Object.defineProperty, so we have to procedurally build up\\r\\n  // the object here.\\r\\n  var dataDef = {};\\r\\n  dataDef.get = function () { return this._data };\\r\\n  var propsDef = {};\\r\\n  propsDef.get = function () { return this._props };\\r\\n  if (false) {}\\r\\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\\r\\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\\r\\n\\r\\n  Vue.prototype.$set = set;\\r\\n  Vue.prototype.$delete = del;\\r\\n\\r\\n  Vue.prototype.$watch = function (\\r\\n    expOrFn,\\r\\n    cb,\\r\\n    options\\r\\n  ) {\\r\\n    var vm = this;\\r\\n    if (isPlainObject(cb)) {\\r\\n      return createWatcher(vm, expOrFn, cb, options)\\r\\n    }\\r\\n    options = options || {};\\r\\n    options.user = true;\\r\\n    var watcher = new Watcher(vm, expOrFn, cb, options);\\r\\n    if (options.immediate) {\\r\\n      try {\\r\\n        cb.call(vm, watcher.value);\\r\\n      } catch (error) {\\r\\n        handleError(error, vm, (\\\"callback for immediate watcher \\\\\\\"\\\" + (watcher.expression) + \\\"\\\\\\\"\\\"));\\r\\n      }\\r\\n    }\\r\\n    return function unwatchFn () {\\r\\n      watcher.teardown();\\r\\n    }\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initProvide (vm) {\\r\\n  var provide = vm.$options.provide;\\r\\n  if (provide) {\\r\\n    vm._provided = typeof provide === 'function'\\r\\n      ? provide.call(vm)\\r\\n      : provide;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initInjections (vm) {\\r\\n  var result = resolveInject(vm.$options.inject, vm);\\r\\n  if (result) {\\r\\n    toggleObserving(false);\\r\\n    Object.keys(result).forEach(function (key) {\\r\\n      /* istanbul ignore else */\\r\\n      if (false) {} else {\\r\\n        defineReactive$$1(vm, key, result[key]);\\r\\n      }\\r\\n    });\\r\\n    toggleObserving(true);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction resolveInject (inject, vm) {\\r\\n  if (inject) {\\r\\n    // inject is :any because flow is not smart enough to figure out cached\\r\\n    var result = Object.create(null);\\r\\n    var keys = hasSymbol\\r\\n      ? Reflect.ownKeys(inject).filter(function (key) {\\r\\n        /* istanbul ignore next */\\r\\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\\r\\n      })\\r\\n      : Object.keys(inject);\\r\\n\\r\\n    for (var i = 0; i < keys.length; i++) {\\r\\n      var key = keys[i];\\r\\n      var provideKey = inject[key].from;\\r\\n      var source = vm;\\r\\n      while (source) {\\r\\n        if (source._provided && hasOwn(source._provided, provideKey)) {\\r\\n          result[key] = source._provided[provideKey];\\r\\n          break\\r\\n        }\\r\\n        source = source.$parent;\\r\\n      }\\r\\n      if (!source) {\\r\\n        if ('default' in inject[key]) {\\r\\n          var provideDefault = inject[key].default;\\r\\n          result[key] = typeof provideDefault === 'function'\\r\\n            ? provideDefault.call(vm)\\r\\n            : provideDefault;\\r\\n        } else if (false) {}\\r\\n      }\\r\\n    }\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Runtime helper for rendering v-for lists.\\r\\n */\\r\\nfunction renderList (\\r\\n  val,\\r\\n  render\\r\\n) {\\r\\n  var ret, i, l, keys, key;\\r\\n  if (Array.isArray(val) || typeof val === 'string') {\\r\\n    ret = new Array(val.length);\\r\\n    for (i = 0, l = val.length; i < l; i++) {\\r\\n      ret[i] = render(val[i], i);\\r\\n    }\\r\\n  } else if (typeof val === 'number') {\\r\\n    ret = new Array(val);\\r\\n    for (i = 0; i < val; i++) {\\r\\n      ret[i] = render(i + 1, i);\\r\\n    }\\r\\n  } else if (isObject(val)) {\\r\\n    keys = Object.keys(val);\\r\\n    ret = new Array(keys.length);\\r\\n    for (i = 0, l = keys.length; i < l; i++) {\\r\\n      key = keys[i];\\r\\n      ret[i] = render(val[key], key, i);\\r\\n    }\\r\\n  }\\r\\n  if (isDef(ret)) {\\r\\n    (ret)._isVList = true;\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Runtime helper for rendering <slot>\\r\\n */\\r\\nfunction renderSlot (\\r\\n  name,\\r\\n  fallback,\\r\\n  props,\\r\\n  bindObject\\r\\n) {\\r\\n  var scopedSlotFn = this.$scopedSlots[name];\\r\\n  var nodes;\\r\\n  if (scopedSlotFn) { // scoped slot\\r\\n    props = props || {};\\r\\n    if (bindObject) {\\r\\n      if (false) {}\\r\\n      props = extend(extend({}, bindObject), props);\\r\\n    }\\r\\n    nodes = scopedSlotFn(props) || fallback;\\r\\n  } else {\\r\\n    nodes = this.$slots[name] || fallback;\\r\\n  }\\r\\n\\r\\n  var target = props && props.slot;\\r\\n  if (target) {\\r\\n    return this.$createElement('template', { slot: target }, nodes)\\r\\n  } else {\\r\\n    return nodes\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Runtime helper for resolving filters\\r\\n */\\r\\nfunction resolveFilter (id) {\\r\\n  return resolveAsset(this.$options, 'filters', id, true) || identity\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction isKeyNotMatch (expect, actual) {\\r\\n  if (Array.isArray(expect)) {\\r\\n    return expect.indexOf(actual) === -1\\r\\n  } else {\\r\\n    return expect !== actual\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Runtime helper for checking keyCodes from config.\\r\\n * exposed as Vue.prototype._k\\r\\n * passing in eventKeyName as last argument separately for backwards compat\\r\\n */\\r\\nfunction checkKeyCodes (\\r\\n  eventKeyCode,\\r\\n  key,\\r\\n  builtInKeyCode,\\r\\n  eventKeyName,\\r\\n  builtInKeyName\\r\\n) {\\r\\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\\r\\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\\r\\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\\r\\n  } else if (mappedKeyCode) {\\r\\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\\r\\n  } else if (eventKeyName) {\\r\\n    return hyphenate(eventKeyName) !== key\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Runtime helper for merging v-bind=\\\"object\\\" into a VNode's data.\\r\\n */\\r\\nfunction bindObjectProps (\\r\\n  data,\\r\\n  tag,\\r\\n  value,\\r\\n  asProp,\\r\\n  isSync\\r\\n) {\\r\\n  if (value) {\\r\\n    if (!isObject(value)) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        'v-bind without argument expects an Object or Array value',\\r\\n        this\\r\\n      );\\r\\n    } else {\\r\\n      if (Array.isArray(value)) {\\r\\n        value = toObject(value);\\r\\n      }\\r\\n      var hash;\\r\\n      var loop = function ( key ) {\\r\\n        if (\\r\\n          key === 'class' ||\\r\\n          key === 'style' ||\\r\\n          isReservedAttribute(key)\\r\\n        ) {\\r\\n          hash = data;\\r\\n        } else {\\r\\n          var type = data.attrs && data.attrs.type;\\r\\n          hash = asProp || config.mustUseProp(tag, type, key)\\r\\n            ? data.domProps || (data.domProps = {})\\r\\n            : data.attrs || (data.attrs = {});\\r\\n        }\\r\\n        var camelizedKey = camelize(key);\\r\\n        if (!(key in hash) && !(camelizedKey in hash)) {\\r\\n          hash[key] = value[key];\\r\\n\\r\\n          if (isSync) {\\r\\n            var on = data.on || (data.on = {});\\r\\n            on[(\\\"update:\\\" + camelizedKey)] = function ($event) {\\r\\n              value[key] = $event;\\r\\n            };\\r\\n          }\\r\\n        }\\r\\n      };\\r\\n\\r\\n      for (var key in value) loop( key );\\r\\n    }\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Runtime helper for rendering static trees.\\r\\n */\\r\\nfunction renderStatic (\\r\\n  index,\\r\\n  isInFor\\r\\n) {\\r\\n  var cached = this._staticTrees || (this._staticTrees = []);\\r\\n  var tree = cached[index];\\r\\n  // if has already-rendered static tree and not inside v-for,\\r\\n  // we can reuse the same tree.\\r\\n  if (tree && !isInFor) {\\r\\n    return tree\\r\\n  }\\r\\n  // otherwise, render a fresh tree.\\r\\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\\r\\n    this._renderProxy,\\r\\n    null,\\r\\n    this // for render fns generated for functional component templates\\r\\n  );\\r\\n  markStatic(tree, (\\\"__static__\\\" + index), false);\\r\\n  return tree\\r\\n}\\r\\n\\r\\n/**\\r\\n * Runtime helper for v-once.\\r\\n * Effectively it means marking the node as static with a unique key.\\r\\n */\\r\\nfunction markOnce (\\r\\n  tree,\\r\\n  index,\\r\\n  key\\r\\n) {\\r\\n  markStatic(tree, (\\\"__once__\\\" + index + (key ? (\\\"_\\\" + key) : \\\"\\\")), true);\\r\\n  return tree\\r\\n}\\r\\n\\r\\nfunction markStatic (\\r\\n  tree,\\r\\n  key,\\r\\n  isOnce\\r\\n) {\\r\\n  if (Array.isArray(tree)) {\\r\\n    for (var i = 0; i < tree.length; i++) {\\r\\n      if (tree[i] && typeof tree[i] !== 'string') {\\r\\n        markStaticNode(tree[i], (key + \\\"_\\\" + i), isOnce);\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    markStaticNode(tree, key, isOnce);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction markStaticNode (node, key, isOnce) {\\r\\n  node.isStatic = true;\\r\\n  node.key = key;\\r\\n  node.isOnce = isOnce;\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction bindObjectListeners (data, value) {\\r\\n  if (value) {\\r\\n    if (!isPlainObject(value)) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        'v-on without argument expects an Object value',\\r\\n        this\\r\\n      );\\r\\n    } else {\\r\\n      var on = data.on = data.on ? extend({}, data.on) : {};\\r\\n      for (var key in value) {\\r\\n        var existing = on[key];\\r\\n        var ours = value[key];\\r\\n        on[key] = existing ? [].concat(existing, ours) : ours;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction installRenderHelpers (target) {\\r\\n  target._o = markOnce;\\r\\n  target._n = toNumber;\\r\\n  target._s = toString;\\r\\n  target._l = renderList;\\r\\n  target._t = renderSlot;\\r\\n  target._q = looseEqual;\\r\\n  target._i = looseIndexOf;\\r\\n  target._m = renderStatic;\\r\\n  target._f = resolveFilter;\\r\\n  target._k = checkKeyCodes;\\r\\n  target._b = bindObjectProps;\\r\\n  target._v = createTextVNode;\\r\\n  target._e = createEmptyVNode;\\r\\n  target._u = resolveScopedSlots;\\r\\n  target._g = bindObjectListeners;\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction FunctionalRenderContext (\\r\\n  data,\\r\\n  props,\\r\\n  children,\\r\\n  parent,\\r\\n  Ctor\\r\\n) {\\r\\n  var options = Ctor.options;\\r\\n  // ensure the createElement function in functional components\\r\\n  // gets a unique context - this is necessary for correct named slot check\\r\\n  var contextVm;\\r\\n  if (hasOwn(parent, '_uid')) {\\r\\n    contextVm = Object.create(parent);\\r\\n    // $flow-disable-line\\r\\n    contextVm._original = parent;\\r\\n  } else {\\r\\n    // the context vm passed in is a functional context as well.\\r\\n    // in this case we want to make sure we are able to get a hold to the\\r\\n    // real context instance.\\r\\n    contextVm = parent;\\r\\n    // $flow-disable-line\\r\\n    parent = parent._original;\\r\\n  }\\r\\n  var isCompiled = isTrue(options._compiled);\\r\\n  var needNormalization = !isCompiled;\\r\\n\\r\\n  this.data = data;\\r\\n  this.props = props;\\r\\n  this.children = children;\\r\\n  this.parent = parent;\\r\\n  this.listeners = data.on || emptyObject;\\r\\n  this.injections = resolveInject(options.inject, parent);\\r\\n  this.slots = function () { return resolveSlots(children, parent); };\\r\\n\\r\\n  // support for compiled functional template\\r\\n  if (isCompiled) {\\r\\n    // exposing $options for renderStatic()\\r\\n    this.$options = options;\\r\\n    // pre-resolve slots for renderSlot()\\r\\n    this.$slots = this.slots();\\r\\n    this.$scopedSlots = data.scopedSlots || emptyObject;\\r\\n  }\\r\\n\\r\\n  if (options._scopeId) {\\r\\n    this._c = function (a, b, c, d) {\\r\\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\\r\\n      if (vnode && !Array.isArray(vnode)) {\\r\\n        vnode.fnScopeId = options._scopeId;\\r\\n        vnode.fnContext = parent;\\r\\n      }\\r\\n      return vnode\\r\\n    };\\r\\n  } else {\\r\\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\\r\\n  }\\r\\n}\\r\\n\\r\\ninstallRenderHelpers(FunctionalRenderContext.prototype);\\r\\n\\r\\nfunction createFunctionalComponent (\\r\\n  Ctor,\\r\\n  propsData,\\r\\n  data,\\r\\n  contextVm,\\r\\n  children\\r\\n) {\\r\\n  var options = Ctor.options;\\r\\n  var props = {};\\r\\n  var propOptions = options.props;\\r\\n  if (isDef(propOptions)) {\\r\\n    for (var key in propOptions) {\\r\\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\\r\\n    }\\r\\n  } else {\\r\\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\\r\\n    if (isDef(data.props)) { mergeProps(props, data.props); }\\r\\n  }\\r\\n\\r\\n  var renderContext = new FunctionalRenderContext(\\r\\n    data,\\r\\n    props,\\r\\n    children,\\r\\n    contextVm,\\r\\n    Ctor\\r\\n  );\\r\\n\\r\\n  var vnode = options.render.call(null, renderContext._c, renderContext);\\r\\n\\r\\n  if (vnode instanceof VNode) {\\r\\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\\r\\n  } else if (Array.isArray(vnode)) {\\r\\n    var vnodes = normalizeChildren(vnode) || [];\\r\\n    var res = new Array(vnodes.length);\\r\\n    for (var i = 0; i < vnodes.length; i++) {\\r\\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\\r\\n    }\\r\\n    return res\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\\r\\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\\r\\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\\r\\n  // that should not be matched to match.\\r\\n  var clone = cloneVNode(vnode);\\r\\n  clone.fnContext = contextVm;\\r\\n  clone.fnOptions = options;\\r\\n  if (false) {}\\r\\n  if (data.slot) {\\r\\n    (clone.data || (clone.data = {})).slot = data.slot;\\r\\n  }\\r\\n  return clone\\r\\n}\\r\\n\\r\\nfunction mergeProps (to, from) {\\r\\n  for (var key in from) {\\r\\n    to[camelize(key)] = from[key];\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/*  */\\r\\n\\r\\n/*  */\\r\\n\\r\\n/*  */\\r\\n\\r\\n// inline hooks to be invoked on component VNodes during patch\\r\\nvar componentVNodeHooks = {\\r\\n  init: function init (vnode, hydrating) {\\r\\n    if (\\r\\n      vnode.componentInstance &&\\r\\n      !vnode.componentInstance._isDestroyed &&\\r\\n      vnode.data.keepAlive\\r\\n    ) {\\r\\n      // kept-alive components, treat as a patch\\r\\n      var mountedNode = vnode; // work around flow\\r\\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\\r\\n    } else {\\r\\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\\r\\n        vnode,\\r\\n        activeInstance\\r\\n      );\\r\\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\\r\\n    }\\r\\n  },\\r\\n\\r\\n  prepatch: function prepatch (oldVnode, vnode) {\\r\\n    var options = vnode.componentOptions;\\r\\n    var child = vnode.componentInstance = oldVnode.componentInstance;\\r\\n    updateChildComponent(\\r\\n      child,\\r\\n      options.propsData, // updated props\\r\\n      options.listeners, // updated listeners\\r\\n      vnode, // new parent vnode\\r\\n      options.children // new children\\r\\n    );\\r\\n  },\\r\\n\\r\\n  insert: function insert (vnode) {\\r\\n    var context = vnode.context;\\r\\n    var componentInstance = vnode.componentInstance;\\r\\n    if (!componentInstance._isMounted) {\\r\\n      componentInstance._isMounted = true;\\r\\n      callHook(componentInstance, 'mounted');\\r\\n    }\\r\\n    if (vnode.data.keepAlive) {\\r\\n      if (context._isMounted) {\\r\\n        // vue-router#1212\\r\\n        // During updates, a kept-alive component's child components may\\r\\n        // change, so directly walking the tree here may call activated hooks\\r\\n        // on incorrect children. Instead we push them into a queue which will\\r\\n        // be processed after the whole patch process ended.\\r\\n        queueActivatedComponent(componentInstance);\\r\\n      } else {\\r\\n        activateChildComponent(componentInstance, true /* direct */);\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n\\r\\n  destroy: function destroy (vnode) {\\r\\n    var componentInstance = vnode.componentInstance;\\r\\n    if (!componentInstance._isDestroyed) {\\r\\n      if (!vnode.data.keepAlive) {\\r\\n        componentInstance.$destroy();\\r\\n      } else {\\r\\n        deactivateChildComponent(componentInstance, true /* direct */);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nvar hooksToMerge = Object.keys(componentVNodeHooks);\\r\\n\\r\\nfunction createComponent (\\r\\n  Ctor,\\r\\n  data,\\r\\n  context,\\r\\n  children,\\r\\n  tag\\r\\n) {\\r\\n  if (isUndef(Ctor)) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var baseCtor = context.$options._base;\\r\\n\\r\\n  // plain options object: turn it into a constructor\\r\\n  if (isObject(Ctor)) {\\r\\n    Ctor = baseCtor.extend(Ctor);\\r\\n  }\\r\\n\\r\\n  // if at this stage it's not a constructor or an async component factory,\\r\\n  // reject.\\r\\n  if (typeof Ctor !== 'function') {\\r\\n    if (false) {}\\r\\n    return\\r\\n  }\\r\\n\\r\\n  // async component\\r\\n  var asyncFactory;\\r\\n  if (isUndef(Ctor.cid)) {\\r\\n    asyncFactory = Ctor;\\r\\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\\r\\n    if (Ctor === undefined) {\\r\\n      // return a placeholder node for async component, which is rendered\\r\\n      // as a comment node but preserves all the raw information for the node.\\r\\n      // the information will be used for async server-rendering and hydration.\\r\\n      return createAsyncPlaceholder(\\r\\n        asyncFactory,\\r\\n        data,\\r\\n        context,\\r\\n        children,\\r\\n        tag\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  data = data || {};\\r\\n\\r\\n  // resolve constructor options in case global mixins are applied after\\r\\n  // component constructor creation\\r\\n  resolveConstructorOptions(Ctor);\\r\\n\\r\\n  // transform component v-model data into props & events\\r\\n  if (isDef(data.model)) {\\r\\n    transformModel(Ctor.options, data);\\r\\n  }\\r\\n\\r\\n  // extract props\\r\\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\\r\\n\\r\\n  // functional component\\r\\n  if (isTrue(Ctor.options.functional)) {\\r\\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\\r\\n  }\\r\\n\\r\\n  // extract listeners, since these needs to be treated as\\r\\n  // child component listeners instead of DOM listeners\\r\\n  var listeners = data.on;\\r\\n  // replace with listeners with .native modifier\\r\\n  // so it gets processed during parent component patch.\\r\\n  data.on = data.nativeOn;\\r\\n\\r\\n  if (isTrue(Ctor.options.abstract)) {\\r\\n    // abstract components do not keep anything\\r\\n    // other than props & listeners & slot\\r\\n\\r\\n    // work around flow\\r\\n    var slot = data.slot;\\r\\n    data = {};\\r\\n    if (slot) {\\r\\n      data.slot = slot;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // install component management hooks onto the placeholder node\\r\\n  installComponentHooks(data);\\r\\n\\r\\n  // return a placeholder vnode\\r\\n  var name = Ctor.options.name || tag;\\r\\n  var vnode = new VNode(\\r\\n    (\\\"vue-component-\\\" + (Ctor.cid) + (name ? (\\\"-\\\" + name) : '')),\\r\\n    data, undefined, undefined, undefined, context,\\r\\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\\r\\n    asyncFactory\\r\\n  );\\r\\n\\r\\n  return vnode\\r\\n}\\r\\n\\r\\nfunction createComponentInstanceForVnode (\\r\\n  vnode, // we know it's MountedComponentVNode but flow doesn't\\r\\n  parent // activeInstance in lifecycle state\\r\\n) {\\r\\n  var options = {\\r\\n    _isComponent: true,\\r\\n    _parentVnode: vnode,\\r\\n    parent: parent\\r\\n  };\\r\\n  // check inline-template render functions\\r\\n  var inlineTemplate = vnode.data.inlineTemplate;\\r\\n  if (isDef(inlineTemplate)) {\\r\\n    options.render = inlineTemplate.render;\\r\\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\\r\\n  }\\r\\n  return new vnode.componentOptions.Ctor(options)\\r\\n}\\r\\n\\r\\nfunction installComponentHooks (data) {\\r\\n  var hooks = data.hook || (data.hook = {});\\r\\n  for (var i = 0; i < hooksToMerge.length; i++) {\\r\\n    var key = hooksToMerge[i];\\r\\n    var existing = hooks[key];\\r\\n    var toMerge = componentVNodeHooks[key];\\r\\n    if (existing !== toMerge && !(existing && existing._merged)) {\\r\\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction mergeHook$1 (f1, f2) {\\r\\n  var merged = function (a, b) {\\r\\n    // flow complains about extra args which is why we use any\\r\\n    f1(a, b);\\r\\n    f2(a, b);\\r\\n  };\\r\\n  merged._merged = true;\\r\\n  return merged\\r\\n}\\r\\n\\r\\n// transform component v-model info (value and callback) into\\r\\n// prop and event handler respectively.\\r\\nfunction transformModel (options, data) {\\r\\n  var prop = (options.model && options.model.prop) || 'value';\\r\\n  var event = (options.model && options.model.event) || 'input'\\r\\n  ;(data.props || (data.props = {}))[prop] = data.model.value;\\r\\n  var on = data.on || (data.on = {});\\r\\n  var existing = on[event];\\r\\n  var callback = data.model.callback;\\r\\n  if (isDef(existing)) {\\r\\n    if (\\r\\n      Array.isArray(existing)\\r\\n        ? existing.indexOf(callback) === -1\\r\\n        : existing !== callback\\r\\n    ) {\\r\\n      on[event] = [callback].concat(existing);\\r\\n    }\\r\\n  } else {\\r\\n    on[event] = callback;\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar SIMPLE_NORMALIZE = 1;\\r\\nvar ALWAYS_NORMALIZE = 2;\\r\\n\\r\\n// wrapper function for providing a more flexible interface\\r\\n// without getting yelled at by flow\\r\\nfunction createElement (\\r\\n  context,\\r\\n  tag,\\r\\n  data,\\r\\n  children,\\r\\n  normalizationType,\\r\\n  alwaysNormalize\\r\\n) {\\r\\n  if (Array.isArray(data) || isPrimitive(data)) {\\r\\n    normalizationType = children;\\r\\n    children = data;\\r\\n    data = undefined;\\r\\n  }\\r\\n  if (isTrue(alwaysNormalize)) {\\r\\n    normalizationType = ALWAYS_NORMALIZE;\\r\\n  }\\r\\n  return _createElement(context, tag, data, children, normalizationType)\\r\\n}\\r\\n\\r\\nfunction _createElement (\\r\\n  context,\\r\\n  tag,\\r\\n  data,\\r\\n  children,\\r\\n  normalizationType\\r\\n) {\\r\\n  if (isDef(data) && isDef((data).__ob__)) {\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      \\\"Avoid using observed data object as vnode data: \\\" + (JSON.stringify(data)) + \\\"\\\\n\\\" +\\r\\n      'Always create fresh vnode data objects in each render!',\\r\\n      context\\r\\n    );\\r\\n    return createEmptyVNode()\\r\\n  }\\r\\n  // object syntax in v-bind\\r\\n  if (isDef(data) && isDef(data.is)) {\\r\\n    tag = data.is;\\r\\n  }\\r\\n  if (!tag) {\\r\\n    // in case of component :is set to falsy value\\r\\n    return createEmptyVNode()\\r\\n  }\\r\\n  // warn against non-primitive key\\r\\n  if (false\\r\\n  ) {}\\r\\n  // support single function children as default scoped slot\\r\\n  if (Array.isArray(children) &&\\r\\n    typeof children[0] === 'function'\\r\\n  ) {\\r\\n    data = data || {};\\r\\n    data.scopedSlots = { default: children[0] };\\r\\n    children.length = 0;\\r\\n  }\\r\\n  if (normalizationType === ALWAYS_NORMALIZE) {\\r\\n    children = normalizeChildren(children);\\r\\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\\r\\n    children = simpleNormalizeChildren(children);\\r\\n  }\\r\\n  var vnode, ns;\\r\\n  if (typeof tag === 'string') {\\r\\n    var Ctor;\\r\\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\\r\\n    if (config.isReservedTag(tag)) {\\r\\n      // platform built-in elements\\r\\n      vnode = new VNode(\\r\\n        config.parsePlatformTagName(tag), data, children,\\r\\n        undefined, undefined, context\\r\\n      );\\r\\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\\r\\n      // component\\r\\n      vnode = createComponent(Ctor, data, context, children, tag);\\r\\n    } else {\\r\\n      // unknown or unlisted namespaced elements\\r\\n      // check at runtime because it may get assigned a namespace when its\\r\\n      // parent normalizes children\\r\\n      vnode = new VNode(\\r\\n        tag, data, children,\\r\\n        undefined, undefined, context\\r\\n      );\\r\\n    }\\r\\n  } else {\\r\\n    // direct component options / constructor\\r\\n    vnode = createComponent(tag, data, context, children);\\r\\n  }\\r\\n  if (Array.isArray(vnode)) {\\r\\n    return vnode\\r\\n  } else if (isDef(vnode)) {\\r\\n    if (isDef(ns)) { applyNS(vnode, ns); }\\r\\n    if (isDef(data)) { registerDeepBindings(data); }\\r\\n    return vnode\\r\\n  } else {\\r\\n    return createEmptyVNode()\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction applyNS (vnode, ns, force) {\\r\\n  vnode.ns = ns;\\r\\n  if (vnode.tag === 'foreignObject') {\\r\\n    // use default namespace inside foreignObject\\r\\n    ns = undefined;\\r\\n    force = true;\\r\\n  }\\r\\n  if (isDef(vnode.children)) {\\r\\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\\r\\n      var child = vnode.children[i];\\r\\n      if (isDef(child.tag) && (\\r\\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\\r\\n        applyNS(child, ns, force);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// ref #5318\\r\\n// necessary to ensure parent re-render when deep bindings like :style and\\r\\n// :class are used on slot nodes\\r\\nfunction registerDeepBindings (data) {\\r\\n  if (isObject(data.style)) {\\r\\n    traverse(data.style);\\r\\n  }\\r\\n  if (isObject(data.class)) {\\r\\n    traverse(data.class);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initRender (vm) {\\r\\n  vm._vnode = null; // the root of the child tree\\r\\n  vm._staticTrees = null; // v-once cached trees\\r\\n  var options = vm.$options;\\r\\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\\r\\n  var renderContext = parentVnode && parentVnode.context;\\r\\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\\r\\n  vm.$scopedSlots = emptyObject;\\r\\n  // bind the createElement fn to this instance\\r\\n  // so that we get proper render context inside it.\\r\\n  // args order: tag, data, children, normalizationType, alwaysNormalize\\r\\n  // internal version is used by render functions compiled from templates\\r\\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\\r\\n  // normalization is always applied for the public version, used in\\r\\n  // user-written render functions.\\r\\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\\r\\n\\r\\n  // $attrs & $listeners are exposed for easier HOC creation.\\r\\n  // they need to be reactive so that HOCs using them are always updated\\r\\n  var parentData = parentVnode && parentVnode.data;\\r\\n\\r\\n  /* istanbul ignore else */\\r\\n  if (false) {} else {\\r\\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\\r\\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction renderMixin (Vue) {\\r\\n  // install runtime convenience helpers\\r\\n  installRenderHelpers(Vue.prototype);\\r\\n\\r\\n  Vue.prototype.$nextTick = function (fn) {\\r\\n    return nextTick(fn, this)\\r\\n  };\\r\\n\\r\\n  Vue.prototype._render = function () {\\r\\n    var vm = this;\\r\\n    var ref = vm.$options;\\r\\n    var render = ref.render;\\r\\n    var _parentVnode = ref._parentVnode;\\r\\n\\r\\n    if (_parentVnode) {\\r\\n      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\\r\\n    }\\r\\n\\r\\n    // set parent vnode. this allows render functions to have access\\r\\n    // to the data on the placeholder node.\\r\\n    vm.$vnode = _parentVnode;\\r\\n    // render self\\r\\n    var vnode;\\r\\n    try {\\r\\n      vnode = render.call(vm._renderProxy, vm.$createElement);\\r\\n    } catch (e) {\\r\\n      handleError(e, vm, \\\"render\\\");\\r\\n      // return error render result,\\r\\n      // or previous vnode to prevent render error causing blank component\\r\\n      /* istanbul ignore else */\\r\\n      if (false) {} else {\\r\\n        vnode = vm._vnode;\\r\\n      }\\r\\n    }\\r\\n    // return empty vnode in case the render function errored out\\r\\n    if (!(vnode instanceof VNode)) {\\r\\n      if (false) {}\\r\\n      vnode = createEmptyVNode();\\r\\n    }\\r\\n    // set parent\\r\\n    vnode.parent = _parentVnode;\\r\\n    return vnode\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar uid$3 = 0;\\r\\n\\r\\nfunction initMixin (Vue) {\\r\\n  Vue.prototype._init = function (options) {\\r\\n    var vm = this;\\r\\n    // a uid\\r\\n    vm._uid = uid$3++;\\r\\n\\r\\n    var startTag, endTag;\\r\\n    /* istanbul ignore if */\\r\\n    if (false) {}\\r\\n\\r\\n    // a flag to avoid this being observed\\r\\n    vm._isVue = true;\\r\\n    // merge options\\r\\n    if (options && options._isComponent) {\\r\\n      // optimize internal component instantiation\\r\\n      // since dynamic options merging is pretty slow, and none of the\\r\\n      // internal component options needs special treatment.\\r\\n      initInternalComponent(vm, options);\\r\\n    } else {\\r\\n      vm.$options = mergeOptions(\\r\\n        resolveConstructorOptions(vm.constructor),\\r\\n        options || {},\\r\\n        vm\\r\\n      );\\r\\n    }\\r\\n    /* istanbul ignore else */\\r\\n    if (false) {} else {\\r\\n      vm._renderProxy = vm;\\r\\n    }\\r\\n    // expose real self\\r\\n    vm._self = vm;\\r\\n    initLifecycle(vm);\\r\\n    initEvents(vm);\\r\\n    initRender(vm);\\r\\n    callHook(vm, 'beforeCreate');\\r\\n    initInjections(vm); // resolve injections before data/props\\r\\n    initState(vm);\\r\\n    initProvide(vm); // resolve provide after data/props\\r\\n    callHook(vm, 'created');\\r\\n\\r\\n    /* istanbul ignore if */\\r\\n    if (false) {}\\r\\n\\r\\n    if (vm.$options.el) {\\r\\n      vm.$mount(vm.$options.el);\\r\\n    }\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction initInternalComponent (vm, options) {\\r\\n  var opts = vm.$options = Object.create(vm.constructor.options);\\r\\n  // doing this because it's faster than dynamic enumeration.\\r\\n  var parentVnode = options._parentVnode;\\r\\n  opts.parent = options.parent;\\r\\n  opts._parentVnode = parentVnode;\\r\\n\\r\\n  var vnodeComponentOptions = parentVnode.componentOptions;\\r\\n  opts.propsData = vnodeComponentOptions.propsData;\\r\\n  opts._parentListeners = vnodeComponentOptions.listeners;\\r\\n  opts._renderChildren = vnodeComponentOptions.children;\\r\\n  opts._componentTag = vnodeComponentOptions.tag;\\r\\n\\r\\n  if (options.render) {\\r\\n    opts.render = options.render;\\r\\n    opts.staticRenderFns = options.staticRenderFns;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction resolveConstructorOptions (Ctor) {\\r\\n  var options = Ctor.options;\\r\\n  if (Ctor.super) {\\r\\n    var superOptions = resolveConstructorOptions(Ctor.super);\\r\\n    var cachedSuperOptions = Ctor.superOptions;\\r\\n    if (superOptions !== cachedSuperOptions) {\\r\\n      // super option changed,\\r\\n      // need to resolve new options.\\r\\n      Ctor.superOptions = superOptions;\\r\\n      // check if there are any late-modified/attached options (#4976)\\r\\n      var modifiedOptions = resolveModifiedOptions(Ctor);\\r\\n      // update base extend options\\r\\n      if (modifiedOptions) {\\r\\n        extend(Ctor.extendOptions, modifiedOptions);\\r\\n      }\\r\\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\\r\\n      if (options.name) {\\r\\n        options.components[options.name] = Ctor;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  return options\\r\\n}\\r\\n\\r\\nfunction resolveModifiedOptions (Ctor) {\\r\\n  var modified;\\r\\n  var latest = Ctor.options;\\r\\n  var extended = Ctor.extendOptions;\\r\\n  var sealed = Ctor.sealedOptions;\\r\\n  for (var key in latest) {\\r\\n    if (latest[key] !== sealed[key]) {\\r\\n      if (!modified) { modified = {}; }\\r\\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\\r\\n    }\\r\\n  }\\r\\n  return modified\\r\\n}\\r\\n\\r\\nfunction dedupe (latest, extended, sealed) {\\r\\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\\r\\n  // between merges\\r\\n  if (Array.isArray(latest)) {\\r\\n    var res = [];\\r\\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\\r\\n    extended = Array.isArray(extended) ? extended : [extended];\\r\\n    for (var i = 0; i < latest.length; i++) {\\r\\n      // push original options and not sealed options to exclude duplicated options\\r\\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\\r\\n        res.push(latest[i]);\\r\\n      }\\r\\n    }\\r\\n    return res\\r\\n  } else {\\r\\n    return latest\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction Vue (options) {\\r\\n  if (false\\r\\n  ) {}\\r\\n  this._init(options);\\r\\n}\\r\\n\\r\\ninitMixin(Vue);\\r\\nstateMixin(Vue);\\r\\neventsMixin(Vue);\\r\\nlifecycleMixin(Vue);\\r\\nrenderMixin(Vue);\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initUse (Vue) {\\r\\n  Vue.use = function (plugin) {\\r\\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\\r\\n    if (installedPlugins.indexOf(plugin) > -1) {\\r\\n      return this\\r\\n    }\\r\\n\\r\\n    // additional parameters\\r\\n    var args = toArray(arguments, 1);\\r\\n    args.unshift(this);\\r\\n    if (typeof plugin.install === 'function') {\\r\\n      plugin.install.apply(plugin, args);\\r\\n    } else if (typeof plugin === 'function') {\\r\\n      plugin.apply(null, args);\\r\\n    }\\r\\n    installedPlugins.push(plugin);\\r\\n    return this\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initMixin$1 (Vue) {\\r\\n  Vue.mixin = function (mixin) {\\r\\n    this.options = mergeOptions(this.options, mixin);\\r\\n    return this\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initExtend (Vue) {\\r\\n  /**\\r\\n   * Each instance constructor, including Vue, has a unique\\r\\n   * cid. This enables us to create wrapped \\\"child\\r\\n   * constructors\\\" for prototypal inheritance and cache them.\\r\\n   */\\r\\n  Vue.cid = 0;\\r\\n  var cid = 1;\\r\\n\\r\\n  /**\\r\\n   * Class inheritance\\r\\n   */\\r\\n  Vue.extend = function (extendOptions) {\\r\\n    extendOptions = extendOptions || {};\\r\\n    var Super = this;\\r\\n    var SuperId = Super.cid;\\r\\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\\r\\n    if (cachedCtors[SuperId]) {\\r\\n      return cachedCtors[SuperId]\\r\\n    }\\r\\n\\r\\n    var name = extendOptions.name || Super.options.name;\\r\\n    if (false) {}\\r\\n\\r\\n    var Sub = function VueComponent (options) {\\r\\n      this._init(options);\\r\\n    };\\r\\n    Sub.prototype = Object.create(Super.prototype);\\r\\n    Sub.prototype.constructor = Sub;\\r\\n    Sub.cid = cid++;\\r\\n    Sub.options = mergeOptions(\\r\\n      Super.options,\\r\\n      extendOptions\\r\\n    );\\r\\n    Sub['super'] = Super;\\r\\n\\r\\n    // For props and computed properties, we define the proxy getters on\\r\\n    // the Vue instances at extension time, on the extended prototype. This\\r\\n    // avoids Object.defineProperty calls for each instance created.\\r\\n    if (Sub.options.props) {\\r\\n      initProps$1(Sub);\\r\\n    }\\r\\n    if (Sub.options.computed) {\\r\\n      initComputed$1(Sub);\\r\\n    }\\r\\n\\r\\n    // allow further extension/mixin/plugin usage\\r\\n    Sub.extend = Super.extend;\\r\\n    Sub.mixin = Super.mixin;\\r\\n    Sub.use = Super.use;\\r\\n\\r\\n    // create asset registers, so extended classes\\r\\n    // can have their private assets too.\\r\\n    ASSET_TYPES.forEach(function (type) {\\r\\n      Sub[type] = Super[type];\\r\\n    });\\r\\n    // enable recursive self-lookup\\r\\n    if (name) {\\r\\n      Sub.options.components[name] = Sub;\\r\\n    }\\r\\n\\r\\n    // keep a reference to the super options at extension time.\\r\\n    // later at instantiation we can check if Super's options have\\r\\n    // been updated.\\r\\n    Sub.superOptions = Super.options;\\r\\n    Sub.extendOptions = extendOptions;\\r\\n    Sub.sealedOptions = extend({}, Sub.options);\\r\\n\\r\\n    // cache constructor\\r\\n    cachedCtors[SuperId] = Sub;\\r\\n    return Sub\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction initProps$1 (Comp) {\\r\\n  var props = Comp.options.props;\\r\\n  for (var key in props) {\\r\\n    proxy(Comp.prototype, \\\"_props\\\", key);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction initComputed$1 (Comp) {\\r\\n  var computed = Comp.options.computed;\\r\\n  for (var key in computed) {\\r\\n    defineComputed(Comp.prototype, key, computed[key]);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initAssetRegisters (Vue) {\\r\\n  /**\\r\\n   * Create asset registration methods.\\r\\n   */\\r\\n  ASSET_TYPES.forEach(function (type) {\\r\\n    Vue[type] = function (\\r\\n      id,\\r\\n      definition\\r\\n    ) {\\r\\n      if (!definition) {\\r\\n        return this.options[type + 's'][id]\\r\\n      } else {\\r\\n        /* istanbul ignore if */\\r\\n        if (false) {}\\r\\n        if (type === 'component' && isPlainObject(definition)) {\\r\\n          definition.name = definition.name || id;\\r\\n          definition = this.options._base.extend(definition);\\r\\n        }\\r\\n        if (type === 'directive' && typeof definition === 'function') {\\r\\n          definition = { bind: definition, update: definition };\\r\\n        }\\r\\n        this.options[type + 's'][id] = definition;\\r\\n        return definition\\r\\n      }\\r\\n    };\\r\\n  });\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nfunction getComponentName (opts) {\\r\\n  return opts && (opts.Ctor.options.name || opts.tag)\\r\\n}\\r\\n\\r\\nfunction matches (pattern, name) {\\r\\n  if (Array.isArray(pattern)) {\\r\\n    return pattern.indexOf(name) > -1\\r\\n  } else if (typeof pattern === 'string') {\\r\\n    return pattern.split(',').indexOf(name) > -1\\r\\n  } else if (isRegExp(pattern)) {\\r\\n    return pattern.test(name)\\r\\n  }\\r\\n  /* istanbul ignore next */\\r\\n  return false\\r\\n}\\r\\n\\r\\nfunction pruneCache (keepAliveInstance, filter) {\\r\\n  var cache = keepAliveInstance.cache;\\r\\n  var keys = keepAliveInstance.keys;\\r\\n  var _vnode = keepAliveInstance._vnode;\\r\\n  for (var key in cache) {\\r\\n    var cachedNode = cache[key];\\r\\n    if (cachedNode) {\\r\\n      var name = getComponentName(cachedNode.componentOptions);\\r\\n      if (name && !filter(name)) {\\r\\n        pruneCacheEntry(cache, key, keys, _vnode);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction pruneCacheEntry (\\r\\n  cache,\\r\\n  key,\\r\\n  keys,\\r\\n  current\\r\\n) {\\r\\n  var cached$$1 = cache[key];\\r\\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\\r\\n    cached$$1.componentInstance.$destroy();\\r\\n  }\\r\\n  cache[key] = null;\\r\\n  remove(keys, key);\\r\\n}\\r\\n\\r\\nvar patternTypes = [String, RegExp, Array];\\r\\n\\r\\nvar KeepAlive = {\\r\\n  name: 'keep-alive',\\r\\n  abstract: true,\\r\\n\\r\\n  props: {\\r\\n    include: patternTypes,\\r\\n    exclude: patternTypes,\\r\\n    max: [String, Number]\\r\\n  },\\r\\n\\r\\n  created: function created () {\\r\\n    this.cache = Object.create(null);\\r\\n    this.keys = [];\\r\\n  },\\r\\n\\r\\n  destroyed: function destroyed () {\\r\\n    for (var key in this.cache) {\\r\\n      pruneCacheEntry(this.cache, key, this.keys);\\r\\n    }\\r\\n  },\\r\\n\\r\\n  mounted: function mounted () {\\r\\n    var this$1 = this;\\r\\n\\r\\n    this.$watch('include', function (val) {\\r\\n      pruneCache(this$1, function (name) { return matches(val, name); });\\r\\n    });\\r\\n    this.$watch('exclude', function (val) {\\r\\n      pruneCache(this$1, function (name) { return !matches(val, name); });\\r\\n    });\\r\\n  },\\r\\n\\r\\n  render: function render () {\\r\\n    var slot = this.$slots.default;\\r\\n    var vnode = getFirstComponentChild(slot);\\r\\n    var componentOptions = vnode && vnode.componentOptions;\\r\\n    if (componentOptions) {\\r\\n      // check pattern\\r\\n      var name = getComponentName(componentOptions);\\r\\n      var ref = this;\\r\\n      var include = ref.include;\\r\\n      var exclude = ref.exclude;\\r\\n      if (\\r\\n        // not included\\r\\n        (include && (!name || !matches(include, name))) ||\\r\\n        // excluded\\r\\n        (exclude && name && matches(exclude, name))\\r\\n      ) {\\r\\n        return vnode\\r\\n      }\\r\\n\\r\\n      var ref$1 = this;\\r\\n      var cache = ref$1.cache;\\r\\n      var keys = ref$1.keys;\\r\\n      var key = vnode.key == null\\r\\n        // same constructor may get registered as different local components\\r\\n        // so cid alone is not enough (#3269)\\r\\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\\\"::\\\" + (componentOptions.tag)) : '')\\r\\n        : vnode.key;\\r\\n      if (cache[key]) {\\r\\n        vnode.componentInstance = cache[key].componentInstance;\\r\\n        // make current key freshest\\r\\n        remove(keys, key);\\r\\n        keys.push(key);\\r\\n      } else {\\r\\n        cache[key] = vnode;\\r\\n        keys.push(key);\\r\\n        // prune oldest entry\\r\\n        if (this.max && keys.length > parseInt(this.max)) {\\r\\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      vnode.data.keepAlive = true;\\r\\n    }\\r\\n    return vnode || (slot && slot[0])\\r\\n  }\\r\\n};\\r\\n\\r\\nvar builtInComponents = {\\r\\n  KeepAlive: KeepAlive\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction initGlobalAPI (Vue) {\\r\\n  // config\\r\\n  var configDef = {};\\r\\n  configDef.get = function () { return config; };\\r\\n  if (false) {}\\r\\n  Object.defineProperty(Vue, 'config', configDef);\\r\\n\\r\\n  // exposed util methods.\\r\\n  // NOTE: these are not considered part of the public API - avoid relying on\\r\\n  // them unless you are aware of the risk.\\r\\n  Vue.util = {\\r\\n    warn: warn,\\r\\n    extend: extend,\\r\\n    mergeOptions: mergeOptions,\\r\\n    defineReactive: defineReactive$$1\\r\\n  };\\r\\n\\r\\n  Vue.set = set;\\r\\n  Vue.delete = del;\\r\\n  Vue.nextTick = nextTick;\\r\\n\\r\\n  Vue.options = Object.create(null);\\r\\n  ASSET_TYPES.forEach(function (type) {\\r\\n    Vue.options[type + 's'] = Object.create(null);\\r\\n  });\\r\\n\\r\\n  // this is used to identify the \\\"base\\\" constructor to extend all plain-object\\r\\n  // components with in Weex's multi-instance scenarios.\\r\\n  Vue.options._base = Vue;\\r\\n\\r\\n  extend(Vue.options.components, builtInComponents);\\r\\n\\r\\n  initUse(Vue);\\r\\n  initMixin$1(Vue);\\r\\n  initExtend(Vue);\\r\\n  initAssetRegisters(Vue);\\r\\n}\\r\\n\\r\\ninitGlobalAPI(Vue);\\r\\n\\r\\nObject.defineProperty(Vue.prototype, '$isServer', {\\r\\n  get: isServerRendering\\r\\n});\\r\\n\\r\\nObject.defineProperty(Vue.prototype, '$ssrContext', {\\r\\n  get: function get () {\\r\\n    /* istanbul ignore next */\\r\\n    return this.$vnode && this.$vnode.ssrContext\\r\\n  }\\r\\n});\\r\\n\\r\\n// expose FunctionalRenderContext for ssr runtime helper installation\\r\\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\\r\\n  value: FunctionalRenderContext\\r\\n});\\r\\n\\r\\nVue.version = '2.5.18';\\r\\n\\r\\n/*  */\\r\\n\\r\\n// these are reserved for web because they are directly compiled away\\r\\n// during template compilation\\r\\nvar isReservedAttr = makeMap('style,class');\\r\\n\\r\\n// attributes that should be using props for binding\\r\\nvar acceptValue = makeMap('input,textarea,option,select,progress');\\r\\nvar mustUseProp = function (tag, type, attr) {\\r\\n  return (\\r\\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\\r\\n    (attr === 'selected' && tag === 'option') ||\\r\\n    (attr === 'checked' && tag === 'input') ||\\r\\n    (attr === 'muted' && tag === 'video')\\r\\n  )\\r\\n};\\r\\n\\r\\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\\r\\n\\r\\nvar isBooleanAttr = makeMap(\\r\\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\\r\\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\\r\\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\\r\\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\\r\\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\\r\\n  'truespeed,typemustmatch,visible'\\r\\n);\\r\\n\\r\\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\\r\\n\\r\\nvar isXlink = function (name) {\\r\\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\\r\\n};\\r\\n\\r\\nvar getXlinkProp = function (name) {\\r\\n  return isXlink(name) ? name.slice(6, name.length) : ''\\r\\n};\\r\\n\\r\\nvar isFalsyAttrValue = function (val) {\\r\\n  return val == null || val === false\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction genClassForVnode (vnode) {\\r\\n  var data = vnode.data;\\r\\n  var parentNode = vnode;\\r\\n  var childNode = vnode;\\r\\n  while (isDef(childNode.componentInstance)) {\\r\\n    childNode = childNode.componentInstance._vnode;\\r\\n    if (childNode && childNode.data) {\\r\\n      data = mergeClassData(childNode.data, data);\\r\\n    }\\r\\n  }\\r\\n  while (isDef(parentNode = parentNode.parent)) {\\r\\n    if (parentNode && parentNode.data) {\\r\\n      data = mergeClassData(data, parentNode.data);\\r\\n    }\\r\\n  }\\r\\n  return renderClass(data.staticClass, data.class)\\r\\n}\\r\\n\\r\\nfunction mergeClassData (child, parent) {\\r\\n  return {\\r\\n    staticClass: concat(child.staticClass, parent.staticClass),\\r\\n    class: isDef(child.class)\\r\\n      ? [child.class, parent.class]\\r\\n      : parent.class\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction renderClass (\\r\\n  staticClass,\\r\\n  dynamicClass\\r\\n) {\\r\\n  if (isDef(staticClass) || isDef(dynamicClass)) {\\r\\n    return concat(staticClass, stringifyClass(dynamicClass))\\r\\n  }\\r\\n  /* istanbul ignore next */\\r\\n  return ''\\r\\n}\\r\\n\\r\\nfunction concat (a, b) {\\r\\n  return a ? b ? (a + ' ' + b) : a : (b || '')\\r\\n}\\r\\n\\r\\nfunction stringifyClass (value) {\\r\\n  if (Array.isArray(value)) {\\r\\n    return stringifyArray(value)\\r\\n  }\\r\\n  if (isObject(value)) {\\r\\n    return stringifyObject(value)\\r\\n  }\\r\\n  if (typeof value === 'string') {\\r\\n    return value\\r\\n  }\\r\\n  /* istanbul ignore next */\\r\\n  return ''\\r\\n}\\r\\n\\r\\nfunction stringifyArray (value) {\\r\\n  var res = '';\\r\\n  var stringified;\\r\\n  for (var i = 0, l = value.length; i < l; i++) {\\r\\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\\r\\n      if (res) { res += ' '; }\\r\\n      res += stringified;\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction stringifyObject (value) {\\r\\n  var res = '';\\r\\n  for (var key in value) {\\r\\n    if (value[key]) {\\r\\n      if (res) { res += ' '; }\\r\\n      res += key;\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar namespaceMap = {\\r\\n  svg: 'http://www.w3.org/2000/svg',\\r\\n  math: 'http://www.w3.org/1998/Math/MathML'\\r\\n};\\r\\n\\r\\nvar isHTMLTag = makeMap(\\r\\n  'html,body,base,head,link,meta,style,title,' +\\r\\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\\r\\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\\r\\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\\r\\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\\r\\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\\r\\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\\r\\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\\r\\n  'output,progress,select,textarea,' +\\r\\n  'details,dialog,menu,menuitem,summary,' +\\r\\n  'content,element,shadow,template,blockquote,iframe,tfoot'\\r\\n);\\r\\n\\r\\n// this map is intentionally selective, only covering SVG elements that may\\r\\n// contain child elements.\\r\\nvar isSVG = makeMap(\\r\\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\\r\\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\\r\\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\\r\\n  true\\r\\n);\\r\\n\\r\\nvar isPreTag = function (tag) { return tag === 'pre'; };\\r\\n\\r\\nvar isReservedTag = function (tag) {\\r\\n  return isHTMLTag(tag) || isSVG(tag)\\r\\n};\\r\\n\\r\\nfunction getTagNamespace (tag) {\\r\\n  if (isSVG(tag)) {\\r\\n    return 'svg'\\r\\n  }\\r\\n  // basic support for MathML\\r\\n  // note it doesn't support other MathML elements being component roots\\r\\n  if (tag === 'math') {\\r\\n    return 'math'\\r\\n  }\\r\\n}\\r\\n\\r\\nvar unknownElementCache = Object.create(null);\\r\\nfunction isUnknownElement (tag) {\\r\\n  /* istanbul ignore if */\\r\\n  if (!inBrowser) {\\r\\n    return true\\r\\n  }\\r\\n  if (isReservedTag(tag)) {\\r\\n    return false\\r\\n  }\\r\\n  tag = tag.toLowerCase();\\r\\n  /* istanbul ignore if */\\r\\n  if (unknownElementCache[tag] != null) {\\r\\n    return unknownElementCache[tag]\\r\\n  }\\r\\n  var el = document.createElement(tag);\\r\\n  if (tag.indexOf('-') > -1) {\\r\\n    // http://stackoverflow.com/a/28210364/1070244\\r\\n    return (unknownElementCache[tag] = (\\r\\n      el.constructor === window.HTMLUnknownElement ||\\r\\n      el.constructor === window.HTMLElement\\r\\n    ))\\r\\n  } else {\\r\\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\\r\\n  }\\r\\n}\\r\\n\\r\\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Query an element selector if it's not an element already.\\r\\n */\\r\\nfunction query (el) {\\r\\n  if (typeof el === 'string') {\\r\\n    var selected = document.querySelector(el);\\r\\n    if (!selected) {\\r\\n      \\\"production\\\" !== 'production' && warn(\\r\\n        'Cannot find element: ' + el\\r\\n      );\\r\\n      return document.createElement('div')\\r\\n    }\\r\\n    return selected\\r\\n  } else {\\r\\n    return el\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction createElement$1 (tagName, vnode) {\\r\\n  var elm = document.createElement(tagName);\\r\\n  if (tagName !== 'select') {\\r\\n    return elm\\r\\n  }\\r\\n  // false or null will remove the attribute but undefined will not\\r\\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\\r\\n    elm.setAttribute('multiple', 'multiple');\\r\\n  }\\r\\n  return elm\\r\\n}\\r\\n\\r\\nfunction createElementNS (namespace, tagName) {\\r\\n  return document.createElementNS(namespaceMap[namespace], tagName)\\r\\n}\\r\\n\\r\\nfunction createTextNode (text) {\\r\\n  return document.createTextNode(text)\\r\\n}\\r\\n\\r\\nfunction createComment (text) {\\r\\n  return document.createComment(text)\\r\\n}\\r\\n\\r\\nfunction insertBefore (parentNode, newNode, referenceNode) {\\r\\n  parentNode.insertBefore(newNode, referenceNode);\\r\\n}\\r\\n\\r\\nfunction removeChild (node, child) {\\r\\n  node.removeChild(child);\\r\\n}\\r\\n\\r\\nfunction appendChild (node, child) {\\r\\n  node.appendChild(child);\\r\\n}\\r\\n\\r\\nfunction parentNode (node) {\\r\\n  return node.parentNode\\r\\n}\\r\\n\\r\\nfunction nextSibling (node) {\\r\\n  return node.nextSibling\\r\\n}\\r\\n\\r\\nfunction tagName (node) {\\r\\n  return node.tagName\\r\\n}\\r\\n\\r\\nfunction setTextContent (node, text) {\\r\\n  node.textContent = text;\\r\\n}\\r\\n\\r\\nfunction setStyleScope (node, scopeId) {\\r\\n  node.setAttribute(scopeId, '');\\r\\n}\\r\\n\\r\\nvar nodeOps = /*#__PURE__*/Object.freeze({\\r\\n  createElement: createElement$1,\\r\\n  createElementNS: createElementNS,\\r\\n  createTextNode: createTextNode,\\r\\n  createComment: createComment,\\r\\n  insertBefore: insertBefore,\\r\\n  removeChild: removeChild,\\r\\n  appendChild: appendChild,\\r\\n  parentNode: parentNode,\\r\\n  nextSibling: nextSibling,\\r\\n  tagName: tagName,\\r\\n  setTextContent: setTextContent,\\r\\n  setStyleScope: setStyleScope\\r\\n});\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar ref = {\\r\\n  create: function create (_, vnode) {\\r\\n    registerRef(vnode);\\r\\n  },\\r\\n  update: function update (oldVnode, vnode) {\\r\\n    if (oldVnode.data.ref !== vnode.data.ref) {\\r\\n      registerRef(oldVnode, true);\\r\\n      registerRef(vnode);\\r\\n    }\\r\\n  },\\r\\n  destroy: function destroy (vnode) {\\r\\n    registerRef(vnode, true);\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction registerRef (vnode, isRemoval) {\\r\\n  var key = vnode.data.ref;\\r\\n  if (!isDef(key)) { return }\\r\\n\\r\\n  var vm = vnode.context;\\r\\n  var ref = vnode.componentInstance || vnode.elm;\\r\\n  var refs = vm.$refs;\\r\\n  if (isRemoval) {\\r\\n    if (Array.isArray(refs[key])) {\\r\\n      remove(refs[key], ref);\\r\\n    } else if (refs[key] === ref) {\\r\\n      refs[key] = undefined;\\r\\n    }\\r\\n  } else {\\r\\n    if (vnode.data.refInFor) {\\r\\n      if (!Array.isArray(refs[key])) {\\r\\n        refs[key] = [ref];\\r\\n      } else if (refs[key].indexOf(ref) < 0) {\\r\\n        // $flow-disable-line\\r\\n        refs[key].push(ref);\\r\\n      }\\r\\n    } else {\\r\\n      refs[key] = ref;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Virtual DOM patching algorithm based on Snabbdom by\\r\\n * Simon Friis Vindum (@paldepind)\\r\\n * Licensed under the MIT License\\r\\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\\r\\n *\\r\\n * modified by Evan You (@yyx990803)\\r\\n *\\r\\n * Not type-checking this because this file is perf-critical and the cost\\r\\n * of making flow understand it is not worth it.\\r\\n */\\r\\n\\r\\nvar emptyNode = new VNode('', {}, []);\\r\\n\\r\\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\\r\\n\\r\\nfunction childrenIgnored (vnode) {\\r\\n  return vnode && vnode.data && vnode.data.domProps && (\\r\\n    vnode.data.domProps.innerHTML || vnode.data.domProps.textContent\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction sameVnode (a, b) {\\r\\n  return (\\r\\n    a.key === b.key && (\\r\\n      (\\r\\n        a.tag === b.tag &&\\r\\n        a.isComment === b.isComment &&\\r\\n        isDef(a.data) === isDef(b.data) &&\\r\\n        !childrenIgnored(a) && !childrenIgnored(b) &&\\r\\n        sameInputType(a, b)\\r\\n      ) || (\\r\\n        isTrue(a.isAsyncPlaceholder) &&\\r\\n        a.asyncFactory === b.asyncFactory &&\\r\\n        isUndef(b.asyncFactory.error)\\r\\n      )\\r\\n    )\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction sameInputType (a, b) {\\r\\n  if (a.tag !== 'input') { return true }\\r\\n  var i;\\r\\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\\r\\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\\r\\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\\r\\n}\\r\\n\\r\\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\\r\\n  var i, key;\\r\\n  var map = {};\\r\\n  for (i = beginIdx; i <= endIdx; ++i) {\\r\\n    key = children[i].key;\\r\\n    if (isDef(key)) { map[key] = i; }\\r\\n  }\\r\\n  return map\\r\\n}\\r\\n\\r\\nfunction createPatchFunction (backend) {\\r\\n  var i, j;\\r\\n  var cbs = {};\\r\\n\\r\\n  var modules = backend.modules;\\r\\n  var nodeOps = backend.nodeOps;\\r\\n\\r\\n  for (i = 0; i < hooks.length; ++i) {\\r\\n    cbs[hooks[i]] = [];\\r\\n    for (j = 0; j < modules.length; ++j) {\\r\\n      if (isDef(modules[j][hooks[i]])) {\\r\\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function emptyNodeAt (elm) {\\r\\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\\r\\n  }\\r\\n\\r\\n  function createRmCb (childElm, listeners) {\\r\\n    function remove$$1 () {\\r\\n      if (--remove$$1.listeners === 0) {\\r\\n        removeNode(childElm);\\r\\n      }\\r\\n    }\\r\\n    remove$$1.listeners = listeners;\\r\\n    return remove$$1\\r\\n  }\\r\\n\\r\\n  function removeNode (el) {\\r\\n    var parent = nodeOps.parentNode(el);\\r\\n    // element may have already been removed due to v-html / v-text\\r\\n    if (isDef(parent)) {\\r\\n      nodeOps.removeChild(parent, el);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function isUnknownElement$$1 (vnode, inVPre) {\\r\\n    return (\\r\\n      !inVPre &&\\r\\n      !vnode.ns &&\\r\\n      !(\\r\\n        config.ignoredElements.length &&\\r\\n        config.ignoredElements.some(function (ignore) {\\r\\n          return isRegExp(ignore)\\r\\n            ? ignore.test(vnode.tag)\\r\\n            : ignore === vnode.tag\\r\\n        })\\r\\n      ) &&\\r\\n      config.isUnknownElement(vnode.tag)\\r\\n    )\\r\\n  }\\r\\n\\r\\n  var creatingElmInVPre = 0;\\r\\n\\r\\n  function createElm (\\r\\n    vnode,\\r\\n    insertedVnodeQueue,\\r\\n    parentElm,\\r\\n    refElm,\\r\\n    nested,\\r\\n    ownerArray,\\r\\n    index\\r\\n  ) {\\r\\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\\r\\n      // This vnode was used in a previous render!\\r\\n      // now it's used as a new node, overwriting its elm would cause\\r\\n      // potential patch errors down the road when it's used as an insertion\\r\\n      // reference node. Instead, we clone the node on-demand before creating\\r\\n      // associated DOM element for it.\\r\\n      vnode = ownerArray[index] = cloneVNode(vnode);\\r\\n    }\\r\\n\\r\\n    vnode.isRootInsert = !nested; // for transition enter check\\r\\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    var data = vnode.data;\\r\\n    var children = vnode.children;\\r\\n    var tag = vnode.tag;\\r\\n    if (isDef(tag)) {\\r\\n      if (false) {}\\r\\n\\r\\n      vnode.elm = vnode.ns\\r\\n        ? nodeOps.createElementNS(vnode.ns, tag)\\r\\n        : nodeOps.createElement(tag, vnode);\\r\\n      setScope(vnode);\\r\\n\\r\\n      /* istanbul ignore if */\\r\\n      {\\r\\n        createChildren(vnode, children, insertedVnodeQueue);\\r\\n        if (isDef(data)) {\\r\\n          invokeCreateHooks(vnode, insertedVnodeQueue);\\r\\n        }\\r\\n        insert(parentElm, vnode.elm, refElm);\\r\\n      }\\r\\n\\r\\n      if (false) {}\\r\\n    } else if (isTrue(vnode.isComment)) {\\r\\n      vnode.elm = nodeOps.createComment(vnode.text);\\r\\n      insert(parentElm, vnode.elm, refElm);\\r\\n    } else {\\r\\n      vnode.elm = nodeOps.createTextNode(vnode.text);\\r\\n      insert(parentElm, vnode.elm, refElm);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\r\\n    var i = vnode.data;\\r\\n    if (isDef(i)) {\\r\\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\\r\\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\\r\\n        i(vnode, false /* hydrating */);\\r\\n      }\\r\\n      // after calling the init hook, if the vnode is a child component\\r\\n      // it should've created a child instance and mounted it. the child\\r\\n      // component also has set the placeholder vnode's elm.\\r\\n      // in that case we can just return the element and be done.\\r\\n      if (isDef(vnode.componentInstance)) {\\r\\n        initComponent(vnode, insertedVnodeQueue);\\r\\n        insert(parentElm, vnode.elm, refElm);\\r\\n        if (isTrue(isReactivated)) {\\r\\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\\r\\n        }\\r\\n        return true\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function initComponent (vnode, insertedVnodeQueue) {\\r\\n    if (isDef(vnode.data.pendingInsert)) {\\r\\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\\r\\n      vnode.data.pendingInsert = null;\\r\\n    }\\r\\n    vnode.elm = vnode.componentInstance.$el;\\r\\n    if (isPatchable(vnode)) {\\r\\n      invokeCreateHooks(vnode, insertedVnodeQueue);\\r\\n      setScope(vnode);\\r\\n    } else {\\r\\n      // empty component root.\\r\\n      // skip all element-related modules except for ref (#3455)\\r\\n      registerRef(vnode);\\r\\n      // make sure to invoke the insert hook\\r\\n      insertedVnodeQueue.push(vnode);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\r\\n    var i;\\r\\n    // hack for #4339: a reactivated component with inner transition\\r\\n    // does not trigger because the inner node's created hooks are not called\\r\\n    // again. It's not ideal to involve module-specific logic in here but\\r\\n    // there doesn't seem to be a better way to do it.\\r\\n    var innerNode = vnode;\\r\\n    while (innerNode.componentInstance) {\\r\\n      innerNode = innerNode.componentInstance._vnode;\\r\\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\\r\\n        for (i = 0; i < cbs.activate.length; ++i) {\\r\\n          cbs.activate[i](emptyNode, innerNode);\\r\\n        }\\r\\n        insertedVnodeQueue.push(innerNode);\\r\\n        break\\r\\n      }\\r\\n    }\\r\\n    // unlike a newly created component,\\r\\n    // a reactivated keep-alive component doesn't insert itself\\r\\n    insert(parentElm, vnode.elm, refElm);\\r\\n  }\\r\\n\\r\\n  function insert (parent, elm, ref$$1) {\\r\\n    if (isDef(parent)) {\\r\\n      if (isDef(ref$$1)) {\\r\\n        if (nodeOps.parentNode(ref$$1) === parent) {\\r\\n          nodeOps.insertBefore(parent, elm, ref$$1);\\r\\n        }\\r\\n      } else {\\r\\n        nodeOps.appendChild(parent, elm);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function createChildren (vnode, children, insertedVnodeQueue) {\\r\\n    if (Array.isArray(children)) {\\r\\n      if (false) {}\\r\\n      for (var i = 0; i < children.length; ++i) {\\r\\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\\r\\n      }\\r\\n    } else if (isPrimitive(vnode.text)) {\\r\\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function isPatchable (vnode) {\\r\\n    while (vnode.componentInstance) {\\r\\n      vnode = vnode.componentInstance._vnode;\\r\\n    }\\r\\n    return isDef(vnode.tag)\\r\\n  }\\r\\n\\r\\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\\r\\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\\r\\n      cbs.create[i$1](emptyNode, vnode);\\r\\n    }\\r\\n    i = vnode.data.hook; // Reuse variable\\r\\n    if (isDef(i)) {\\r\\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\\r\\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // set scope id attribute for scoped CSS.\\r\\n  // this is implemented as a special case to avoid the overhead\\r\\n  // of going through the normal attribute patching process.\\r\\n  function setScope (vnode) {\\r\\n    var i;\\r\\n    if (isDef(i = vnode.fnScopeId)) {\\r\\n      nodeOps.setStyleScope(vnode.elm, i);\\r\\n    } else {\\r\\n      var ancestor = vnode;\\r\\n      while (ancestor) {\\r\\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\\r\\n          nodeOps.setStyleScope(vnode.elm, i);\\r\\n        }\\r\\n        ancestor = ancestor.parent;\\r\\n      }\\r\\n    }\\r\\n    // for slot content they should also get the scopeId from the host instance.\\r\\n    if (isDef(i = activeInstance) &&\\r\\n      i !== vnode.context &&\\r\\n      i !== vnode.fnContext &&\\r\\n      isDef(i = i.$options._scopeId)\\r\\n    ) {\\r\\n      nodeOps.setStyleScope(vnode.elm, i);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\\r\\n    for (; startIdx <= endIdx; ++startIdx) {\\r\\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function invokeDestroyHook (vnode) {\\r\\n    var i, j;\\r\\n    var data = vnode.data;\\r\\n    if (isDef(data)) {\\r\\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\\r\\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\\r\\n    }\\r\\n    if (isDef(i = vnode.children)) {\\r\\n      for (j = 0; j < vnode.children.length; ++j) {\\r\\n        invokeDestroyHook(vnode.children[j]);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\\r\\n    for (; startIdx <= endIdx; ++startIdx) {\\r\\n      var ch = vnodes[startIdx];\\r\\n      if (isDef(ch)) {\\r\\n        if (isDef(ch.tag)) {\\r\\n          removeAndInvokeRemoveHook(ch);\\r\\n          invokeDestroyHook(ch);\\r\\n        } else { // Text node\\r\\n          removeNode(ch.elm);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAndInvokeRemoveHook (vnode, rm) {\\r\\n    if (isDef(rm) || isDef(vnode.data)) {\\r\\n      var i;\\r\\n      var listeners = cbs.remove.length + 1;\\r\\n      if (isDef(rm)) {\\r\\n        // we have a recursively passed down rm callback\\r\\n        // increase the listeners count\\r\\n        rm.listeners += listeners;\\r\\n      } else {\\r\\n        // directly removing\\r\\n        rm = createRmCb(vnode.elm, listeners);\\r\\n      }\\r\\n      // recursively invoke hooks on child component root node\\r\\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\\r\\n        removeAndInvokeRemoveHook(i, rm);\\r\\n      }\\r\\n      for (i = 0; i < cbs.remove.length; ++i) {\\r\\n        cbs.remove[i](vnode, rm);\\r\\n      }\\r\\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\\r\\n        i(vnode, rm);\\r\\n      } else {\\r\\n        rm();\\r\\n      }\\r\\n    } else {\\r\\n      removeNode(vnode.elm);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\\r\\n    var oldStartIdx = 0;\\r\\n    var newStartIdx = 0;\\r\\n    var oldEndIdx = oldCh.length - 1;\\r\\n    var oldStartVnode = oldCh[0];\\r\\n    var oldEndVnode = oldCh[oldEndIdx];\\r\\n    var newEndIdx = newCh.length - 1;\\r\\n    var newStartVnode = newCh[0];\\r\\n    var newEndVnode = newCh[newEndIdx];\\r\\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\\r\\n\\r\\n    // removeOnly is a special flag used only by <transition-group>\\r\\n    // to ensure removed elements stay in correct relative positions\\r\\n    // during leaving transitions\\r\\n    var canMove = !removeOnly;\\r\\n\\r\\n    if (false) {}\\r\\n\\r\\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\r\\n      if (isUndef(oldStartVnode)) {\\r\\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\\r\\n      } else if (isUndef(oldEndVnode)) {\\r\\n        oldEndVnode = oldCh[--oldEndIdx];\\r\\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\\r\\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\\r\\n        oldStartVnode = oldCh[++oldStartIdx];\\r\\n        newStartVnode = newCh[++newStartIdx];\\r\\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\\r\\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\\r\\n        oldEndVnode = oldCh[--oldEndIdx];\\r\\n        newEndVnode = newCh[--newEndIdx];\\r\\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\\r\\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\\r\\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\\r\\n        oldStartVnode = oldCh[++oldStartIdx];\\r\\n        newEndVnode = newCh[--newEndIdx];\\r\\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\\r\\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\\r\\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\\r\\n        oldEndVnode = oldCh[--oldEndIdx];\\r\\n        newStartVnode = newCh[++newStartIdx];\\r\\n      } else {\\r\\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\\r\\n        idxInOld = isDef(newStartVnode.key)\\r\\n          ? oldKeyToIdx[newStartVnode.key]\\r\\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\\r\\n        if (isUndef(idxInOld)) { // New element\\r\\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\\r\\n        } else {\\r\\n          vnodeToMove = oldCh[idxInOld];\\r\\n          if (sameVnode(vnodeToMove, newStartVnode)) {\\r\\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\\r\\n            oldCh[idxInOld] = undefined;\\r\\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\\r\\n          } else {\\r\\n            // same key but different element. treat as new element\\r\\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\\r\\n          }\\r\\n        }\\r\\n        newStartVnode = newCh[++newStartIdx];\\r\\n      }\\r\\n    }\\r\\n    if (oldStartIdx > oldEndIdx) {\\r\\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\\r\\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\\r\\n    } else if (newStartIdx > newEndIdx) {\\r\\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function checkDuplicateKeys (children) {\\r\\n    var seenKeys = {};\\r\\n    for (var i = 0; i < children.length; i++) {\\r\\n      var vnode = children[i];\\r\\n      var key = vnode.key;\\r\\n      if (isDef(key)) {\\r\\n        if (seenKeys[key]) {\\r\\n          warn(\\r\\n            (\\\"Duplicate keys detected: '\\\" + key + \\\"'. This may cause an update error.\\\"),\\r\\n            vnode.context\\r\\n          );\\r\\n        } else {\\r\\n          seenKeys[key] = true;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function findIdxInOld (node, oldCh, start, end) {\\r\\n    for (var i = start; i < end; i++) {\\r\\n      var c = oldCh[i];\\r\\n      if (isDef(c) && sameVnode(node, c)) { return i }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function patchVnode (\\r\\n    oldVnode,\\r\\n    vnode,\\r\\n    insertedVnodeQueue,\\r\\n    ownerArray,\\r\\n    index,\\r\\n    removeOnly\\r\\n  ) {\\r\\n    if (oldVnode === vnode) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\\r\\n      // clone reused vnode\\r\\n      vnode = ownerArray[index] = cloneVNode(vnode);\\r\\n    }\\r\\n\\r\\n    var elm = vnode.elm = oldVnode.elm;\\r\\n\\r\\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\\r\\n      if (isDef(vnode.asyncFactory.resolved)) {\\r\\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\\r\\n      } else {\\r\\n        vnode.isAsyncPlaceholder = true;\\r\\n      }\\r\\n      return\\r\\n    }\\r\\n\\r\\n    // reuse element for static trees.\\r\\n    // note we only do this if the vnode is cloned -\\r\\n    // if the new node is not cloned it means the render functions have been\\r\\n    // reset by the hot-reload-api and we need to do a proper re-render.\\r\\n    if (isTrue(vnode.isStatic) &&\\r\\n      isTrue(oldVnode.isStatic) &&\\r\\n      vnode.key === oldVnode.key &&\\r\\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\\r\\n    ) {\\r\\n      vnode.componentInstance = oldVnode.componentInstance;\\r\\n      return\\r\\n    }\\r\\n\\r\\n    var i;\\r\\n    var data = vnode.data;\\r\\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\\r\\n      i(oldVnode, vnode);\\r\\n    }\\r\\n\\r\\n    var oldCh = oldVnode.children;\\r\\n    var ch = vnode.children;\\r\\n    if (isDef(data) && isPatchable(vnode)) {\\r\\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\\r\\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\\r\\n    }\\r\\n    if (isUndef(vnode.text)) {\\r\\n      if (isDef(oldCh) && isDef(ch)) {\\r\\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\\r\\n      } else if (isDef(ch)) {\\r\\n        if (false) {}\\r\\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\\r\\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\\r\\n      } else if (isDef(oldCh)) {\\r\\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\\r\\n      } else if (isDef(oldVnode.text)) {\\r\\n        nodeOps.setTextContent(elm, '');\\r\\n      }\\r\\n    } else if (oldVnode.text !== vnode.text) {\\r\\n      nodeOps.setTextContent(elm, vnode.text);\\r\\n    }\\r\\n    if (isDef(data)) {\\r\\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function invokeInsertHook (vnode, queue, initial) {\\r\\n    // delay insert hooks for component root nodes, invoke them after the\\r\\n    // element is really inserted\\r\\n    if (isTrue(initial) && isDef(vnode.parent)) {\\r\\n      vnode.parent.data.pendingInsert = queue;\\r\\n    } else {\\r\\n      for (var i = 0; i < queue.length; ++i) {\\r\\n        queue[i].data.hook.insert(queue[i]);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var hydrationBailed = false;\\r\\n  // list of modules that can skip create hook during hydration because they\\r\\n  // are already rendered on the client or has no need for initialization\\r\\n  // Note: style is excluded because it relies on initial clone for future\\r\\n  // deep updates (#7063).\\r\\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\\r\\n\\r\\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\\r\\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\\r\\n    var i;\\r\\n    var tag = vnode.tag;\\r\\n    var data = vnode.data;\\r\\n    var children = vnode.children;\\r\\n    inVPre = inVPre || (data && data.pre);\\r\\n    vnode.elm = elm;\\r\\n\\r\\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\\r\\n      vnode.isAsyncPlaceholder = true;\\r\\n      return true\\r\\n    }\\r\\n    // assert node match\\r\\n    if (false) {}\\r\\n    if (isDef(data)) {\\r\\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\\r\\n      if (isDef(i = vnode.componentInstance)) {\\r\\n        // child component. it should have hydrated its own tree.\\r\\n        initComponent(vnode, insertedVnodeQueue);\\r\\n        return true\\r\\n      }\\r\\n    }\\r\\n    if (isDef(tag)) {\\r\\n      if (isDef(children)) {\\r\\n        // empty element, allow client to pick up and populate children\\r\\n        if (!elm.hasChildNodes()) {\\r\\n          createChildren(vnode, children, insertedVnodeQueue);\\r\\n        } else {\\r\\n          // v-html and domProps: innerHTML\\r\\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\\r\\n            if (i !== elm.innerHTML) {\\r\\n              /* istanbul ignore if */\\r\\n              if (false\\r\\n              ) {}\\r\\n              return false\\r\\n            }\\r\\n          } else {\\r\\n            // iterate and compare children lists\\r\\n            var childrenMatch = true;\\r\\n            var childNode = elm.firstChild;\\r\\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\\r\\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\\r\\n                childrenMatch = false;\\r\\n                break\\r\\n              }\\r\\n              childNode = childNode.nextSibling;\\r\\n            }\\r\\n            // if childNode is not null, it means the actual childNodes list is\\r\\n            // longer than the virtual children list.\\r\\n            if (!childrenMatch || childNode) {\\r\\n              /* istanbul ignore if */\\r\\n              if (false\\r\\n              ) {}\\r\\n              return false\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      if (isDef(data)) {\\r\\n        var fullInvoke = false;\\r\\n        for (var key in data) {\\r\\n          if (!isRenderedModule(key)) {\\r\\n            fullInvoke = true;\\r\\n            invokeCreateHooks(vnode, insertedVnodeQueue);\\r\\n            break\\r\\n          }\\r\\n        }\\r\\n        if (!fullInvoke && data['class']) {\\r\\n          // ensure collecting deps for deep class bindings for future updates\\r\\n          traverse(data['class']);\\r\\n        }\\r\\n      }\\r\\n    } else if (elm.data !== vnode.text) {\\r\\n      elm.data = vnode.text;\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function assertNodeMatch (node, vnode, inVPre) {\\r\\n    if (isDef(vnode.tag)) {\\r\\n      return vnode.tag.indexOf('vue-component') === 0 || (\\r\\n        !isUnknownElement$$1(vnode, inVPre) &&\\r\\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\\r\\n      )\\r\\n    } else {\\r\\n      return node.nodeType === (vnode.isComment ? 8 : 3)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\\r\\n    if (isUndef(vnode)) {\\r\\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\\r\\n      return\\r\\n    }\\r\\n\\r\\n    var isInitialPatch = false;\\r\\n    var insertedVnodeQueue = [];\\r\\n\\r\\n    if (isUndef(oldVnode)) {\\r\\n      // empty mount (likely as component), create new root element\\r\\n      isInitialPatch = true;\\r\\n      createElm(vnode, insertedVnodeQueue);\\r\\n    } else {\\r\\n      var isRealElement = isDef(oldVnode.nodeType);\\r\\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\\r\\n        // patch existing root node\\r\\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\\r\\n      } else {\\r\\n        if (isRealElement) {\\r\\n          // mounting to a real element\\r\\n          // check if this is server-rendered content and if we can perform\\r\\n          // a successful hydration.\\r\\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\\r\\n            oldVnode.removeAttribute(SSR_ATTR);\\r\\n            hydrating = true;\\r\\n          }\\r\\n          if (isTrue(hydrating)) {\\r\\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\\r\\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\\r\\n              return oldVnode\\r\\n            } else if (false) {}\\r\\n          }\\r\\n          // either not server-rendered, or hydration failed.\\r\\n          // create an empty node and replace it\\r\\n          oldVnode = emptyNodeAt(oldVnode);\\r\\n        }\\r\\n\\r\\n        // replacing existing element\\r\\n        var oldElm = oldVnode.elm;\\r\\n        var parentElm = nodeOps.parentNode(oldElm);\\r\\n\\r\\n        // create new node\\r\\n        createElm(\\r\\n          vnode,\\r\\n          insertedVnodeQueue,\\r\\n          // extremely rare edge case: do not insert if old element is in a\\r\\n          // leaving transition. Only happens when combining transition +\\r\\n          // keep-alive + HOCs. (#4590)\\r\\n          oldElm._leaveCb ? null : parentElm,\\r\\n          nodeOps.nextSibling(oldElm)\\r\\n        );\\r\\n\\r\\n        // update parent placeholder node element, recursively\\r\\n        if (isDef(vnode.parent)) {\\r\\n          var ancestor = vnode.parent;\\r\\n          var patchable = isPatchable(vnode);\\r\\n          while (ancestor) {\\r\\n            for (var i = 0; i < cbs.destroy.length; ++i) {\\r\\n              cbs.destroy[i](ancestor);\\r\\n            }\\r\\n            ancestor.elm = vnode.elm;\\r\\n            if (patchable) {\\r\\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\\r\\n                cbs.create[i$1](emptyNode, ancestor);\\r\\n              }\\r\\n              // #6513\\r\\n              // invoke insert hooks that may have been merged by create hooks.\\r\\n              // e.g. for directives that uses the \\\"inserted\\\" hook.\\r\\n              var insert = ancestor.data.hook.insert;\\r\\n              if (insert.merged) {\\r\\n                // start at index 1 to avoid re-invoking component mounted hook\\r\\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\\r\\n                  insert.fns[i$2]();\\r\\n                }\\r\\n              }\\r\\n            } else {\\r\\n              registerRef(ancestor);\\r\\n            }\\r\\n            ancestor = ancestor.parent;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        // destroy old node\\r\\n        if (isDef(parentElm)) {\\r\\n          removeVnodes(parentElm, [oldVnode], 0, 0);\\r\\n        } else if (isDef(oldVnode.tag)) {\\r\\n          invokeDestroyHook(oldVnode);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\\r\\n    return vnode.elm\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar directives = {\\r\\n  create: updateDirectives,\\r\\n  update: updateDirectives,\\r\\n  destroy: function unbindDirectives (vnode) {\\r\\n    updateDirectives(vnode, emptyNode);\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction updateDirectives (oldVnode, vnode) {\\r\\n  if (oldVnode.data.directives || vnode.data.directives) {\\r\\n    _update(oldVnode, vnode);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction _update (oldVnode, vnode) {\\r\\n  var isCreate = oldVnode === emptyNode;\\r\\n  var isDestroy = vnode === emptyNode;\\r\\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\\r\\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\\r\\n\\r\\n  var dirsWithInsert = [];\\r\\n  var dirsWithPostpatch = [];\\r\\n\\r\\n  var key, oldDir, dir;\\r\\n  for (key in newDirs) {\\r\\n    oldDir = oldDirs[key];\\r\\n    dir = newDirs[key];\\r\\n    if (!oldDir) {\\r\\n      // new directive, bind\\r\\n      callHook$1(dir, 'bind', vnode, oldVnode);\\r\\n      if (dir.def && dir.def.inserted) {\\r\\n        dirsWithInsert.push(dir);\\r\\n      }\\r\\n    } else {\\r\\n      // existing directive, update\\r\\n      dir.oldValue = oldDir.value;\\r\\n      callHook$1(dir, 'update', vnode, oldVnode);\\r\\n      if (dir.def && dir.def.componentUpdated) {\\r\\n        dirsWithPostpatch.push(dir);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (dirsWithInsert.length) {\\r\\n    var callInsert = function () {\\r\\n      for (var i = 0; i < dirsWithInsert.length; i++) {\\r\\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\\r\\n      }\\r\\n    };\\r\\n    if (isCreate) {\\r\\n      mergeVNodeHook(vnode, 'insert', callInsert);\\r\\n    } else {\\r\\n      callInsert();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (dirsWithPostpatch.length) {\\r\\n    mergeVNodeHook(vnode, 'postpatch', function () {\\r\\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\\r\\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  if (!isCreate) {\\r\\n    for (key in oldDirs) {\\r\\n      if (!newDirs[key]) {\\r\\n        // no longer present, unbind\\r\\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar emptyModifiers = Object.create(null);\\r\\n\\r\\nfunction normalizeDirectives$1 (\\r\\n  dirs,\\r\\n  vm\\r\\n) {\\r\\n  var res = Object.create(null);\\r\\n  if (!dirs) {\\r\\n    // $flow-disable-line\\r\\n    return res\\r\\n  }\\r\\n  var i, dir;\\r\\n  for (i = 0; i < dirs.length; i++) {\\r\\n    dir = dirs[i];\\r\\n    if (!dir.modifiers) {\\r\\n      // $flow-disable-line\\r\\n      dir.modifiers = emptyModifiers;\\r\\n    }\\r\\n    res[getRawDirName(dir)] = dir;\\r\\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\\r\\n  }\\r\\n  // $flow-disable-line\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction getRawDirName (dir) {\\r\\n  return dir.rawName || ((dir.name) + \\\".\\\" + (Object.keys(dir.modifiers || {}).join('.')))\\r\\n}\\r\\n\\r\\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\\r\\n  var fn = dir.def && dir.def[hook];\\r\\n  if (fn) {\\r\\n    try {\\r\\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\\r\\n    } catch (e) {\\r\\n      handleError(e, vnode.context, (\\\"directive \\\" + (dir.name) + \\\" \\\" + hook + \\\" hook\\\"));\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar baseModules = [\\r\\n  ref,\\r\\n  directives\\r\\n];\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction updateAttrs (oldVnode, vnode) {\\r\\n  var opts = vnode.componentOptions;\\r\\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\\r\\n    return\\r\\n  }\\r\\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\\r\\n    return\\r\\n  }\\r\\n  var key, cur, old;\\r\\n  var elm = vnode.elm;\\r\\n  var oldAttrs = oldVnode.data.attrs || {};\\r\\n  var attrs = vnode.data.attrs || {};\\r\\n  // clone observed objects, as the user probably wants to mutate it\\r\\n  if (isDef(attrs.__ob__)) {\\r\\n    attrs = vnode.data.attrs = extend({}, attrs);\\r\\n  }\\r\\n\\r\\n  for (key in attrs) {\\r\\n    cur = attrs[key];\\r\\n    old = oldAttrs[key];\\r\\n    if (old !== cur) {\\r\\n      setAttr(elm, key, cur);\\r\\n    }\\r\\n  }\\r\\n  // #4391: in IE9, setting type can reset value for input[type=radio]\\r\\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\\r\\n  /* istanbul ignore if */\\r\\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\\r\\n    setAttr(elm, 'value', attrs.value);\\r\\n  }\\r\\n  for (key in oldAttrs) {\\r\\n    if (isUndef(attrs[key])) {\\r\\n      if (isXlink(key)) {\\r\\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\\r\\n      } else if (!isEnumeratedAttr(key)) {\\r\\n        elm.removeAttribute(key);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction setAttr (el, key, value) {\\r\\n  if (el.tagName.indexOf('-') > -1) {\\r\\n    baseSetAttr(el, key, value);\\r\\n  } else if (isBooleanAttr(key)) {\\r\\n    // set attribute for blank value\\r\\n    // e.g. <option disabled>Select one</option>\\r\\n    if (isFalsyAttrValue(value)) {\\r\\n      el.removeAttribute(key);\\r\\n    } else {\\r\\n      // technically allowfullscreen is a boolean attribute for <iframe>,\\r\\n      // but Flash expects a value of \\\"true\\\" when used on <embed> tag\\r\\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\\r\\n        ? 'true'\\r\\n        : key;\\r\\n      el.setAttribute(key, value);\\r\\n    }\\r\\n  } else if (isEnumeratedAttr(key)) {\\r\\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\\r\\n  } else if (isXlink(key)) {\\r\\n    if (isFalsyAttrValue(value)) {\\r\\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\\r\\n    } else {\\r\\n      el.setAttributeNS(xlinkNS, key, value);\\r\\n    }\\r\\n  } else {\\r\\n    baseSetAttr(el, key, value);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction baseSetAttr (el, key, value) {\\r\\n  if (isFalsyAttrValue(value)) {\\r\\n    el.removeAttribute(key);\\r\\n  } else {\\r\\n    // #7138: IE10 & 11 fires input event when setting placeholder on\\r\\n    // <textarea>... block the first input event and remove the blocker\\r\\n    // immediately.\\r\\n    /* istanbul ignore if */\\r\\n    if (\\r\\n      isIE && !isIE9 &&\\r\\n      (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') &&\\r\\n      key === 'placeholder' && !el.__ieph\\r\\n    ) {\\r\\n      var blocker = function (e) {\\r\\n        e.stopImmediatePropagation();\\r\\n        el.removeEventListener('input', blocker);\\r\\n      };\\r\\n      el.addEventListener('input', blocker);\\r\\n      // $flow-disable-line\\r\\n      el.__ieph = true; /* IE placeholder patched */\\r\\n    }\\r\\n    el.setAttribute(key, value);\\r\\n  }\\r\\n}\\r\\n\\r\\nvar attrs = {\\r\\n  create: updateAttrs,\\r\\n  update: updateAttrs\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction updateClass (oldVnode, vnode) {\\r\\n  var el = vnode.elm;\\r\\n  var data = vnode.data;\\r\\n  var oldData = oldVnode.data;\\r\\n  if (\\r\\n    isUndef(data.staticClass) &&\\r\\n    isUndef(data.class) && (\\r\\n      isUndef(oldData) || (\\r\\n        isUndef(oldData.staticClass) &&\\r\\n        isUndef(oldData.class)\\r\\n      )\\r\\n    )\\r\\n  ) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var cls = genClassForVnode(vnode);\\r\\n\\r\\n  // handle transition classes\\r\\n  var transitionClass = el._transitionClasses;\\r\\n  if (isDef(transitionClass)) {\\r\\n    cls = concat(cls, stringifyClass(transitionClass));\\r\\n  }\\r\\n\\r\\n  // set the class\\r\\n  if (cls !== el._prevClass) {\\r\\n    el.setAttribute('class', cls);\\r\\n    el._prevClass = cls;\\r\\n  }\\r\\n}\\r\\n\\r\\nvar klass = {\\r\\n  create: updateClass,\\r\\n  update: updateClass\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar validDivisionCharRE = /[\\\\w).+\\\\-_$\\\\]]/;\\r\\n\\r\\nfunction parseFilters (exp) {\\r\\n  var inSingle = false;\\r\\n  var inDouble = false;\\r\\n  var inTemplateString = false;\\r\\n  var inRegex = false;\\r\\n  var curly = 0;\\r\\n  var square = 0;\\r\\n  var paren = 0;\\r\\n  var lastFilterIndex = 0;\\r\\n  var c, prev, i, expression, filters;\\r\\n\\r\\n  for (i = 0; i < exp.length; i++) {\\r\\n    prev = c;\\r\\n    c = exp.charCodeAt(i);\\r\\n    if (inSingle) {\\r\\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\\r\\n    } else if (inDouble) {\\r\\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\\r\\n    } else if (inTemplateString) {\\r\\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\\r\\n    } else if (inRegex) {\\r\\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\\r\\n    } else if (\\r\\n      c === 0x7C && // pipe\\r\\n      exp.charCodeAt(i + 1) !== 0x7C &&\\r\\n      exp.charCodeAt(i - 1) !== 0x7C &&\\r\\n      !curly && !square && !paren\\r\\n    ) {\\r\\n      if (expression === undefined) {\\r\\n        // first filter, end of expression\\r\\n        lastFilterIndex = i + 1;\\r\\n        expression = exp.slice(0, i).trim();\\r\\n      } else {\\r\\n        pushFilter();\\r\\n      }\\r\\n    } else {\\r\\n      switch (c) {\\r\\n        case 0x22: inDouble = true; break         // \\\"\\r\\n        case 0x27: inSingle = true; break         // '\\r\\n        case 0x60: inTemplateString = true; break // `\\r\\n        case 0x28: paren++; break                 // (\\r\\n        case 0x29: paren--; break                 // )\\r\\n        case 0x5B: square++; break                // [\\r\\n        case 0x5D: square--; break                // ]\\r\\n        case 0x7B: curly++; break                 // {\\r\\n        case 0x7D: curly--; break                 // }\\r\\n      }\\r\\n      if (c === 0x2f) { // /\\r\\n        var j = i - 1;\\r\\n        var p = (void 0);\\r\\n        // find first non-whitespace prev char\\r\\n        for (; j >= 0; j--) {\\r\\n          p = exp.charAt(j);\\r\\n          if (p !== ' ') { break }\\r\\n        }\\r\\n        if (!p || !validDivisionCharRE.test(p)) {\\r\\n          inRegex = true;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (expression === undefined) {\\r\\n    expression = exp.slice(0, i).trim();\\r\\n  } else if (lastFilterIndex !== 0) {\\r\\n    pushFilter();\\r\\n  }\\r\\n\\r\\n  function pushFilter () {\\r\\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\\r\\n    lastFilterIndex = i + 1;\\r\\n  }\\r\\n\\r\\n  if (filters) {\\r\\n    for (i = 0; i < filters.length; i++) {\\r\\n      expression = wrapFilter(expression, filters[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return expression\\r\\n}\\r\\n\\r\\nfunction wrapFilter (exp, filter) {\\r\\n  var i = filter.indexOf('(');\\r\\n  if (i < 0) {\\r\\n    // _f: resolveFilter\\r\\n    return (\\\"_f(\\\\\\\"\\\" + filter + \\\"\\\\\\\")(\\\" + exp + \\\")\\\")\\r\\n  } else {\\r\\n    var name = filter.slice(0, i);\\r\\n    var args = filter.slice(i + 1);\\r\\n    return (\\\"_f(\\\\\\\"\\\" + name + \\\"\\\\\\\")(\\\" + exp + (args !== ')' ? ',' + args : args))\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction baseWarn (msg) {\\r\\n  console.error((\\\"[Vue compiler]: \\\" + msg));\\r\\n}\\r\\n\\r\\nfunction pluckModuleFunction (\\r\\n  modules,\\r\\n  key\\r\\n) {\\r\\n  return modules\\r\\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\\r\\n    : []\\r\\n}\\r\\n\\r\\nfunction addProp (el, name, value) {\\r\\n  (el.props || (el.props = [])).push({ name: name, value: value });\\r\\n  el.plain = false;\\r\\n}\\r\\n\\r\\nfunction addAttr (el, name, value) {\\r\\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\\r\\n  el.plain = false;\\r\\n}\\r\\n\\r\\n// add a raw attr (use this in preTransforms)\\r\\nfunction addRawAttr (el, name, value) {\\r\\n  el.attrsMap[name] = value;\\r\\n  el.attrsList.push({ name: name, value: value });\\r\\n}\\r\\n\\r\\nfunction addDirective (\\r\\n  el,\\r\\n  name,\\r\\n  rawName,\\r\\n  value,\\r\\n  arg,\\r\\n  modifiers\\r\\n) {\\r\\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\\r\\n  el.plain = false;\\r\\n}\\r\\n\\r\\nfunction addHandler (\\r\\n  el,\\r\\n  name,\\r\\n  value,\\r\\n  modifiers,\\r\\n  important,\\r\\n  warn\\r\\n) {\\r\\n  modifiers = modifiers || emptyObject;\\r\\n  // warn prevent and passive modifier\\r\\n  /* istanbul ignore if */\\r\\n  if (\\r\\n    false\\r\\n  ) {}\\r\\n\\r\\n  // normalize click.right and click.middle since they don't actually fire\\r\\n  // this is technically browser-specific, but at least for now browsers are\\r\\n  // the only target envs that have right/middle clicks.\\r\\n  if (name === 'click') {\\r\\n    if (modifiers.right) {\\r\\n      name = 'contextmenu';\\r\\n      delete modifiers.right;\\r\\n    } else if (modifiers.middle) {\\r\\n      name = 'mouseup';\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // check capture modifier\\r\\n  if (modifiers.capture) {\\r\\n    delete modifiers.capture;\\r\\n    name = '!' + name; // mark the event as captured\\r\\n  }\\r\\n  if (modifiers.once) {\\r\\n    delete modifiers.once;\\r\\n    name = '~' + name; // mark the event as once\\r\\n  }\\r\\n  /* istanbul ignore if */\\r\\n  if (modifiers.passive) {\\r\\n    delete modifiers.passive;\\r\\n    name = '&' + name; // mark the event as passive\\r\\n  }\\r\\n\\r\\n  var events;\\r\\n  if (modifiers.native) {\\r\\n    delete modifiers.native;\\r\\n    events = el.nativeEvents || (el.nativeEvents = {});\\r\\n  } else {\\r\\n    events = el.events || (el.events = {});\\r\\n  }\\r\\n\\r\\n  var newHandler = {\\r\\n    value: value.trim()\\r\\n  };\\r\\n  if (modifiers !== emptyObject) {\\r\\n    newHandler.modifiers = modifiers;\\r\\n  }\\r\\n\\r\\n  var handlers = events[name];\\r\\n  /* istanbul ignore if */\\r\\n  if (Array.isArray(handlers)) {\\r\\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\\r\\n  } else if (handlers) {\\r\\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\\r\\n  } else {\\r\\n    events[name] = newHandler;\\r\\n  }\\r\\n\\r\\n  el.plain = false;\\r\\n}\\r\\n\\r\\nfunction getBindingAttr (\\r\\n  el,\\r\\n  name,\\r\\n  getStatic\\r\\n) {\\r\\n  var dynamicValue =\\r\\n    getAndRemoveAttr(el, ':' + name) ||\\r\\n    getAndRemoveAttr(el, 'v-bind:' + name);\\r\\n  if (dynamicValue != null) {\\r\\n    return parseFilters(dynamicValue)\\r\\n  } else if (getStatic !== false) {\\r\\n    var staticValue = getAndRemoveAttr(el, name);\\r\\n    if (staticValue != null) {\\r\\n      return JSON.stringify(staticValue)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// note: this only removes the attr from the Array (attrsList) so that it\\r\\n// doesn't get processed by processAttrs.\\r\\n// By default it does NOT remove it from the map (attrsMap) because the map is\\r\\n// needed during codegen.\\r\\nfunction getAndRemoveAttr (\\r\\n  el,\\r\\n  name,\\r\\n  removeFromMap\\r\\n) {\\r\\n  var val;\\r\\n  if ((val = el.attrsMap[name]) != null) {\\r\\n    var list = el.attrsList;\\r\\n    for (var i = 0, l = list.length; i < l; i++) {\\r\\n      if (list[i].name === name) {\\r\\n        list.splice(i, 1);\\r\\n        break\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  if (removeFromMap) {\\r\\n    delete el.attrsMap[name];\\r\\n  }\\r\\n  return val\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n/**\\r\\n * Cross-platform code generation for component v-model\\r\\n */\\r\\nfunction genComponentModel (\\r\\n  el,\\r\\n  value,\\r\\n  modifiers\\r\\n) {\\r\\n  var ref = modifiers || {};\\r\\n  var number = ref.number;\\r\\n  var trim = ref.trim;\\r\\n\\r\\n  var baseValueExpression = '$$v';\\r\\n  var valueExpression = baseValueExpression;\\r\\n  if (trim) {\\r\\n    valueExpression =\\r\\n      \\\"(typeof \\\" + baseValueExpression + \\\" === 'string'\\\" +\\r\\n      \\\"? \\\" + baseValueExpression + \\\".trim()\\\" +\\r\\n      \\\": \\\" + baseValueExpression + \\\")\\\";\\r\\n  }\\r\\n  if (number) {\\r\\n    valueExpression = \\\"_n(\\\" + valueExpression + \\\")\\\";\\r\\n  }\\r\\n  var assignment = genAssignmentCode(value, valueExpression);\\r\\n\\r\\n  el.model = {\\r\\n    value: (\\\"(\\\" + value + \\\")\\\"),\\r\\n    expression: (\\\"\\\\\\\"\\\" + value + \\\"\\\\\\\"\\\"),\\r\\n    callback: (\\\"function (\\\" + baseValueExpression + \\\") {\\\" + assignment + \\\"}\\\")\\r\\n  };\\r\\n}\\r\\n\\r\\n/**\\r\\n * Cross-platform codegen helper for generating v-model value assignment code.\\r\\n */\\r\\nfunction genAssignmentCode (\\r\\n  value,\\r\\n  assignment\\r\\n) {\\r\\n  var res = parseModel(value);\\r\\n  if (res.key === null) {\\r\\n    return (value + \\\"=\\\" + assignment)\\r\\n  } else {\\r\\n    return (\\\"$set(\\\" + (res.exp) + \\\", \\\" + (res.key) + \\\", \\\" + assignment + \\\")\\\")\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Parse a v-model expression into a base path and a final key segment.\\r\\n * Handles both dot-path and possible square brackets.\\r\\n *\\r\\n * Possible cases:\\r\\n *\\r\\n * - test\\r\\n * - test[key]\\r\\n * - test[test1[key]]\\r\\n * - test[\\\"a\\\"][key]\\r\\n * - xxx.test[a[a].test1[key]]\\r\\n * - test.xxx.a[\\\"asa\\\"][test1[key]]\\r\\n *\\r\\n */\\r\\n\\r\\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\\r\\n\\r\\n\\r\\n\\r\\nfunction parseModel (val) {\\r\\n  // Fix https://github.com/vuejs/vue/pull/7730\\r\\n  // allow v-model=\\\"obj.val \\\" (trailing whitespace)\\r\\n  val = val.trim();\\r\\n  len = val.length;\\r\\n\\r\\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\\r\\n    index$1 = val.lastIndexOf('.');\\r\\n    if (index$1 > -1) {\\r\\n      return {\\r\\n        exp: val.slice(0, index$1),\\r\\n        key: '\\\"' + val.slice(index$1 + 1) + '\\\"'\\r\\n      }\\r\\n    } else {\\r\\n      return {\\r\\n        exp: val,\\r\\n        key: null\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  str = val;\\r\\n  index$1 = expressionPos = expressionEndPos = 0;\\r\\n\\r\\n  while (!eof()) {\\r\\n    chr = next();\\r\\n    /* istanbul ignore if */\\r\\n    if (isStringStart(chr)) {\\r\\n      parseString(chr);\\r\\n    } else if (chr === 0x5B) {\\r\\n      parseBracket(chr);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    exp: val.slice(0, expressionPos),\\r\\n    key: val.slice(expressionPos + 1, expressionEndPos)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction next () {\\r\\n  return str.charCodeAt(++index$1)\\r\\n}\\r\\n\\r\\nfunction eof () {\\r\\n  return index$1 >= len\\r\\n}\\r\\n\\r\\nfunction isStringStart (chr) {\\r\\n  return chr === 0x22 || chr === 0x27\\r\\n}\\r\\n\\r\\nfunction parseBracket (chr) {\\r\\n  var inBracket = 1;\\r\\n  expressionPos = index$1;\\r\\n  while (!eof()) {\\r\\n    chr = next();\\r\\n    if (isStringStart(chr)) {\\r\\n      parseString(chr);\\r\\n      continue\\r\\n    }\\r\\n    if (chr === 0x5B) { inBracket++; }\\r\\n    if (chr === 0x5D) { inBracket--; }\\r\\n    if (inBracket === 0) {\\r\\n      expressionEndPos = index$1;\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction parseString (chr) {\\r\\n  var stringQuote = chr;\\r\\n  while (!eof()) {\\r\\n    chr = next();\\r\\n    if (chr === stringQuote) {\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar warn$1;\\r\\n\\r\\n// in some cases, the event used has to be determined at runtime\\r\\n// so we used some reserved tokens during compile.\\r\\nvar RANGE_TOKEN = '__r';\\r\\nvar CHECKBOX_RADIO_TOKEN = '__c';\\r\\n\\r\\nfunction model (\\r\\n  el,\\r\\n  dir,\\r\\n  _warn\\r\\n) {\\r\\n  warn$1 = _warn;\\r\\n  var value = dir.value;\\r\\n  var modifiers = dir.modifiers;\\r\\n  var tag = el.tag;\\r\\n  var type = el.attrsMap.type;\\r\\n\\r\\n  if (false) {}\\r\\n\\r\\n  if (el.component) {\\r\\n    genComponentModel(el, value, modifiers);\\r\\n    // component v-model doesn't need extra runtime\\r\\n    return false\\r\\n  } else if (tag === 'select') {\\r\\n    genSelect(el, value, modifiers);\\r\\n  } else if (tag === 'input' && type === 'checkbox') {\\r\\n    genCheckboxModel(el, value, modifiers);\\r\\n  } else if (tag === 'input' && type === 'radio') {\\r\\n    genRadioModel(el, value, modifiers);\\r\\n  } else if (tag === 'input' || tag === 'textarea') {\\r\\n    genDefaultModel(el, value, modifiers);\\r\\n  } else if (!config.isReservedTag(tag)) {\\r\\n    genComponentModel(el, value, modifiers);\\r\\n    // component v-model doesn't need extra runtime\\r\\n    return false\\r\\n  } else if (false) {}\\r\\n\\r\\n  // ensure runtime directive metadata\\r\\n  return true\\r\\n}\\r\\n\\r\\nfunction genCheckboxModel (\\r\\n  el,\\r\\n  value,\\r\\n  modifiers\\r\\n) {\\r\\n  var number = modifiers && modifiers.number;\\r\\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\\r\\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\\r\\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\\r\\n  addProp(el, 'checked',\\r\\n    \\\"Array.isArray(\\\" + value + \\\")\\\" +\\r\\n    \\\"?_i(\\\" + value + \\\",\\\" + valueBinding + \\\")>-1\\\" + (\\r\\n      trueValueBinding === 'true'\\r\\n        ? (\\\":(\\\" + value + \\\")\\\")\\r\\n        : (\\\":_q(\\\" + value + \\\",\\\" + trueValueBinding + \\\")\\\")\\r\\n    )\\r\\n  );\\r\\n  addHandler(el, 'change',\\r\\n    \\\"var $$a=\\\" + value + \\\",\\\" +\\r\\n        '$$el=$event.target,' +\\r\\n        \\\"$$c=$$el.checked?(\\\" + trueValueBinding + \\\"):(\\\" + falseValueBinding + \\\");\\\" +\\r\\n    'if(Array.isArray($$a)){' +\\r\\n      \\\"var $$v=\\\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \\\",\\\" +\\r\\n          '$$i=_i($$a,$$v);' +\\r\\n      \\\"if($$el.checked){$$i<0&&(\\\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \\\")}\\\" +\\r\\n      \\\"else{$$i>-1&&(\\\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \\\")}\\\" +\\r\\n    \\\"}else{\\\" + (genAssignmentCode(value, '$$c')) + \\\"}\\\",\\r\\n    null, true\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction genRadioModel (\\r\\n  el,\\r\\n  value,\\r\\n  modifiers\\r\\n) {\\r\\n  var number = modifiers && modifiers.number;\\r\\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\\r\\n  valueBinding = number ? (\\\"_n(\\\" + valueBinding + \\\")\\\") : valueBinding;\\r\\n  addProp(el, 'checked', (\\\"_q(\\\" + value + \\\",\\\" + valueBinding + \\\")\\\"));\\r\\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\\r\\n}\\r\\n\\r\\nfunction genSelect (\\r\\n  el,\\r\\n  value,\\r\\n  modifiers\\r\\n) {\\r\\n  var number = modifiers && modifiers.number;\\r\\n  var selectedVal = \\\"Array.prototype.filter\\\" +\\r\\n    \\\".call($event.target.options,function(o){return o.selected})\\\" +\\r\\n    \\\".map(function(o){var val = \\\\\\\"_value\\\\\\\" in o ? o._value : o.value;\\\" +\\r\\n    \\\"return \\\" + (number ? '_n(val)' : 'val') + \\\"})\\\";\\r\\n\\r\\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\\r\\n  var code = \\\"var $$selectedVal = \\\" + selectedVal + \\\";\\\";\\r\\n  code = code + \\\" \\\" + (genAssignmentCode(value, assignment));\\r\\n  addHandler(el, 'change', code, null, true);\\r\\n}\\r\\n\\r\\nfunction genDefaultModel (\\r\\n  el,\\r\\n  value,\\r\\n  modifiers\\r\\n) {\\r\\n  var type = el.attrsMap.type;\\r\\n\\r\\n  // warn if v-bind:value conflicts with v-model\\r\\n  // except for inputs with v-bind:type\\r\\n  if (false) { var binding, typeBinding, value$1; }\\r\\n\\r\\n  var ref = modifiers || {};\\r\\n  var lazy = ref.lazy;\\r\\n  var number = ref.number;\\r\\n  var trim = ref.trim;\\r\\n  var needCompositionGuard = !lazy && type !== 'range';\\r\\n  var event = lazy\\r\\n    ? 'change'\\r\\n    : type === 'range'\\r\\n      ? RANGE_TOKEN\\r\\n      : 'input';\\r\\n\\r\\n  var valueExpression = '$event.target.value';\\r\\n  if (trim) {\\r\\n    valueExpression = \\\"$event.target.value.trim()\\\";\\r\\n  }\\r\\n  if (number) {\\r\\n    valueExpression = \\\"_n(\\\" + valueExpression + \\\")\\\";\\r\\n  }\\r\\n\\r\\n  var code = genAssignmentCode(value, valueExpression);\\r\\n  if (needCompositionGuard) {\\r\\n    code = \\\"if($event.target.composing)return;\\\" + code;\\r\\n  }\\r\\n\\r\\n  addProp(el, 'value', (\\\"(\\\" + value + \\\")\\\"));\\r\\n  addHandler(el, event, code, null, true);\\r\\n  if (trim || number) {\\r\\n    addHandler(el, 'blur', '$forceUpdate()');\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// normalize v-model event tokens that can only be determined at runtime.\\r\\n// it's important to place the event as the first in the array because\\r\\n// the whole point is ensuring the v-model callback gets called before\\r\\n// user-attached handlers.\\r\\nfunction normalizeEvents (on) {\\r\\n  /* istanbul ignore if */\\r\\n  if (isDef(on[RANGE_TOKEN])) {\\r\\n    // IE input[type=range] only supports `change` event\\r\\n    var event = isIE ? 'change' : 'input';\\r\\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\\r\\n    delete on[RANGE_TOKEN];\\r\\n  }\\r\\n  // This was originally intended to fix #4521 but no longer necessary\\r\\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\\r\\n  /* istanbul ignore if */\\r\\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\\r\\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\\r\\n    delete on[CHECKBOX_RADIO_TOKEN];\\r\\n  }\\r\\n}\\r\\n\\r\\nvar target$1;\\r\\n\\r\\nfunction createOnceHandler$1 (event, handler, capture) {\\r\\n  var _target = target$1; // save current target element in closure\\r\\n  return function onceHandler () {\\r\\n    var res = handler.apply(null, arguments);\\r\\n    if (res !== null) {\\r\\n      remove$2(event, onceHandler, capture, _target);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction add$1 (\\r\\n  event,\\r\\n  handler,\\r\\n  capture,\\r\\n  passive\\r\\n) {\\r\\n  handler = withMacroTask(handler);\\r\\n  target$1.addEventListener(\\r\\n    event,\\r\\n    handler,\\r\\n    supportsPassive\\r\\n      ? { capture: capture, passive: passive }\\r\\n      : capture\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction remove$2 (\\r\\n  event,\\r\\n  handler,\\r\\n  capture,\\r\\n  _target\\r\\n) {\\r\\n  (_target || target$1).removeEventListener(\\r\\n    event,\\r\\n    handler._withTask || handler,\\r\\n    capture\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction updateDOMListeners (oldVnode, vnode) {\\r\\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\\r\\n    return\\r\\n  }\\r\\n  var on = vnode.data.on || {};\\r\\n  var oldOn = oldVnode.data.on || {};\\r\\n  target$1 = vnode.elm;\\r\\n  normalizeEvents(on);\\r\\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\\r\\n  target$1 = undefined;\\r\\n}\\r\\n\\r\\nvar events = {\\r\\n  create: updateDOMListeners,\\r\\n  update: updateDOMListeners\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction updateDOMProps (oldVnode, vnode) {\\r\\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\\r\\n    return\\r\\n  }\\r\\n  var key, cur;\\r\\n  var elm = vnode.elm;\\r\\n  var oldProps = oldVnode.data.domProps || {};\\r\\n  var props = vnode.data.domProps || {};\\r\\n  // clone observed objects, as the user probably wants to mutate it\\r\\n  if (isDef(props.__ob__)) {\\r\\n    props = vnode.data.domProps = extend({}, props);\\r\\n  }\\r\\n\\r\\n  for (key in oldProps) {\\r\\n    if (isUndef(props[key])) {\\r\\n      elm[key] = '';\\r\\n    }\\r\\n  }\\r\\n  for (key in props) {\\r\\n    cur = props[key];\\r\\n    // ignore children if the node has textContent or innerHTML,\\r\\n    // as these will throw away existing DOM nodes and cause removal errors\\r\\n    // on subsequent patches (#3360)\\r\\n    if (key === 'textContent' || key === 'innerHTML') {\\r\\n      if (vnode.children) { vnode.children.length = 0; }\\r\\n      if (cur === oldProps[key]) { continue }\\r\\n      // #6601 work around Chrome version <= 55 bug where single textNode\\r\\n      // replaced by innerHTML/textContent retains its parentNode property\\r\\n      if (elm.childNodes.length === 1) {\\r\\n        elm.removeChild(elm.childNodes[0]);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (key === 'value') {\\r\\n      // store value as _value as well since\\r\\n      // non-string values will be stringified\\r\\n      elm._value = cur;\\r\\n      // avoid resetting cursor position when value is the same\\r\\n      var strCur = isUndef(cur) ? '' : String(cur);\\r\\n      if (shouldUpdateValue(elm, strCur)) {\\r\\n        elm.value = strCur;\\r\\n      }\\r\\n    } else {\\r\\n      elm[key] = cur;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// check platforms/web/util/attrs.js acceptValue\\r\\n\\r\\n\\r\\nfunction shouldUpdateValue (elm, checkVal) {\\r\\n  return (!elm.composing && (\\r\\n    elm.tagName === 'OPTION' ||\\r\\n    isNotInFocusAndDirty(elm, checkVal) ||\\r\\n    isDirtyWithModifiers(elm, checkVal)\\r\\n  ))\\r\\n}\\r\\n\\r\\nfunction isNotInFocusAndDirty (elm, checkVal) {\\r\\n  // return true when textbox (.number and .trim) loses focus and its value is\\r\\n  // not equal to the updated value\\r\\n  var notInFocus = true;\\r\\n  // #6157\\r\\n  // work around IE bug when accessing document.activeElement in an iframe\\r\\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\\r\\n  return notInFocus && elm.value !== checkVal\\r\\n}\\r\\n\\r\\nfunction isDirtyWithModifiers (elm, newVal) {\\r\\n  var value = elm.value;\\r\\n  var modifiers = elm._vModifiers; // injected by v-model runtime\\r\\n  if (isDef(modifiers)) {\\r\\n    if (modifiers.lazy) {\\r\\n      // inputs with lazy should only be updated when not in focus\\r\\n      return false\\r\\n    }\\r\\n    if (modifiers.number) {\\r\\n      return toNumber(value) !== toNumber(newVal)\\r\\n    }\\r\\n    if (modifiers.trim) {\\r\\n      return value.trim() !== newVal.trim()\\r\\n    }\\r\\n  }\\r\\n  return value !== newVal\\r\\n}\\r\\n\\r\\nvar domProps = {\\r\\n  create: updateDOMProps,\\r\\n  update: updateDOMProps\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar parseStyleText = cached(function (cssText) {\\r\\n  var res = {};\\r\\n  var listDelimiter = /;(?![^(]*\\\\))/g;\\r\\n  var propertyDelimiter = /:(.+)/;\\r\\n  cssText.split(listDelimiter).forEach(function (item) {\\r\\n    if (item) {\\r\\n      var tmp = item.split(propertyDelimiter);\\r\\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\\r\\n    }\\r\\n  });\\r\\n  return res\\r\\n});\\r\\n\\r\\n// merge static and dynamic style data on the same vnode\\r\\nfunction normalizeStyleData (data) {\\r\\n  var style = normalizeStyleBinding(data.style);\\r\\n  // static style is pre-processed into an object during compilation\\r\\n  // and is always a fresh object, so it's safe to merge into it\\r\\n  return data.staticStyle\\r\\n    ? extend(data.staticStyle, style)\\r\\n    : style\\r\\n}\\r\\n\\r\\n// normalize possible array / string values into Object\\r\\nfunction normalizeStyleBinding (bindingStyle) {\\r\\n  if (Array.isArray(bindingStyle)) {\\r\\n    return toObject(bindingStyle)\\r\\n  }\\r\\n  if (typeof bindingStyle === 'string') {\\r\\n    return parseStyleText(bindingStyle)\\r\\n  }\\r\\n  return bindingStyle\\r\\n}\\r\\n\\r\\n/**\\r\\n * parent component style should be after child's\\r\\n * so that parent component's style could override it\\r\\n */\\r\\nfunction getStyle (vnode, checkChild) {\\r\\n  var res = {};\\r\\n  var styleData;\\r\\n\\r\\n  if (checkChild) {\\r\\n    var childNode = vnode;\\r\\n    while (childNode.componentInstance) {\\r\\n      childNode = childNode.componentInstance._vnode;\\r\\n      if (\\r\\n        childNode && childNode.data &&\\r\\n        (styleData = normalizeStyleData(childNode.data))\\r\\n      ) {\\r\\n        extend(res, styleData);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if ((styleData = normalizeStyleData(vnode.data))) {\\r\\n    extend(res, styleData);\\r\\n  }\\r\\n\\r\\n  var parentNode = vnode;\\r\\n  while ((parentNode = parentNode.parent)) {\\r\\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\\r\\n      extend(res, styleData);\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar cssVarRE = /^--/;\\r\\nvar importantRE = /\\\\s*!important$/;\\r\\nvar setProp = function (el, name, val) {\\r\\n  /* istanbul ignore if */\\r\\n  if (cssVarRE.test(name)) {\\r\\n    el.style.setProperty(name, val);\\r\\n  } else if (importantRE.test(val)) {\\r\\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\\r\\n  } else {\\r\\n    var normalizedName = normalize(name);\\r\\n    if (Array.isArray(val)) {\\r\\n      // Support values array created by autoprefixer, e.g.\\r\\n      // {display: [\\\"-webkit-box\\\", \\\"-ms-flexbox\\\", \\\"flex\\\"]}\\r\\n      // Set them one by one, and the browser will only set those it can recognize\\r\\n      for (var i = 0, len = val.length; i < len; i++) {\\r\\n        el.style[normalizedName] = val[i];\\r\\n      }\\r\\n    } else {\\r\\n      el.style[normalizedName] = val;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\\r\\n\\r\\nvar emptyStyle;\\r\\nvar normalize = cached(function (prop) {\\r\\n  emptyStyle = emptyStyle || document.createElement('div').style;\\r\\n  prop = camelize(prop);\\r\\n  if (prop !== 'filter' && (prop in emptyStyle)) {\\r\\n    return prop\\r\\n  }\\r\\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\\r\\n  for (var i = 0; i < vendorNames.length; i++) {\\r\\n    var name = vendorNames[i] + capName;\\r\\n    if (name in emptyStyle) {\\r\\n      return name\\r\\n    }\\r\\n  }\\r\\n});\\r\\n\\r\\nfunction updateStyle (oldVnode, vnode) {\\r\\n  var data = vnode.data;\\r\\n  var oldData = oldVnode.data;\\r\\n\\r\\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\\r\\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\\r\\n  ) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var cur, name;\\r\\n  var el = vnode.elm;\\r\\n  var oldStaticStyle = oldData.staticStyle;\\r\\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\\r\\n\\r\\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\\r\\n  var oldStyle = oldStaticStyle || oldStyleBinding;\\r\\n\\r\\n  var style = normalizeStyleBinding(vnode.data.style) || {};\\r\\n\\r\\n  // store normalized style under a different key for next diff\\r\\n  // make sure to clone it if it's reactive, since the user likely wants\\r\\n  // to mutate it.\\r\\n  vnode.data.normalizedStyle = isDef(style.__ob__)\\r\\n    ? extend({}, style)\\r\\n    : style;\\r\\n\\r\\n  var newStyle = getStyle(vnode, true);\\r\\n\\r\\n  for (name in oldStyle) {\\r\\n    if (isUndef(newStyle[name])) {\\r\\n      setProp(el, name, '');\\r\\n    }\\r\\n  }\\r\\n  for (name in newStyle) {\\r\\n    cur = newStyle[name];\\r\\n    if (cur !== oldStyle[name]) {\\r\\n      // ie9 setting to null has no effect, must use empty string\\r\\n      setProp(el, name, cur == null ? '' : cur);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar style = {\\r\\n  create: updateStyle,\\r\\n  update: updateStyle\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar whitespaceRE = /\\\\s+/;\\r\\n\\r\\n/**\\r\\n * Add class with compatibility for SVG since classList is not supported on\\r\\n * SVG elements in IE\\r\\n */\\r\\nfunction addClass (el, cls) {\\r\\n  /* istanbul ignore if */\\r\\n  if (!cls || !(cls = cls.trim())) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  /* istanbul ignore else */\\r\\n  if (el.classList) {\\r\\n    if (cls.indexOf(' ') > -1) {\\r\\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\\r\\n    } else {\\r\\n      el.classList.add(cls);\\r\\n    }\\r\\n  } else {\\r\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\r\\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\\r\\n      el.setAttribute('class', (cur + cls).trim());\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Remove class with compatibility for SVG since classList is not supported on\\r\\n * SVG elements in IE\\r\\n */\\r\\nfunction removeClass (el, cls) {\\r\\n  /* istanbul ignore if */\\r\\n  if (!cls || !(cls = cls.trim())) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  /* istanbul ignore else */\\r\\n  if (el.classList) {\\r\\n    if (cls.indexOf(' ') > -1) {\\r\\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\\r\\n    } else {\\r\\n      el.classList.remove(cls);\\r\\n    }\\r\\n    if (!el.classList.length) {\\r\\n      el.removeAttribute('class');\\r\\n    }\\r\\n  } else {\\r\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\r\\n    var tar = ' ' + cls + ' ';\\r\\n    while (cur.indexOf(tar) >= 0) {\\r\\n      cur = cur.replace(tar, ' ');\\r\\n    }\\r\\n    cur = cur.trim();\\r\\n    if (cur) {\\r\\n      el.setAttribute('class', cur);\\r\\n    } else {\\r\\n      el.removeAttribute('class');\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction resolveTransition (def$$1) {\\r\\n  if (!def$$1) {\\r\\n    return\\r\\n  }\\r\\n  /* istanbul ignore else */\\r\\n  if (typeof def$$1 === 'object') {\\r\\n    var res = {};\\r\\n    if (def$$1.css !== false) {\\r\\n      extend(res, autoCssTransition(def$$1.name || 'v'));\\r\\n    }\\r\\n    extend(res, def$$1);\\r\\n    return res\\r\\n  } else if (typeof def$$1 === 'string') {\\r\\n    return autoCssTransition(def$$1)\\r\\n  }\\r\\n}\\r\\n\\r\\nvar autoCssTransition = cached(function (name) {\\r\\n  return {\\r\\n    enterClass: (name + \\\"-enter\\\"),\\r\\n    enterToClass: (name + \\\"-enter-to\\\"),\\r\\n    enterActiveClass: (name + \\\"-enter-active\\\"),\\r\\n    leaveClass: (name + \\\"-leave\\\"),\\r\\n    leaveToClass: (name + \\\"-leave-to\\\"),\\r\\n    leaveActiveClass: (name + \\\"-leave-active\\\")\\r\\n  }\\r\\n});\\r\\n\\r\\nvar hasTransition = inBrowser && !isIE9;\\r\\nvar TRANSITION = 'transition';\\r\\nvar ANIMATION = 'animation';\\r\\n\\r\\n// Transition property/event sniffing\\r\\nvar transitionProp = 'transition';\\r\\nvar transitionEndEvent = 'transitionend';\\r\\nvar animationProp = 'animation';\\r\\nvar animationEndEvent = 'animationend';\\r\\nif (hasTransition) {\\r\\n  /* istanbul ignore if */\\r\\n  if (window.ontransitionend === undefined &&\\r\\n    window.onwebkittransitionend !== undefined\\r\\n  ) {\\r\\n    transitionProp = 'WebkitTransition';\\r\\n    transitionEndEvent = 'webkitTransitionEnd';\\r\\n  }\\r\\n  if (window.onanimationend === undefined &&\\r\\n    window.onwebkitanimationend !== undefined\\r\\n  ) {\\r\\n    animationProp = 'WebkitAnimation';\\r\\n    animationEndEvent = 'webkitAnimationEnd';\\r\\n  }\\r\\n}\\r\\n\\r\\n// binding to window is necessary to make hot reload work in IE in strict mode\\r\\nvar raf = inBrowser\\r\\n  ? window.requestAnimationFrame\\r\\n    ? window.requestAnimationFrame.bind(window)\\r\\n    : setTimeout\\r\\n  : /* istanbul ignore next */ function (fn) { return fn(); };\\r\\n\\r\\nfunction nextFrame (fn) {\\r\\n  raf(function () {\\r\\n    raf(fn);\\r\\n  });\\r\\n}\\r\\n\\r\\nfunction addTransitionClass (el, cls) {\\r\\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\\r\\n  if (transitionClasses.indexOf(cls) < 0) {\\r\\n    transitionClasses.push(cls);\\r\\n    addClass(el, cls);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction removeTransitionClass (el, cls) {\\r\\n  if (el._transitionClasses) {\\r\\n    remove(el._transitionClasses, cls);\\r\\n  }\\r\\n  removeClass(el, cls);\\r\\n}\\r\\n\\r\\nfunction whenTransitionEnds (\\r\\n  el,\\r\\n  expectedType,\\r\\n  cb\\r\\n) {\\r\\n  var ref = getTransitionInfo(el, expectedType);\\r\\n  var type = ref.type;\\r\\n  var timeout = ref.timeout;\\r\\n  var propCount = ref.propCount;\\r\\n  if (!type) { return cb() }\\r\\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\\r\\n  var ended = 0;\\r\\n  var end = function () {\\r\\n    el.removeEventListener(event, onEnd);\\r\\n    cb();\\r\\n  };\\r\\n  var onEnd = function (e) {\\r\\n    if (e.target === el) {\\r\\n      if (++ended >= propCount) {\\r\\n        end();\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n  setTimeout(function () {\\r\\n    if (ended < propCount) {\\r\\n      end();\\r\\n    }\\r\\n  }, timeout + 1);\\r\\n  el.addEventListener(event, onEnd);\\r\\n}\\r\\n\\r\\nvar transformRE = /\\\\b(transform|all)(,|$)/;\\r\\n\\r\\nfunction getTransitionInfo (el, expectedType) {\\r\\n  var styles = window.getComputedStyle(el);\\r\\n  // JSDOM may return undefined for transition properties\\r\\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\\r\\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\\r\\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\\r\\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\\r\\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\\r\\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\\r\\n\\r\\n  var type;\\r\\n  var timeout = 0;\\r\\n  var propCount = 0;\\r\\n  /* istanbul ignore if */\\r\\n  if (expectedType === TRANSITION) {\\r\\n    if (transitionTimeout > 0) {\\r\\n      type = TRANSITION;\\r\\n      timeout = transitionTimeout;\\r\\n      propCount = transitionDurations.length;\\r\\n    }\\r\\n  } else if (expectedType === ANIMATION) {\\r\\n    if (animationTimeout > 0) {\\r\\n      type = ANIMATION;\\r\\n      timeout = animationTimeout;\\r\\n      propCount = animationDurations.length;\\r\\n    }\\r\\n  } else {\\r\\n    timeout = Math.max(transitionTimeout, animationTimeout);\\r\\n    type = timeout > 0\\r\\n      ? transitionTimeout > animationTimeout\\r\\n        ? TRANSITION\\r\\n        : ANIMATION\\r\\n      : null;\\r\\n    propCount = type\\r\\n      ? type === TRANSITION\\r\\n        ? transitionDurations.length\\r\\n        : animationDurations.length\\r\\n      : 0;\\r\\n  }\\r\\n  var hasTransform =\\r\\n    type === TRANSITION &&\\r\\n    transformRE.test(styles[transitionProp + 'Property']);\\r\\n  return {\\r\\n    type: type,\\r\\n    timeout: timeout,\\r\\n    propCount: propCount,\\r\\n    hasTransform: hasTransform\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getTimeout (delays, durations) {\\r\\n  /* istanbul ignore next */\\r\\n  while (delays.length < durations.length) {\\r\\n    delays = delays.concat(delays);\\r\\n  }\\r\\n\\r\\n  return Math.max.apply(null, durations.map(function (d, i) {\\r\\n    return toMs(d) + toMs(delays[i])\\r\\n  }))\\r\\n}\\r\\n\\r\\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\\r\\n// in a locale-dependent way, using a comma instead of a dot.\\r\\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\\r\\n// as a floor function) causing unexpected behaviors\\r\\nfunction toMs (s) {\\r\\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction enter (vnode, toggleDisplay) {\\r\\n  var el = vnode.elm;\\r\\n\\r\\n  // call leave callback now\\r\\n  if (isDef(el._leaveCb)) {\\r\\n    el._leaveCb.cancelled = true;\\r\\n    el._leaveCb();\\r\\n  }\\r\\n\\r\\n  var data = resolveTransition(vnode.data.transition);\\r\\n  if (isUndef(data)) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  /* istanbul ignore if */\\r\\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var css = data.css;\\r\\n  var type = data.type;\\r\\n  var enterClass = data.enterClass;\\r\\n  var enterToClass = data.enterToClass;\\r\\n  var enterActiveClass = data.enterActiveClass;\\r\\n  var appearClass = data.appearClass;\\r\\n  var appearToClass = data.appearToClass;\\r\\n  var appearActiveClass = data.appearActiveClass;\\r\\n  var beforeEnter = data.beforeEnter;\\r\\n  var enter = data.enter;\\r\\n  var afterEnter = data.afterEnter;\\r\\n  var enterCancelled = data.enterCancelled;\\r\\n  var beforeAppear = data.beforeAppear;\\r\\n  var appear = data.appear;\\r\\n  var afterAppear = data.afterAppear;\\r\\n  var appearCancelled = data.appearCancelled;\\r\\n  var duration = data.duration;\\r\\n\\r\\n  // activeInstance will always be the <transition> component managing this\\r\\n  // transition. One edge case to check is when the <transition> is placed\\r\\n  // as the root node of a child component. In that case we need to check\\r\\n  // <transition>'s parent for appear check.\\r\\n  var context = activeInstance;\\r\\n  var transitionNode = activeInstance.$vnode;\\r\\n  while (transitionNode && transitionNode.parent) {\\r\\n    transitionNode = transitionNode.parent;\\r\\n    context = transitionNode.context;\\r\\n  }\\r\\n\\r\\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\\r\\n\\r\\n  if (isAppear && !appear && appear !== '') {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var startClass = isAppear && appearClass\\r\\n    ? appearClass\\r\\n    : enterClass;\\r\\n  var activeClass = isAppear && appearActiveClass\\r\\n    ? appearActiveClass\\r\\n    : enterActiveClass;\\r\\n  var toClass = isAppear && appearToClass\\r\\n    ? appearToClass\\r\\n    : enterToClass;\\r\\n\\r\\n  var beforeEnterHook = isAppear\\r\\n    ? (beforeAppear || beforeEnter)\\r\\n    : beforeEnter;\\r\\n  var enterHook = isAppear\\r\\n    ? (typeof appear === 'function' ? appear : enter)\\r\\n    : enter;\\r\\n  var afterEnterHook = isAppear\\r\\n    ? (afterAppear || afterEnter)\\r\\n    : afterEnter;\\r\\n  var enterCancelledHook = isAppear\\r\\n    ? (appearCancelled || enterCancelled)\\r\\n    : enterCancelled;\\r\\n\\r\\n  var explicitEnterDuration = toNumber(\\r\\n    isObject(duration)\\r\\n      ? duration.enter\\r\\n      : duration\\r\\n  );\\r\\n\\r\\n  if (false) {}\\r\\n\\r\\n  var expectsCSS = css !== false && !isIE9;\\r\\n  var userWantsControl = getHookArgumentsLength(enterHook);\\r\\n\\r\\n  var cb = el._enterCb = once(function () {\\r\\n    if (expectsCSS) {\\r\\n      removeTransitionClass(el, toClass);\\r\\n      removeTransitionClass(el, activeClass);\\r\\n    }\\r\\n    if (cb.cancelled) {\\r\\n      if (expectsCSS) {\\r\\n        removeTransitionClass(el, startClass);\\r\\n      }\\r\\n      enterCancelledHook && enterCancelledHook(el);\\r\\n    } else {\\r\\n      afterEnterHook && afterEnterHook(el);\\r\\n    }\\r\\n    el._enterCb = null;\\r\\n  });\\r\\n\\r\\n  if (!vnode.data.show) {\\r\\n    // remove pending leave element on enter by injecting an insert hook\\r\\n    mergeVNodeHook(vnode, 'insert', function () {\\r\\n      var parent = el.parentNode;\\r\\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\\r\\n      if (pendingNode &&\\r\\n        pendingNode.tag === vnode.tag &&\\r\\n        pendingNode.elm._leaveCb\\r\\n      ) {\\r\\n        pendingNode.elm._leaveCb();\\r\\n      }\\r\\n      enterHook && enterHook(el, cb);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // start enter transition\\r\\n  beforeEnterHook && beforeEnterHook(el);\\r\\n  if (expectsCSS) {\\r\\n    addTransitionClass(el, startClass);\\r\\n    addTransitionClass(el, activeClass);\\r\\n    nextFrame(function () {\\r\\n      removeTransitionClass(el, startClass);\\r\\n      if (!cb.cancelled) {\\r\\n        addTransitionClass(el, toClass);\\r\\n        if (!userWantsControl) {\\r\\n          if (isValidDuration(explicitEnterDuration)) {\\r\\n            setTimeout(cb, explicitEnterDuration);\\r\\n          } else {\\r\\n            whenTransitionEnds(el, type, cb);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  if (vnode.data.show) {\\r\\n    toggleDisplay && toggleDisplay();\\r\\n    enterHook && enterHook(el, cb);\\r\\n  }\\r\\n\\r\\n  if (!expectsCSS && !userWantsControl) {\\r\\n    cb();\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction leave (vnode, rm) {\\r\\n  var el = vnode.elm;\\r\\n\\r\\n  // call enter callback now\\r\\n  if (isDef(el._enterCb)) {\\r\\n    el._enterCb.cancelled = true;\\r\\n    el._enterCb();\\r\\n  }\\r\\n\\r\\n  var data = resolveTransition(vnode.data.transition);\\r\\n  if (isUndef(data) || el.nodeType !== 1) {\\r\\n    return rm()\\r\\n  }\\r\\n\\r\\n  /* istanbul ignore if */\\r\\n  if (isDef(el._leaveCb)) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var css = data.css;\\r\\n  var type = data.type;\\r\\n  var leaveClass = data.leaveClass;\\r\\n  var leaveToClass = data.leaveToClass;\\r\\n  var leaveActiveClass = data.leaveActiveClass;\\r\\n  var beforeLeave = data.beforeLeave;\\r\\n  var leave = data.leave;\\r\\n  var afterLeave = data.afterLeave;\\r\\n  var leaveCancelled = data.leaveCancelled;\\r\\n  var delayLeave = data.delayLeave;\\r\\n  var duration = data.duration;\\r\\n\\r\\n  var expectsCSS = css !== false && !isIE9;\\r\\n  var userWantsControl = getHookArgumentsLength(leave);\\r\\n\\r\\n  var explicitLeaveDuration = toNumber(\\r\\n    isObject(duration)\\r\\n      ? duration.leave\\r\\n      : duration\\r\\n  );\\r\\n\\r\\n  if (false) {}\\r\\n\\r\\n  var cb = el._leaveCb = once(function () {\\r\\n    if (el.parentNode && el.parentNode._pending) {\\r\\n      el.parentNode._pending[vnode.key] = null;\\r\\n    }\\r\\n    if (expectsCSS) {\\r\\n      removeTransitionClass(el, leaveToClass);\\r\\n      removeTransitionClass(el, leaveActiveClass);\\r\\n    }\\r\\n    if (cb.cancelled) {\\r\\n      if (expectsCSS) {\\r\\n        removeTransitionClass(el, leaveClass);\\r\\n      }\\r\\n      leaveCancelled && leaveCancelled(el);\\r\\n    } else {\\r\\n      rm();\\r\\n      afterLeave && afterLeave(el);\\r\\n    }\\r\\n    el._leaveCb = null;\\r\\n  });\\r\\n\\r\\n  if (delayLeave) {\\r\\n    delayLeave(performLeave);\\r\\n  } else {\\r\\n    performLeave();\\r\\n  }\\r\\n\\r\\n  function performLeave () {\\r\\n    // the delayed leave may have already been cancelled\\r\\n    if (cb.cancelled) {\\r\\n      return\\r\\n    }\\r\\n    // record leaving element\\r\\n    if (!vnode.data.show && el.parentNode) {\\r\\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\\r\\n    }\\r\\n    beforeLeave && beforeLeave(el);\\r\\n    if (expectsCSS) {\\r\\n      addTransitionClass(el, leaveClass);\\r\\n      addTransitionClass(el, leaveActiveClass);\\r\\n      nextFrame(function () {\\r\\n        removeTransitionClass(el, leaveClass);\\r\\n        if (!cb.cancelled) {\\r\\n          addTransitionClass(el, leaveToClass);\\r\\n          if (!userWantsControl) {\\r\\n            if (isValidDuration(explicitLeaveDuration)) {\\r\\n              setTimeout(cb, explicitLeaveDuration);\\r\\n            } else {\\r\\n              whenTransitionEnds(el, type, cb);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n    leave && leave(el, cb);\\r\\n    if (!expectsCSS && !userWantsControl) {\\r\\n      cb();\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// only used in dev mode\\r\\nfunction checkDuration (val, name, vnode) {\\r\\n  if (typeof val !== 'number') {\\r\\n    warn(\\r\\n      \\\"<transition> explicit \\\" + name + \\\" duration is not a valid number - \\\" +\\r\\n      \\\"got \\\" + (JSON.stringify(val)) + \\\".\\\",\\r\\n      vnode.context\\r\\n    );\\r\\n  } else if (isNaN(val)) {\\r\\n    warn(\\r\\n      \\\"<transition> explicit \\\" + name + \\\" duration is NaN - \\\" +\\r\\n      'the duration expression might be incorrect.',\\r\\n      vnode.context\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isValidDuration (val) {\\r\\n  return typeof val === 'number' && !isNaN(val)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Normalize a transition hook's argument length. The hook may be:\\r\\n * - a merged hook (invoker) with the original in .fns\\r\\n * - a wrapped component method (check ._length)\\r\\n * - a plain function (.length)\\r\\n */\\r\\nfunction getHookArgumentsLength (fn) {\\r\\n  if (isUndef(fn)) {\\r\\n    return false\\r\\n  }\\r\\n  var invokerFns = fn.fns;\\r\\n  if (isDef(invokerFns)) {\\r\\n    // invoker\\r\\n    return getHookArgumentsLength(\\r\\n      Array.isArray(invokerFns)\\r\\n        ? invokerFns[0]\\r\\n        : invokerFns\\r\\n    )\\r\\n  } else {\\r\\n    return (fn._length || fn.length) > 1\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction _enter (_, vnode) {\\r\\n  if (vnode.data.show !== true) {\\r\\n    enter(vnode);\\r\\n  }\\r\\n}\\r\\n\\r\\nvar transition = inBrowser ? {\\r\\n  create: _enter,\\r\\n  activate: _enter,\\r\\n  remove: function remove$$1 (vnode, rm) {\\r\\n    /* istanbul ignore else */\\r\\n    if (vnode.data.show !== true) {\\r\\n      leave(vnode, rm);\\r\\n    } else {\\r\\n      rm();\\r\\n    }\\r\\n  }\\r\\n} : {};\\r\\n\\r\\nvar platformModules = [\\r\\n  attrs,\\r\\n  klass,\\r\\n  events,\\r\\n  domProps,\\r\\n  style,\\r\\n  transition\\r\\n];\\r\\n\\r\\n/*  */\\r\\n\\r\\n// the directive module should be applied last, after all\\r\\n// built-in modules have been applied.\\r\\nvar modules = platformModules.concat(baseModules);\\r\\n\\r\\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\\r\\n\\r\\n/**\\r\\n * Not type checking this file because flow doesn't like attaching\\r\\n * properties to Elements.\\r\\n */\\r\\n\\r\\n/* istanbul ignore if */\\r\\nif (isIE9) {\\r\\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\\r\\n  document.addEventListener('selectionchange', function () {\\r\\n    var el = document.activeElement;\\r\\n    if (el && el.vmodel) {\\r\\n      trigger(el, 'input');\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\nvar directive = {\\r\\n  inserted: function inserted (el, binding, vnode, oldVnode) {\\r\\n    if (vnode.tag === 'select') {\\r\\n      // #6903\\r\\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\\r\\n        mergeVNodeHook(vnode, 'postpatch', function () {\\r\\n          directive.componentUpdated(el, binding, vnode);\\r\\n        });\\r\\n      } else {\\r\\n        setSelected(el, binding, vnode.context);\\r\\n      }\\r\\n      el._vOptions = [].map.call(el.options, getValue);\\r\\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\\r\\n      el._vModifiers = binding.modifiers;\\r\\n      if (!binding.modifiers.lazy) {\\r\\n        el.addEventListener('compositionstart', onCompositionStart);\\r\\n        el.addEventListener('compositionend', onCompositionEnd);\\r\\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\\r\\n        // switching focus before confirming composition choice\\r\\n        // this also fixes the issue where some browsers e.g. iOS Chrome\\r\\n        // fires \\\"change\\\" instead of \\\"input\\\" on autocomplete.\\r\\n        el.addEventListener('change', onCompositionEnd);\\r\\n        /* istanbul ignore if */\\r\\n        if (isIE9) {\\r\\n          el.vmodel = true;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n\\r\\n  componentUpdated: function componentUpdated (el, binding, vnode) {\\r\\n    if (vnode.tag === 'select') {\\r\\n      setSelected(el, binding, vnode.context);\\r\\n      // in case the options rendered by v-for have changed,\\r\\n      // it's possible that the value is out-of-sync with the rendered options.\\r\\n      // detect such cases and filter out values that no longer has a matching\\r\\n      // option in the DOM.\\r\\n      var prevOptions = el._vOptions;\\r\\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\\r\\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\\r\\n        // trigger change event if\\r\\n        // no matching option found for at least one value\\r\\n        var needReset = el.multiple\\r\\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\\r\\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\\r\\n        if (needReset) {\\r\\n          trigger(el, 'change');\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction setSelected (el, binding, vm) {\\r\\n  actuallySetSelected(el, binding, vm);\\r\\n  /* istanbul ignore if */\\r\\n  if (isIE || isEdge) {\\r\\n    setTimeout(function () {\\r\\n      actuallySetSelected(el, binding, vm);\\r\\n    }, 0);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction actuallySetSelected (el, binding, vm) {\\r\\n  var value = binding.value;\\r\\n  var isMultiple = el.multiple;\\r\\n  if (isMultiple && !Array.isArray(value)) {\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      \\\"<select multiple v-model=\\\\\\\"\\\" + (binding.expression) + \\\"\\\\\\\"> \\\" +\\r\\n      \\\"expects an Array value for its binding, but got \\\" + (Object.prototype.toString.call(value).slice(8, -1)),\\r\\n      vm\\r\\n    );\\r\\n    return\\r\\n  }\\r\\n  var selected, option;\\r\\n  for (var i = 0, l = el.options.length; i < l; i++) {\\r\\n    option = el.options[i];\\r\\n    if (isMultiple) {\\r\\n      selected = looseIndexOf(value, getValue(option)) > -1;\\r\\n      if (option.selected !== selected) {\\r\\n        option.selected = selected;\\r\\n      }\\r\\n    } else {\\r\\n      if (looseEqual(getValue(option), value)) {\\r\\n        if (el.selectedIndex !== i) {\\r\\n          el.selectedIndex = i;\\r\\n        }\\r\\n        return\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  if (!isMultiple) {\\r\\n    el.selectedIndex = -1;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction hasNoMatchingOption (value, options) {\\r\\n  return options.every(function (o) { return !looseEqual(o, value); })\\r\\n}\\r\\n\\r\\nfunction getValue (option) {\\r\\n  return '_value' in option\\r\\n    ? option._value\\r\\n    : option.value\\r\\n}\\r\\n\\r\\nfunction onCompositionStart (e) {\\r\\n  e.target.composing = true;\\r\\n}\\r\\n\\r\\nfunction onCompositionEnd (e) {\\r\\n  // prevent triggering an input event for no reason\\r\\n  if (!e.target.composing) { return }\\r\\n  e.target.composing = false;\\r\\n  trigger(e.target, 'input');\\r\\n}\\r\\n\\r\\nfunction trigger (el, type) {\\r\\n  var e = document.createEvent('HTMLEvents');\\r\\n  e.initEvent(type, true, true);\\r\\n  el.dispatchEvent(e);\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// recursively search for possible transition defined inside the component root\\r\\nfunction locateNode (vnode) {\\r\\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\\r\\n    ? locateNode(vnode.componentInstance._vnode)\\r\\n    : vnode\\r\\n}\\r\\n\\r\\nvar show = {\\r\\n  bind: function bind (el, ref, vnode) {\\r\\n    var value = ref.value;\\r\\n\\r\\n    vnode = locateNode(vnode);\\r\\n    var transition$$1 = vnode.data && vnode.data.transition;\\r\\n    var originalDisplay = el.__vOriginalDisplay =\\r\\n      el.style.display === 'none' ? '' : el.style.display;\\r\\n    if (value && transition$$1) {\\r\\n      vnode.data.show = true;\\r\\n      enter(vnode, function () {\\r\\n        el.style.display = originalDisplay;\\r\\n      });\\r\\n    } else {\\r\\n      el.style.display = value ? originalDisplay : 'none';\\r\\n    }\\r\\n  },\\r\\n\\r\\n  update: function update (el, ref, vnode) {\\r\\n    var value = ref.value;\\r\\n    var oldValue = ref.oldValue;\\r\\n\\r\\n    /* istanbul ignore if */\\r\\n    if (!value === !oldValue) { return }\\r\\n    vnode = locateNode(vnode);\\r\\n    var transition$$1 = vnode.data && vnode.data.transition;\\r\\n    if (transition$$1) {\\r\\n      vnode.data.show = true;\\r\\n      if (value) {\\r\\n        enter(vnode, function () {\\r\\n          el.style.display = el.__vOriginalDisplay;\\r\\n        });\\r\\n      } else {\\r\\n        leave(vnode, function () {\\r\\n          el.style.display = 'none';\\r\\n        });\\r\\n      }\\r\\n    } else {\\r\\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\\r\\n    }\\r\\n  },\\r\\n\\r\\n  unbind: function unbind (\\r\\n    el,\\r\\n    binding,\\r\\n    vnode,\\r\\n    oldVnode,\\r\\n    isDestroy\\r\\n  ) {\\r\\n    if (!isDestroy) {\\r\\n      el.style.display = el.__vOriginalDisplay;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nvar platformDirectives = {\\r\\n  model: directive,\\r\\n  show: show\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar transitionProps = {\\r\\n  name: String,\\r\\n  appear: Boolean,\\r\\n  css: Boolean,\\r\\n  mode: String,\\r\\n  type: String,\\r\\n  enterClass: String,\\r\\n  leaveClass: String,\\r\\n  enterToClass: String,\\r\\n  leaveToClass: String,\\r\\n  enterActiveClass: String,\\r\\n  leaveActiveClass: String,\\r\\n  appearClass: String,\\r\\n  appearActiveClass: String,\\r\\n  appearToClass: String,\\r\\n  duration: [Number, String, Object]\\r\\n};\\r\\n\\r\\n// in case the child is also an abstract component, e.g. <keep-alive>\\r\\n// we want to recursively retrieve the real component to be rendered\\r\\nfunction getRealChild (vnode) {\\r\\n  var compOptions = vnode && vnode.componentOptions;\\r\\n  if (compOptions && compOptions.Ctor.options.abstract) {\\r\\n    return getRealChild(getFirstComponentChild(compOptions.children))\\r\\n  } else {\\r\\n    return vnode\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction extractTransitionData (comp) {\\r\\n  var data = {};\\r\\n  var options = comp.$options;\\r\\n  // props\\r\\n  for (var key in options.propsData) {\\r\\n    data[key] = comp[key];\\r\\n  }\\r\\n  // events.\\r\\n  // extract listeners and pass them directly to the transition methods\\r\\n  var listeners = options._parentListeners;\\r\\n  for (var key$1 in listeners) {\\r\\n    data[camelize(key$1)] = listeners[key$1];\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\nfunction placeholder (h, rawChild) {\\r\\n  if (/\\\\d-keep-alive$/.test(rawChild.tag)) {\\r\\n    return h('keep-alive', {\\r\\n      props: rawChild.componentOptions.propsData\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction hasParentTransition (vnode) {\\r\\n  while ((vnode = vnode.parent)) {\\r\\n    if (vnode.data.transition) {\\r\\n      return true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isSameChild (child, oldChild) {\\r\\n  return oldChild.key === child.key && oldChild.tag === child.tag\\r\\n}\\r\\n\\r\\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\\r\\n\\r\\nvar isVShowDirective = function (d) { return d.name === 'show'; };\\r\\n\\r\\nvar Transition = {\\r\\n  name: 'transition',\\r\\n  props: transitionProps,\\r\\n  abstract: true,\\r\\n\\r\\n  render: function render (h) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var children = this.$slots.default;\\r\\n    if (!children) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    // filter out text nodes (possible whitespaces)\\r\\n    children = children.filter(isNotTextNode);\\r\\n    /* istanbul ignore if */\\r\\n    if (!children.length) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    // warn multiple elements\\r\\n    if (false) {}\\r\\n\\r\\n    var mode = this.mode;\\r\\n\\r\\n    // warn invalid mode\\r\\n    if (false\\r\\n    ) {}\\r\\n\\r\\n    var rawChild = children[0];\\r\\n\\r\\n    // if this is a component root node and the component's\\r\\n    // parent container node also has transition, skip.\\r\\n    if (hasParentTransition(this.$vnode)) {\\r\\n      return rawChild\\r\\n    }\\r\\n\\r\\n    // apply transition data to child\\r\\n    // use getRealChild() to ignore abstract components e.g. keep-alive\\r\\n    var child = getRealChild(rawChild);\\r\\n    /* istanbul ignore if */\\r\\n    if (!child) {\\r\\n      return rawChild\\r\\n    }\\r\\n\\r\\n    if (this._leaving) {\\r\\n      return placeholder(h, rawChild)\\r\\n    }\\r\\n\\r\\n    // ensure a key that is unique to the vnode type and to this transition\\r\\n    // component instance. This key will be used to remove pending leaving nodes\\r\\n    // during entering.\\r\\n    var id = \\\"__transition-\\\" + (this._uid) + \\\"-\\\";\\r\\n    child.key = child.key == null\\r\\n      ? child.isComment\\r\\n        ? id + 'comment'\\r\\n        : id + child.tag\\r\\n      : isPrimitive(child.key)\\r\\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\\r\\n        : child.key;\\r\\n\\r\\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\\r\\n    var oldRawChild = this._vnode;\\r\\n    var oldChild = getRealChild(oldRawChild);\\r\\n\\r\\n    // mark v-show\\r\\n    // so that the transition module can hand over the control to the directive\\r\\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\\r\\n      child.data.show = true;\\r\\n    }\\r\\n\\r\\n    if (\\r\\n      oldChild &&\\r\\n      oldChild.data &&\\r\\n      !isSameChild(child, oldChild) &&\\r\\n      !isAsyncPlaceholder(oldChild) &&\\r\\n      // #6687 component root is a comment node\\r\\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\\r\\n    ) {\\r\\n      // replace old child transition data with fresh one\\r\\n      // important for dynamic transitions!\\r\\n      var oldData = oldChild.data.transition = extend({}, data);\\r\\n      // handle transition mode\\r\\n      if (mode === 'out-in') {\\r\\n        // return placeholder node and queue update when leave finishes\\r\\n        this._leaving = true;\\r\\n        mergeVNodeHook(oldData, 'afterLeave', function () {\\r\\n          this$1._leaving = false;\\r\\n          this$1.$forceUpdate();\\r\\n        });\\r\\n        return placeholder(h, rawChild)\\r\\n      } else if (mode === 'in-out') {\\r\\n        if (isAsyncPlaceholder(child)) {\\r\\n          return oldRawChild\\r\\n        }\\r\\n        var delayedLeave;\\r\\n        var performLeave = function () { delayedLeave(); };\\r\\n        mergeVNodeHook(data, 'afterEnter', performLeave);\\r\\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\\r\\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return rawChild\\r\\n  }\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar props = extend({\\r\\n  tag: String,\\r\\n  moveClass: String\\r\\n}, transitionProps);\\r\\n\\r\\ndelete props.mode;\\r\\n\\r\\nvar TransitionGroup = {\\r\\n  props: props,\\r\\n\\r\\n  beforeMount: function beforeMount () {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var update = this._update;\\r\\n    this._update = function (vnode, hydrating) {\\r\\n      var restoreActiveInstance = setActiveInstance(this$1);\\r\\n      // force removing pass\\r\\n      this$1.__patch__(\\r\\n        this$1._vnode,\\r\\n        this$1.kept,\\r\\n        false, // hydrating\\r\\n        true // removeOnly (!important, avoids unnecessary moves)\\r\\n      );\\r\\n      this$1._vnode = this$1.kept;\\r\\n      restoreActiveInstance();\\r\\n      update.call(this$1, vnode, hydrating);\\r\\n    };\\r\\n  },\\r\\n\\r\\n  render: function render (h) {\\r\\n    var tag = this.tag || this.$vnode.data.tag || 'span';\\r\\n    var map = Object.create(null);\\r\\n    var prevChildren = this.prevChildren = this.children;\\r\\n    var rawChildren = this.$slots.default || [];\\r\\n    var children = this.children = [];\\r\\n    var transitionData = extractTransitionData(this);\\r\\n\\r\\n    for (var i = 0; i < rawChildren.length; i++) {\\r\\n      var c = rawChildren[i];\\r\\n      if (c.tag) {\\r\\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\\r\\n          children.push(c);\\r\\n          map[c.key] = c\\r\\n          ;(c.data || (c.data = {})).transition = transitionData;\\r\\n        } else if (false) { var name, opts; }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (prevChildren) {\\r\\n      var kept = [];\\r\\n      var removed = [];\\r\\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\\r\\n        var c$1 = prevChildren[i$1];\\r\\n        c$1.data.transition = transitionData;\\r\\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\\r\\n        if (map[c$1.key]) {\\r\\n          kept.push(c$1);\\r\\n        } else {\\r\\n          removed.push(c$1);\\r\\n        }\\r\\n      }\\r\\n      this.kept = h(tag, null, kept);\\r\\n      this.removed = removed;\\r\\n    }\\r\\n\\r\\n    return h(tag, null, children)\\r\\n  },\\r\\n\\r\\n  updated: function updated () {\\r\\n    var children = this.prevChildren;\\r\\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\\r\\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    // we divide the work into three loops to avoid mixing DOM reads and writes\\r\\n    // in each iteration - which helps prevent layout thrashing.\\r\\n    children.forEach(callPendingCbs);\\r\\n    children.forEach(recordPosition);\\r\\n    children.forEach(applyTranslation);\\r\\n\\r\\n    // force reflow to put everything in position\\r\\n    // assign to this to avoid being removed in tree-shaking\\r\\n    // $flow-disable-line\\r\\n    this._reflow = document.body.offsetHeight;\\r\\n\\r\\n    children.forEach(function (c) {\\r\\n      if (c.data.moved) {\\r\\n        var el = c.elm;\\r\\n        var s = el.style;\\r\\n        addTransitionClass(el, moveClass);\\r\\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\\r\\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\\r\\n          if (e && e.target !== el) {\\r\\n            return\\r\\n          }\\r\\n          if (!e || /transform$/.test(e.propertyName)) {\\r\\n            el.removeEventListener(transitionEndEvent, cb);\\r\\n            el._moveCb = null;\\r\\n            removeTransitionClass(el, moveClass);\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n    });\\r\\n  },\\r\\n\\r\\n  methods: {\\r\\n    hasMove: function hasMove (el, moveClass) {\\r\\n      /* istanbul ignore if */\\r\\n      if (!hasTransition) {\\r\\n        return false\\r\\n      }\\r\\n      /* istanbul ignore if */\\r\\n      if (this._hasMove) {\\r\\n        return this._hasMove\\r\\n      }\\r\\n      // Detect whether an element with the move class applied has\\r\\n      // CSS transitions. Since the element may be inside an entering\\r\\n      // transition at this very moment, we make a clone of it and remove\\r\\n      // all other transition classes applied to ensure only the move class\\r\\n      // is applied.\\r\\n      var clone = el.cloneNode();\\r\\n      if (el._transitionClasses) {\\r\\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\\r\\n      }\\r\\n      addClass(clone, moveClass);\\r\\n      clone.style.display = 'none';\\r\\n      this.$el.appendChild(clone);\\r\\n      var info = getTransitionInfo(clone);\\r\\n      this.$el.removeChild(clone);\\r\\n      return (this._hasMove = info.hasTransform)\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction callPendingCbs (c) {\\r\\n  /* istanbul ignore if */\\r\\n  if (c.elm._moveCb) {\\r\\n    c.elm._moveCb();\\r\\n  }\\r\\n  /* istanbul ignore if */\\r\\n  if (c.elm._enterCb) {\\r\\n    c.elm._enterCb();\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction recordPosition (c) {\\r\\n  c.data.newPos = c.elm.getBoundingClientRect();\\r\\n}\\r\\n\\r\\nfunction applyTranslation (c) {\\r\\n  var oldPos = c.data.pos;\\r\\n  var newPos = c.data.newPos;\\r\\n  var dx = oldPos.left - newPos.left;\\r\\n  var dy = oldPos.top - newPos.top;\\r\\n  if (dx || dy) {\\r\\n    c.data.moved = true;\\r\\n    var s = c.elm.style;\\r\\n    s.transform = s.WebkitTransform = \\\"translate(\\\" + dx + \\\"px,\\\" + dy + \\\"px)\\\";\\r\\n    s.transitionDuration = '0s';\\r\\n  }\\r\\n}\\r\\n\\r\\nvar platformComponents = {\\r\\n  Transition: Transition,\\r\\n  TransitionGroup: TransitionGroup\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\n// install platform specific utils\\r\\nVue.config.mustUseProp = mustUseProp;\\r\\nVue.config.isReservedTag = isReservedTag;\\r\\nVue.config.isReservedAttr = isReservedAttr;\\r\\nVue.config.getTagNamespace = getTagNamespace;\\r\\nVue.config.isUnknownElement = isUnknownElement;\\r\\n\\r\\n// install platform runtime directives & components\\r\\nextend(Vue.options.directives, platformDirectives);\\r\\nextend(Vue.options.components, platformComponents);\\r\\n\\r\\n// install platform patch function\\r\\nVue.prototype.__patch__ = inBrowser ? patch : noop;\\r\\n\\r\\n// public mount method\\r\\nVue.prototype.$mount = function (\\r\\n  el,\\r\\n  hydrating\\r\\n) {\\r\\n  el = el && inBrowser ? query(el) : undefined;\\r\\n  return mountComponent(this, el, hydrating)\\r\\n};\\r\\n\\r\\n// devtools global hook\\r\\n/* istanbul ignore next */\\r\\nif (inBrowser) {\\r\\n  setTimeout(function () {\\r\\n    if (config.devtools) {\\r\\n      if (devtools) {\\r\\n        devtools.emit('init', Vue);\\r\\n      } else if (\\r\\n        false\\r\\n      ) {}\\r\\n    }\\r\\n    if (false\\r\\n    ) {}\\r\\n  }, 0);\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar defaultTagRE = /\\\\{\\\\{((?:.|\\\\r?\\\\n)+?)\\\\}\\\\}/g;\\r\\nvar regexEscapeRE = /[-.*+?^${}()|[\\\\]\\\\/\\\\\\\\]/g;\\r\\n\\r\\nvar buildRegex = cached(function (delimiters) {\\r\\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\\\\\$&');\\r\\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\\\\\$&');\\r\\n  return new RegExp(open + '((?:.|\\\\\\\\n)+?)' + close, 'g')\\r\\n});\\r\\n\\r\\n\\r\\n\\r\\nfunction parseText (\\r\\n  text,\\r\\n  delimiters\\r\\n) {\\r\\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\\r\\n  if (!tagRE.test(text)) {\\r\\n    return\\r\\n  }\\r\\n  var tokens = [];\\r\\n  var rawTokens = [];\\r\\n  var lastIndex = tagRE.lastIndex = 0;\\r\\n  var match, index, tokenValue;\\r\\n  while ((match = tagRE.exec(text))) {\\r\\n    index = match.index;\\r\\n    // push text token\\r\\n    if (index > lastIndex) {\\r\\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\\r\\n      tokens.push(JSON.stringify(tokenValue));\\r\\n    }\\r\\n    // tag token\\r\\n    var exp = parseFilters(match[1].trim());\\r\\n    tokens.push((\\\"_s(\\\" + exp + \\\")\\\"));\\r\\n    rawTokens.push({ '@binding': exp });\\r\\n    lastIndex = index + match[0].length;\\r\\n  }\\r\\n  if (lastIndex < text.length) {\\r\\n    rawTokens.push(tokenValue = text.slice(lastIndex));\\r\\n    tokens.push(JSON.stringify(tokenValue));\\r\\n  }\\r\\n  return {\\r\\n    expression: tokens.join('+'),\\r\\n    tokens: rawTokens\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction transformNode (el, options) {\\r\\n  var warn = options.warn || baseWarn;\\r\\n  var staticClass = getAndRemoveAttr(el, 'class');\\r\\n  if (false) { var res; }\\r\\n  if (staticClass) {\\r\\n    el.staticClass = JSON.stringify(staticClass);\\r\\n  }\\r\\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\\r\\n  if (classBinding) {\\r\\n    el.classBinding = classBinding;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genData (el) {\\r\\n  var data = '';\\r\\n  if (el.staticClass) {\\r\\n    data += \\\"staticClass:\\\" + (el.staticClass) + \\\",\\\";\\r\\n  }\\r\\n  if (el.classBinding) {\\r\\n    data += \\\"class:\\\" + (el.classBinding) + \\\",\\\";\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\nvar klass$1 = {\\r\\n  staticKeys: ['staticClass'],\\r\\n  transformNode: transformNode,\\r\\n  genData: genData\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction transformNode$1 (el, options) {\\r\\n  var warn = options.warn || baseWarn;\\r\\n  var staticStyle = getAndRemoveAttr(el, 'style');\\r\\n  if (staticStyle) {\\r\\n    /* istanbul ignore if */\\r\\n    if (false) { var res; }\\r\\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\\r\\n  }\\r\\n\\r\\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\\r\\n  if (styleBinding) {\\r\\n    el.styleBinding = styleBinding;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genData$1 (el) {\\r\\n  var data = '';\\r\\n  if (el.staticStyle) {\\r\\n    data += \\\"staticStyle:\\\" + (el.staticStyle) + \\\",\\\";\\r\\n  }\\r\\n  if (el.styleBinding) {\\r\\n    data += \\\"style:(\\\" + (el.styleBinding) + \\\"),\\\";\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\nvar style$1 = {\\r\\n  staticKeys: ['staticStyle'],\\r\\n  transformNode: transformNode$1,\\r\\n  genData: genData$1\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar decoder;\\r\\n\\r\\nvar he = {\\r\\n  decode: function decode (html) {\\r\\n    decoder = decoder || document.createElement('div');\\r\\n    decoder.innerHTML = html;\\r\\n    return decoder.textContent\\r\\n  }\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar isUnaryTag = makeMap(\\r\\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\\r\\n  'link,meta,param,source,track,wbr'\\r\\n);\\r\\n\\r\\n// Elements that you can, intentionally, leave open\\r\\n// (and which close themselves)\\r\\nvar canBeLeftOpenTag = makeMap(\\r\\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\\r\\n);\\r\\n\\r\\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\\r\\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\\r\\nvar isNonPhrasingTag = makeMap(\\r\\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\\r\\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\\r\\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\\r\\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\\r\\n  'title,tr,track'\\r\\n);\\r\\n\\r\\n/**\\r\\n * Not type-checking this file because it's mostly vendor code.\\r\\n */\\r\\n\\r\\n// Regular Expressions for parsing tags and attributes\\r\\nvar attribute = /^\\\\s*([^\\\\s\\\"'<>\\\\/=]+)(?:\\\\s*(=)\\\\s*(?:\\\"([^\\\"]*)\\\"+|'([^']*)'+|([^\\\\s\\\"'=<>`]+)))?/;\\r\\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\\r\\n// but for Vue templates we can enforce a simple charset\\r\\nvar ncname = '[a-zA-Z_][\\\\\\\\w\\\\\\\\-\\\\\\\\.]*';\\r\\nvar qnameCapture = \\\"((?:\\\" + ncname + \\\"\\\\\\\\:)?\\\" + ncname + \\\")\\\";\\r\\nvar startTagOpen = new RegExp((\\\"^<\\\" + qnameCapture));\\r\\nvar startTagClose = /^\\\\s*(\\\\/?)>/;\\r\\nvar endTag = new RegExp((\\\"^<\\\\\\\\/\\\" + qnameCapture + \\\"[^>]*>\\\"));\\r\\nvar doctype = /^<!DOCTYPE [^>]+>/i;\\r\\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\\r\\nvar comment = /^<!\\\\--/;\\r\\nvar conditionalComment = /^<!\\\\[/;\\r\\n\\r\\n// Special Elements (can contain anything)\\r\\nvar isPlainTextElement = makeMap('script,style,textarea', true);\\r\\nvar reCache = {};\\r\\n\\r\\nvar decodingMap = {\\r\\n  '&lt;': '<',\\r\\n  '&gt;': '>',\\r\\n  '&quot;': '\\\"',\\r\\n  '&amp;': '&',\\r\\n  '&#10;': '\\\\n',\\r\\n  '&#9;': '\\\\t'\\r\\n};\\r\\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\\r\\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\\r\\n\\r\\n// #5992\\r\\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\\r\\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\\\n'; };\\r\\n\\r\\nfunction decodeAttr (value, shouldDecodeNewlines) {\\r\\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\\r\\n  return value.replace(re, function (match) { return decodingMap[match]; })\\r\\n}\\r\\n\\r\\nfunction parseHTML (html, options) {\\r\\n  var stack = [];\\r\\n  var expectHTML = options.expectHTML;\\r\\n  var isUnaryTag$$1 = options.isUnaryTag || no;\\r\\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\\r\\n  var index = 0;\\r\\n  var last, lastTag;\\r\\n  while (html) {\\r\\n    last = html;\\r\\n    // Make sure we're not in a plaintext content element like script/style\\r\\n    if (!lastTag || !isPlainTextElement(lastTag)) {\\r\\n      var textEnd = html.indexOf('<');\\r\\n      if (textEnd === 0) {\\r\\n        // Comment:\\r\\n        if (comment.test(html)) {\\r\\n          var commentEnd = html.indexOf('--\\x3e');\\r\\n\\r\\n          if (commentEnd >= 0) {\\r\\n            if (options.shouldKeepComment) {\\r\\n              options.comment(html.substring(4, commentEnd));\\r\\n            }\\r\\n            advance(commentEnd + 3);\\r\\n            continue\\r\\n          }\\r\\n        }\\r\\n\\r\\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\\r\\n        if (conditionalComment.test(html)) {\\r\\n          var conditionalEnd = html.indexOf(']>');\\r\\n\\r\\n          if (conditionalEnd >= 0) {\\r\\n            advance(conditionalEnd + 2);\\r\\n            continue\\r\\n          }\\r\\n        }\\r\\n\\r\\n        // Doctype:\\r\\n        var doctypeMatch = html.match(doctype);\\r\\n        if (doctypeMatch) {\\r\\n          advance(doctypeMatch[0].length);\\r\\n          continue\\r\\n        }\\r\\n\\r\\n        // End tag:\\r\\n        var endTagMatch = html.match(endTag);\\r\\n        if (endTagMatch) {\\r\\n          var curIndex = index;\\r\\n          advance(endTagMatch[0].length);\\r\\n          parseEndTag(endTagMatch[1], curIndex, index);\\r\\n          continue\\r\\n        }\\r\\n\\r\\n        // Start tag:\\r\\n        var startTagMatch = parseStartTag();\\r\\n        if (startTagMatch) {\\r\\n          handleStartTag(startTagMatch);\\r\\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\\r\\n            advance(1);\\r\\n          }\\r\\n          continue\\r\\n        }\\r\\n      }\\r\\n\\r\\n      var text = (void 0), rest = (void 0), next = (void 0);\\r\\n      if (textEnd >= 0) {\\r\\n        rest = html.slice(textEnd);\\r\\n        while (\\r\\n          !endTag.test(rest) &&\\r\\n          !startTagOpen.test(rest) &&\\r\\n          !comment.test(rest) &&\\r\\n          !conditionalComment.test(rest)\\r\\n        ) {\\r\\n          // < in plain text, be forgiving and treat it as text\\r\\n          next = rest.indexOf('<', 1);\\r\\n          if (next < 0) { break }\\r\\n          textEnd += next;\\r\\n          rest = html.slice(textEnd);\\r\\n        }\\r\\n        text = html.substring(0, textEnd);\\r\\n        advance(textEnd);\\r\\n      }\\r\\n\\r\\n      if (textEnd < 0) {\\r\\n        text = html;\\r\\n        html = '';\\r\\n      }\\r\\n\\r\\n      if (options.chars && text) {\\r\\n        options.chars(text);\\r\\n      }\\r\\n    } else {\\r\\n      var endTagLength = 0;\\r\\n      var stackedTag = lastTag.toLowerCase();\\r\\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\\\\\s\\\\\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\\r\\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\\r\\n        endTagLength = endTag.length;\\r\\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\\r\\n          text = text\\r\\n            .replace(/<!\\\\--([\\\\s\\\\S]*?)--\\x3e/g, '$1') // #7298\\r\\n            .replace(/<!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)]]>/g, '$1');\\r\\n        }\\r\\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\\r\\n          text = text.slice(1);\\r\\n        }\\r\\n        if (options.chars) {\\r\\n          options.chars(text);\\r\\n        }\\r\\n        return ''\\r\\n      });\\r\\n      index += html.length - rest$1.length;\\r\\n      html = rest$1;\\r\\n      parseEndTag(stackedTag, index - endTagLength, index);\\r\\n    }\\r\\n\\r\\n    if (html === last) {\\r\\n      options.chars && options.chars(html);\\r\\n      if (false) {}\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Clean up any remaining tags\\r\\n  parseEndTag();\\r\\n\\r\\n  function advance (n) {\\r\\n    index += n;\\r\\n    html = html.substring(n);\\r\\n  }\\r\\n\\r\\n  function parseStartTag () {\\r\\n    var start = html.match(startTagOpen);\\r\\n    if (start) {\\r\\n      var match = {\\r\\n        tagName: start[1],\\r\\n        attrs: [],\\r\\n        start: index\\r\\n      };\\r\\n      advance(start[0].length);\\r\\n      var end, attr;\\r\\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\\r\\n        advance(attr[0].length);\\r\\n        match.attrs.push(attr);\\r\\n      }\\r\\n      if (end) {\\r\\n        match.unarySlash = end[1];\\r\\n        advance(end[0].length);\\r\\n        match.end = index;\\r\\n        return match\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handleStartTag (match) {\\r\\n    var tagName = match.tagName;\\r\\n    var unarySlash = match.unarySlash;\\r\\n\\r\\n    if (expectHTML) {\\r\\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\\r\\n        parseEndTag(lastTag);\\r\\n      }\\r\\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\\r\\n        parseEndTag(tagName);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\\r\\n\\r\\n    var l = match.attrs.length;\\r\\n    var attrs = new Array(l);\\r\\n    for (var i = 0; i < l; i++) {\\r\\n      var args = match.attrs[i];\\r\\n      var value = args[3] || args[4] || args[5] || '';\\r\\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\\r\\n        ? options.shouldDecodeNewlinesForHref\\r\\n        : options.shouldDecodeNewlines;\\r\\n      attrs[i] = {\\r\\n        name: args[1],\\r\\n        value: decodeAttr(value, shouldDecodeNewlines)\\r\\n      };\\r\\n    }\\r\\n\\r\\n    if (!unary) {\\r\\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\\r\\n      lastTag = tagName;\\r\\n    }\\r\\n\\r\\n    if (options.start) {\\r\\n      options.start(tagName, attrs, unary, match.start, match.end);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function parseEndTag (tagName, start, end) {\\r\\n    var pos, lowerCasedTagName;\\r\\n    if (start == null) { start = index; }\\r\\n    if (end == null) { end = index; }\\r\\n\\r\\n    // Find the closest opened tag of the same type\\r\\n    if (tagName) {\\r\\n      lowerCasedTagName = tagName.toLowerCase();\\r\\n      for (pos = stack.length - 1; pos >= 0; pos--) {\\r\\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\\r\\n          break\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      // If no tag name is provided, clean shop\\r\\n      pos = 0;\\r\\n    }\\r\\n\\r\\n    if (pos >= 0) {\\r\\n      // Close all the open elements, up the stack\\r\\n      for (var i = stack.length - 1; i >= pos; i--) {\\r\\n        if (false\\r\\n        ) {}\\r\\n        if (options.end) {\\r\\n          options.end(stack[i].tag, start, end);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Remove the open elements from the stack\\r\\n      stack.length = pos;\\r\\n      lastTag = pos && stack[pos - 1].tag;\\r\\n    } else if (lowerCasedTagName === 'br') {\\r\\n      if (options.start) {\\r\\n        options.start(tagName, [], true, start, end);\\r\\n      }\\r\\n    } else if (lowerCasedTagName === 'p') {\\r\\n      if (options.start) {\\r\\n        options.start(tagName, [], false, start, end);\\r\\n      }\\r\\n      if (options.end) {\\r\\n        options.end(tagName, start, end);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar onRE = /^@|^v-on:/;\\r\\nvar dirRE = /^v-|^@|^:/;\\r\\nvar forAliasRE = /([\\\\s\\\\S]*?)\\\\s+(?:in|of)\\\\s+([\\\\s\\\\S]*)/;\\r\\nvar forIteratorRE = /,([^,\\\\}\\\\]]*)(?:,([^,\\\\}\\\\]]*))?$/;\\r\\nvar stripParensRE = /^\\\\(|\\\\)$/g;\\r\\n\\r\\nvar argRE = /:(.*)$/;\\r\\nvar bindRE = /^:|^v-bind:/;\\r\\nvar modifierRE = /\\\\.[^.]+/g;\\r\\n\\r\\nvar decodeHTMLCached = cached(he.decode);\\r\\n\\r\\n// configurable state\\r\\nvar warn$2;\\r\\nvar delimiters;\\r\\nvar transforms;\\r\\nvar preTransforms;\\r\\nvar postTransforms;\\r\\nvar platformIsPreTag;\\r\\nvar platformMustUseProp;\\r\\nvar platformGetTagNamespace;\\r\\n\\r\\n\\r\\n\\r\\nfunction createASTElement (\\r\\n  tag,\\r\\n  attrs,\\r\\n  parent\\r\\n) {\\r\\n  return {\\r\\n    type: 1,\\r\\n    tag: tag,\\r\\n    attrsList: attrs,\\r\\n    attrsMap: makeAttrsMap(attrs),\\r\\n    parent: parent,\\r\\n    children: []\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Convert HTML string to AST.\\r\\n */\\r\\nfunction parse (\\r\\n  template,\\r\\n  options\\r\\n) {\\r\\n  warn$2 = options.warn || baseWarn;\\r\\n\\r\\n  platformIsPreTag = options.isPreTag || no;\\r\\n  platformMustUseProp = options.mustUseProp || no;\\r\\n  platformGetTagNamespace = options.getTagNamespace || no;\\r\\n\\r\\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\\r\\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\\r\\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\\r\\n\\r\\n  delimiters = options.delimiters;\\r\\n\\r\\n  var stack = [];\\r\\n  var preserveWhitespace = options.preserveWhitespace !== false;\\r\\n  var root;\\r\\n  var currentParent;\\r\\n  var inVPre = false;\\r\\n  var inPre = false;\\r\\n  var warned = false;\\r\\n\\r\\n  function warnOnce (msg) {\\r\\n    if (!warned) {\\r\\n      warned = true;\\r\\n      warn$2(msg);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function closeElement (element) {\\r\\n    // check pre state\\r\\n    if (element.pre) {\\r\\n      inVPre = false;\\r\\n    }\\r\\n    if (platformIsPreTag(element.tag)) {\\r\\n      inPre = false;\\r\\n    }\\r\\n    // apply post-transforms\\r\\n    for (var i = 0; i < postTransforms.length; i++) {\\r\\n      postTransforms[i](element, options);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  parseHTML(template, {\\r\\n    warn: warn$2,\\r\\n    expectHTML: options.expectHTML,\\r\\n    isUnaryTag: options.isUnaryTag,\\r\\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\\r\\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\\r\\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\\r\\n    shouldKeepComment: options.comments,\\r\\n    start: function start (tag, attrs, unary) {\\r\\n      // check namespace.\\r\\n      // inherit parent ns if there is one\\r\\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\\r\\n\\r\\n      // handle IE svg bug\\r\\n      /* istanbul ignore if */\\r\\n      if (isIE && ns === 'svg') {\\r\\n        attrs = guardIESVGBug(attrs);\\r\\n      }\\r\\n\\r\\n      var element = createASTElement(tag, attrs, currentParent);\\r\\n      if (ns) {\\r\\n        element.ns = ns;\\r\\n      }\\r\\n\\r\\n      if (isForbiddenTag(element) && !isServerRendering()) {\\r\\n        element.forbidden = true;\\r\\n        \\\"production\\\" !== 'production' && warn$2(\\r\\n          'Templates should only be responsible for mapping the state to the ' +\\r\\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\\r\\n          \\\"<\\\" + tag + \\\">\\\" + ', as they will not be parsed.'\\r\\n        );\\r\\n      }\\r\\n\\r\\n      // apply pre-transforms\\r\\n      for (var i = 0; i < preTransforms.length; i++) {\\r\\n        element = preTransforms[i](element, options) || element;\\r\\n      }\\r\\n\\r\\n      if (!inVPre) {\\r\\n        processPre(element);\\r\\n        if (element.pre) {\\r\\n          inVPre = true;\\r\\n        }\\r\\n      }\\r\\n      if (platformIsPreTag(element.tag)) {\\r\\n        inPre = true;\\r\\n      }\\r\\n      if (inVPre) {\\r\\n        processRawAttrs(element);\\r\\n      } else if (!element.processed) {\\r\\n        // structural directives\\r\\n        processFor(element);\\r\\n        processIf(element);\\r\\n        processOnce(element);\\r\\n        // element-scope stuff\\r\\n        processElement(element, options);\\r\\n      }\\r\\n\\r\\n      function checkRootConstraints (el) {\\r\\n        if (false) {}\\r\\n      }\\r\\n\\r\\n      // tree management\\r\\n      if (!root) {\\r\\n        root = element;\\r\\n        checkRootConstraints(root);\\r\\n      } else if (!stack.length) {\\r\\n        // allow root elements with v-if, v-else-if and v-else\\r\\n        if (root.if && (element.elseif || element.else)) {\\r\\n          checkRootConstraints(element);\\r\\n          addIfCondition(root, {\\r\\n            exp: element.elseif,\\r\\n            block: element\\r\\n          });\\r\\n        } else if (false) {}\\r\\n      }\\r\\n      if (currentParent && !element.forbidden) {\\r\\n        if (element.elseif || element.else) {\\r\\n          processIfConditions(element, currentParent);\\r\\n        } else if (element.slotScope) { // scoped slot\\r\\n          currentParent.plain = false;\\r\\n          var name = element.slotTarget || '\\\"default\\\"'\\r\\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\\r\\n        } else {\\r\\n          currentParent.children.push(element);\\r\\n          element.parent = currentParent;\\r\\n        }\\r\\n      }\\r\\n      if (!unary) {\\r\\n        currentParent = element;\\r\\n        stack.push(element);\\r\\n      } else {\\r\\n        closeElement(element);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    end: function end () {\\r\\n      // remove trailing whitespace\\r\\n      var element = stack[stack.length - 1];\\r\\n      var lastNode = element.children[element.children.length - 1];\\r\\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\\r\\n        element.children.pop();\\r\\n      }\\r\\n      // pop stack\\r\\n      stack.length -= 1;\\r\\n      currentParent = stack[stack.length - 1];\\r\\n      closeElement(element);\\r\\n    },\\r\\n\\r\\n    chars: function chars (text) {\\r\\n      if (!currentParent) {\\r\\n        if (false) {}\\r\\n        return\\r\\n      }\\r\\n      // IE textarea placeholder bug\\r\\n      /* istanbul ignore if */\\r\\n      if (isIE &&\\r\\n        currentParent.tag === 'textarea' &&\\r\\n        currentParent.attrsMap.placeholder === text\\r\\n      ) {\\r\\n        return\\r\\n      }\\r\\n      var children = currentParent.children;\\r\\n      text = inPre || text.trim()\\r\\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\\r\\n        // only preserve whitespace if its not right after a starting tag\\r\\n        : preserveWhitespace && children.length ? ' ' : '';\\r\\n      if (text) {\\r\\n        var res;\\r\\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\\r\\n          children.push({\\r\\n            type: 2,\\r\\n            expression: res.expression,\\r\\n            tokens: res.tokens,\\r\\n            text: text\\r\\n          });\\r\\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\\r\\n          children.push({\\r\\n            type: 3,\\r\\n            text: text\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n    comment: function comment (text) {\\r\\n      currentParent.children.push({\\r\\n        type: 3,\\r\\n        text: text,\\r\\n        isComment: true\\r\\n      });\\r\\n    }\\r\\n  });\\r\\n  return root\\r\\n}\\r\\n\\r\\nfunction processPre (el) {\\r\\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\\r\\n    el.pre = true;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processRawAttrs (el) {\\r\\n  var l = el.attrsList.length;\\r\\n  if (l) {\\r\\n    var attrs = el.attrs = new Array(l);\\r\\n    for (var i = 0; i < l; i++) {\\r\\n      attrs[i] = {\\r\\n        name: el.attrsList[i].name,\\r\\n        value: JSON.stringify(el.attrsList[i].value)\\r\\n      };\\r\\n    }\\r\\n  } else if (!el.pre) {\\r\\n    // non root node in pre blocks with no attributes\\r\\n    el.plain = true;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processElement (element, options) {\\r\\n  processKey(element);\\r\\n\\r\\n  // determine whether this is a plain element after\\r\\n  // removing structural attributes\\r\\n  element.plain = !element.key && !element.attrsList.length;\\r\\n\\r\\n  processRef(element);\\r\\n  processSlot(element);\\r\\n  processComponent(element);\\r\\n  for (var i = 0; i < transforms.length; i++) {\\r\\n    element = transforms[i](element, options) || element;\\r\\n  }\\r\\n  processAttrs(element);\\r\\n}\\r\\n\\r\\nfunction processKey (el) {\\r\\n  var exp = getBindingAttr(el, 'key');\\r\\n  if (exp) {\\r\\n    if (false) { var parent, iterator; }\\r\\n    el.key = exp;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processRef (el) {\\r\\n  var ref = getBindingAttr(el, 'ref');\\r\\n  if (ref) {\\r\\n    el.ref = ref;\\r\\n    el.refInFor = checkInFor(el);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processFor (el) {\\r\\n  var exp;\\r\\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\\r\\n    var res = parseFor(exp);\\r\\n    if (res) {\\r\\n      extend(el, res);\\r\\n    } else if (false) {}\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction parseFor (exp) {\\r\\n  var inMatch = exp.match(forAliasRE);\\r\\n  if (!inMatch) { return }\\r\\n  var res = {};\\r\\n  res.for = inMatch[2].trim();\\r\\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\\r\\n  var iteratorMatch = alias.match(forIteratorRE);\\r\\n  if (iteratorMatch) {\\r\\n    res.alias = alias.replace(forIteratorRE, '').trim();\\r\\n    res.iterator1 = iteratorMatch[1].trim();\\r\\n    if (iteratorMatch[2]) {\\r\\n      res.iterator2 = iteratorMatch[2].trim();\\r\\n    }\\r\\n  } else {\\r\\n    res.alias = alias;\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction processIf (el) {\\r\\n  var exp = getAndRemoveAttr(el, 'v-if');\\r\\n  if (exp) {\\r\\n    el.if = exp;\\r\\n    addIfCondition(el, {\\r\\n      exp: exp,\\r\\n      block: el\\r\\n    });\\r\\n  } else {\\r\\n    if (getAndRemoveAttr(el, 'v-else') != null) {\\r\\n      el.else = true;\\r\\n    }\\r\\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\\r\\n    if (elseif) {\\r\\n      el.elseif = elseif;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processIfConditions (el, parent) {\\r\\n  var prev = findPrevElement(parent.children);\\r\\n  if (prev && prev.if) {\\r\\n    addIfCondition(prev, {\\r\\n      exp: el.elseif,\\r\\n      block: el\\r\\n    });\\r\\n  } else if (false) {}\\r\\n}\\r\\n\\r\\nfunction findPrevElement (children) {\\r\\n  var i = children.length;\\r\\n  while (i--) {\\r\\n    if (children[i].type === 1) {\\r\\n      return children[i]\\r\\n    } else {\\r\\n      if (false) {}\\r\\n      children.pop();\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction addIfCondition (el, condition) {\\r\\n  if (!el.ifConditions) {\\r\\n    el.ifConditions = [];\\r\\n  }\\r\\n  el.ifConditions.push(condition);\\r\\n}\\r\\n\\r\\nfunction processOnce (el) {\\r\\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\\r\\n  if (once$$1 != null) {\\r\\n    el.once = true;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processSlot (el) {\\r\\n  if (el.tag === 'slot') {\\r\\n    el.slotName = getBindingAttr(el, 'name');\\r\\n    if (false) {}\\r\\n  } else {\\r\\n    var slotScope;\\r\\n    if (el.tag === 'template') {\\r\\n      slotScope = getAndRemoveAttr(el, 'scope');\\r\\n      /* istanbul ignore if */\\r\\n      if (false) {}\\r\\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\\r\\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\\r\\n      /* istanbul ignore if */\\r\\n      if (false) {}\\r\\n      el.slotScope = slotScope;\\r\\n    }\\r\\n    var slotTarget = getBindingAttr(el, 'slot');\\r\\n    if (slotTarget) {\\r\\n      el.slotTarget = slotTarget === '\\\"\\\"' ? '\\\"default\\\"' : slotTarget;\\r\\n      // preserve slot as an attribute for native shadow DOM compat\\r\\n      // only for non-scoped slots.\\r\\n      if (el.tag !== 'template' && !el.slotScope) {\\r\\n        addAttr(el, 'slot', slotTarget);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processComponent (el) {\\r\\n  var binding;\\r\\n  if ((binding = getBindingAttr(el, 'is'))) {\\r\\n    el.component = binding;\\r\\n  }\\r\\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\\r\\n    el.inlineTemplate = true;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction processAttrs (el) {\\r\\n  var list = el.attrsList;\\r\\n  var i, l, name, rawName, value, modifiers, isProp;\\r\\n  for (i = 0, l = list.length; i < l; i++) {\\r\\n    name = rawName = list[i].name;\\r\\n    value = list[i].value;\\r\\n    if (dirRE.test(name)) {\\r\\n      // mark element as dynamic\\r\\n      el.hasBindings = true;\\r\\n      // modifiers\\r\\n      modifiers = parseModifiers(name);\\r\\n      if (modifiers) {\\r\\n        name = name.replace(modifierRE, '');\\r\\n      }\\r\\n      if (bindRE.test(name)) { // v-bind\\r\\n        name = name.replace(bindRE, '');\\r\\n        value = parseFilters(value);\\r\\n        isProp = false;\\r\\n        if (\\r\\n          false\\r\\n        ) {}\\r\\n        if (modifiers) {\\r\\n          if (modifiers.prop) {\\r\\n            isProp = true;\\r\\n            name = camelize(name);\\r\\n            if (name === 'innerHtml') { name = 'innerHTML'; }\\r\\n          }\\r\\n          if (modifiers.camel) {\\r\\n            name = camelize(name);\\r\\n          }\\r\\n          if (modifiers.sync) {\\r\\n            addHandler(\\r\\n              el,\\r\\n              (\\\"update:\\\" + (camelize(name))),\\r\\n              genAssignmentCode(value, \\\"$event\\\")\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n        if (isProp || (\\r\\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\\r\\n        )) {\\r\\n          addProp(el, name, value);\\r\\n        } else {\\r\\n          addAttr(el, name, value);\\r\\n        }\\r\\n      } else if (onRE.test(name)) { // v-on\\r\\n        name = name.replace(onRE, '');\\r\\n        addHandler(el, name, value, modifiers, false, warn$2);\\r\\n      } else { // normal directives\\r\\n        name = name.replace(dirRE, '');\\r\\n        // parse arg\\r\\n        var argMatch = name.match(argRE);\\r\\n        var arg = argMatch && argMatch[1];\\r\\n        if (arg) {\\r\\n          name = name.slice(0, -(arg.length + 1));\\r\\n        }\\r\\n        addDirective(el, name, rawName, value, arg, modifiers);\\r\\n        if (false) {}\\r\\n      }\\r\\n    } else {\\r\\n      // literal attribute\\r\\n      if (false) { var res; }\\r\\n      addAttr(el, name, JSON.stringify(value));\\r\\n      // #6887 firefox doesn't update muted state if set via attribute\\r\\n      // even immediately after element creation\\r\\n      if (!el.component &&\\r\\n          name === 'muted' &&\\r\\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\\r\\n        addProp(el, name, 'true');\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checkInFor (el) {\\r\\n  var parent = el;\\r\\n  while (parent) {\\r\\n    if (parent.for !== undefined) {\\r\\n      return true\\r\\n    }\\r\\n    parent = parent.parent;\\r\\n  }\\r\\n  return false\\r\\n}\\r\\n\\r\\nfunction parseModifiers (name) {\\r\\n  var match = name.match(modifierRE);\\r\\n  if (match) {\\r\\n    var ret = {};\\r\\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\\r\\n    return ret\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction makeAttrsMap (attrs) {\\r\\n  var map = {};\\r\\n  for (var i = 0, l = attrs.length; i < l; i++) {\\r\\n    if (\\r\\n      false\\r\\n    ) {}\\r\\n    map[attrs[i].name] = attrs[i].value;\\r\\n  }\\r\\n  return map\\r\\n}\\r\\n\\r\\n// for script (e.g. type=\\\"x/template\\\") or style, do not decode content\\r\\nfunction isTextTag (el) {\\r\\n  return el.tag === 'script' || el.tag === 'style'\\r\\n}\\r\\n\\r\\nfunction isForbiddenTag (el) {\\r\\n  return (\\r\\n    el.tag === 'style' ||\\r\\n    (el.tag === 'script' && (\\r\\n      !el.attrsMap.type ||\\r\\n      el.attrsMap.type === 'text/javascript'\\r\\n    ))\\r\\n  )\\r\\n}\\r\\n\\r\\nvar ieNSBug = /^xmlns:NS\\\\d+/;\\r\\nvar ieNSPrefix = /^NS\\\\d+:/;\\r\\n\\r\\n/* istanbul ignore next */\\r\\nfunction guardIESVGBug (attrs) {\\r\\n  var res = [];\\r\\n  for (var i = 0; i < attrs.length; i++) {\\r\\n    var attr = attrs[i];\\r\\n    if (!ieNSBug.test(attr.name)) {\\r\\n      attr.name = attr.name.replace(ieNSPrefix, '');\\r\\n      res.push(attr);\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction checkForAliasModel (el, value) {\\r\\n  var _el = el;\\r\\n  while (_el) {\\r\\n    if (_el.for && _el.alias === value) {\\r\\n      warn$2(\\r\\n        \\\"<\\\" + (el.tag) + \\\" v-model=\\\\\\\"\\\" + value + \\\"\\\\\\\">: \\\" +\\r\\n        \\\"You are binding v-model directly to a v-for iteration alias. \\\" +\\r\\n        \\\"This will not be able to modify the v-for source array because \\\" +\\r\\n        \\\"writing to the alias is like modifying a function local variable. \\\" +\\r\\n        \\\"Consider using an array of objects and use v-model on an object property instead.\\\"\\r\\n      );\\r\\n    }\\r\\n    _el = _el.parent;\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction preTransformNode (el, options) {\\r\\n  if (el.tag === 'input') {\\r\\n    var map = el.attrsMap;\\r\\n    if (!map['v-model']) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    var typeBinding;\\r\\n    if (map[':type'] || map['v-bind:type']) {\\r\\n      typeBinding = getBindingAttr(el, 'type');\\r\\n    }\\r\\n    if (!map.type && !typeBinding && map['v-bind']) {\\r\\n      typeBinding = \\\"(\\\" + (map['v-bind']) + \\\").type\\\";\\r\\n    }\\r\\n\\r\\n    if (typeBinding) {\\r\\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\\r\\n      var ifConditionExtra = ifCondition ? (\\\"&&(\\\" + ifCondition + \\\")\\\") : \\\"\\\";\\r\\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\\r\\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\\r\\n      // 1. checkbox\\r\\n      var branch0 = cloneASTElement(el);\\r\\n      // process for on the main node\\r\\n      processFor(branch0);\\r\\n      addRawAttr(branch0, 'type', 'checkbox');\\r\\n      processElement(branch0, options);\\r\\n      branch0.processed = true; // prevent it from double-processed\\r\\n      branch0.if = \\\"(\\\" + typeBinding + \\\")==='checkbox'\\\" + ifConditionExtra;\\r\\n      addIfCondition(branch0, {\\r\\n        exp: branch0.if,\\r\\n        block: branch0\\r\\n      });\\r\\n      // 2. add radio else-if condition\\r\\n      var branch1 = cloneASTElement(el);\\r\\n      getAndRemoveAttr(branch1, 'v-for', true);\\r\\n      addRawAttr(branch1, 'type', 'radio');\\r\\n      processElement(branch1, options);\\r\\n      addIfCondition(branch0, {\\r\\n        exp: \\\"(\\\" + typeBinding + \\\")==='radio'\\\" + ifConditionExtra,\\r\\n        block: branch1\\r\\n      });\\r\\n      // 3. other\\r\\n      var branch2 = cloneASTElement(el);\\r\\n      getAndRemoveAttr(branch2, 'v-for', true);\\r\\n      addRawAttr(branch2, ':type', typeBinding);\\r\\n      processElement(branch2, options);\\r\\n      addIfCondition(branch0, {\\r\\n        exp: ifCondition,\\r\\n        block: branch2\\r\\n      });\\r\\n\\r\\n      if (hasElse) {\\r\\n        branch0.else = true;\\r\\n      } else if (elseIfCondition) {\\r\\n        branch0.elseif = elseIfCondition;\\r\\n      }\\r\\n\\r\\n      return branch0\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction cloneASTElement (el) {\\r\\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\\r\\n}\\r\\n\\r\\nvar model$1 = {\\r\\n  preTransformNode: preTransformNode\\r\\n};\\r\\n\\r\\nvar modules$1 = [\\r\\n  klass$1,\\r\\n  style$1,\\r\\n  model$1\\r\\n];\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction text (el, dir) {\\r\\n  if (dir.value) {\\r\\n    addProp(el, 'textContent', (\\\"_s(\\\" + (dir.value) + \\\")\\\"));\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction html (el, dir) {\\r\\n  if (dir.value) {\\r\\n    addProp(el, 'innerHTML', (\\\"_s(\\\" + (dir.value) + \\\")\\\"));\\r\\n  }\\r\\n}\\r\\n\\r\\nvar directives$1 = {\\r\\n  model: model,\\r\\n  text: text,\\r\\n  html: html\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar baseOptions = {\\r\\n  expectHTML: true,\\r\\n  modules: modules$1,\\r\\n  directives: directives$1,\\r\\n  isPreTag: isPreTag,\\r\\n  isUnaryTag: isUnaryTag,\\r\\n  mustUseProp: mustUseProp,\\r\\n  canBeLeftOpenTag: canBeLeftOpenTag,\\r\\n  isReservedTag: isReservedTag,\\r\\n  getTagNamespace: getTagNamespace,\\r\\n  staticKeys: genStaticKeys(modules$1)\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar isStaticKey;\\r\\nvar isPlatformReservedTag;\\r\\n\\r\\nvar genStaticKeysCached = cached(genStaticKeys$1);\\r\\n\\r\\n/**\\r\\n * Goal of the optimizer: walk the generated template AST tree\\r\\n * and detect sub-trees that are purely static, i.e. parts of\\r\\n * the DOM that never needs to change.\\r\\n *\\r\\n * Once we detect these sub-trees, we can:\\r\\n *\\r\\n * 1. Hoist them into constants, so that we no longer need to\\r\\n *    create fresh nodes for them on each re-render;\\r\\n * 2. Completely skip them in the patching process.\\r\\n */\\r\\nfunction optimize (root, options) {\\r\\n  if (!root) { return }\\r\\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\\r\\n  isPlatformReservedTag = options.isReservedTag || no;\\r\\n  // first pass: mark all non-static nodes.\\r\\n  markStatic$1(root);\\r\\n  // second pass: mark static roots.\\r\\n  markStaticRoots(root, false);\\r\\n}\\r\\n\\r\\nfunction genStaticKeys$1 (keys) {\\r\\n  return makeMap(\\r\\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\\r\\n    (keys ? ',' + keys : '')\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction markStatic$1 (node) {\\r\\n  node.static = isStatic(node);\\r\\n  if (node.type === 1) {\\r\\n    // do not make component slot content static. this avoids\\r\\n    // 1. components not able to mutate slot nodes\\r\\n    // 2. static slot content fails for hot-reloading\\r\\n    if (\\r\\n      !isPlatformReservedTag(node.tag) &&\\r\\n      node.tag !== 'slot' &&\\r\\n      node.attrsMap['inline-template'] == null\\r\\n    ) {\\r\\n      return\\r\\n    }\\r\\n    for (var i = 0, l = node.children.length; i < l; i++) {\\r\\n      var child = node.children[i];\\r\\n      markStatic$1(child);\\r\\n      if (!child.static) {\\r\\n        node.static = false;\\r\\n      }\\r\\n    }\\r\\n    if (node.ifConditions) {\\r\\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\\r\\n        var block = node.ifConditions[i$1].block;\\r\\n        markStatic$1(block);\\r\\n        if (!block.static) {\\r\\n          node.static = false;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction markStaticRoots (node, isInFor) {\\r\\n  if (node.type === 1) {\\r\\n    if (node.static || node.once) {\\r\\n      node.staticInFor = isInFor;\\r\\n    }\\r\\n    // For a node to qualify as a static root, it should have children that\\r\\n    // are not just static text. Otherwise the cost of hoisting out will\\r\\n    // outweigh the benefits and it's better off to just always render it fresh.\\r\\n    if (node.static && node.children.length && !(\\r\\n      node.children.length === 1 &&\\r\\n      node.children[0].type === 3\\r\\n    )) {\\r\\n      node.staticRoot = true;\\r\\n      return\\r\\n    } else {\\r\\n      node.staticRoot = false;\\r\\n    }\\r\\n    if (node.children) {\\r\\n      for (var i = 0, l = node.children.length; i < l; i++) {\\r\\n        markStaticRoots(node.children[i], isInFor || !!node.for);\\r\\n      }\\r\\n    }\\r\\n    if (node.ifConditions) {\\r\\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\\r\\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isStatic (node) {\\r\\n  if (node.type === 2) { // expression\\r\\n    return false\\r\\n  }\\r\\n  if (node.type === 3) { // text\\r\\n    return true\\r\\n  }\\r\\n  return !!(node.pre || (\\r\\n    !node.hasBindings && // no dynamic bindings\\r\\n    !node.if && !node.for && // not v-if or v-for or v-else\\r\\n    !isBuiltInTag(node.tag) && // not a built-in\\r\\n    isPlatformReservedTag(node.tag) && // not a component\\r\\n    !isDirectChildOfTemplateFor(node) &&\\r\\n    Object.keys(node).every(isStaticKey)\\r\\n  ))\\r\\n}\\r\\n\\r\\nfunction isDirectChildOfTemplateFor (node) {\\r\\n  while (node.parent) {\\r\\n    node = node.parent;\\r\\n    if (node.tag !== 'template') {\\r\\n      return false\\r\\n    }\\r\\n    if (node.for) {\\r\\n      return true\\r\\n    }\\r\\n  }\\r\\n  return false\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar fnExpRE = /^([\\\\w$_]+|\\\\([^)]*?\\\\))\\\\s*=>|^function\\\\s*\\\\(/;\\r\\nvar simplePathRE = /^[A-Za-z_$][\\\\w$]*(?:\\\\.[A-Za-z_$][\\\\w$]*|\\\\['[^']*?']|\\\\[\\\"[^\\\"]*?\\\"]|\\\\[\\\\d+]|\\\\[[A-Za-z_$][\\\\w$]*])*$/;\\r\\n\\r\\n// KeyboardEvent.keyCode aliases\\r\\nvar keyCodes = {\\r\\n  esc: 27,\\r\\n  tab: 9,\\r\\n  enter: 13,\\r\\n  space: 32,\\r\\n  up: 38,\\r\\n  left: 37,\\r\\n  right: 39,\\r\\n  down: 40,\\r\\n  'delete': [8, 46]\\r\\n};\\r\\n\\r\\n// KeyboardEvent.key aliases\\r\\nvar keyNames = {\\r\\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\\r\\n  esc: ['Esc', 'Escape'],\\r\\n  tab: 'Tab',\\r\\n  enter: 'Enter',\\r\\n  // #9112: IE11 uses `Spacebar` for Space key name.\\r\\n  space: [' ', 'Spacebar'],\\r\\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\\r\\n  up: ['Up', 'ArrowUp'],\\r\\n  left: ['Left', 'ArrowLeft'],\\r\\n  right: ['Right', 'ArrowRight'],\\r\\n  down: ['Down', 'ArrowDown'],\\r\\n  // #9112: IE11 uses `Del` for Delete key name.\\r\\n  'delete': ['Backspace', 'Delete', 'Del']\\r\\n};\\r\\n\\r\\n// #4868: modifiers that prevent the execution of the listener\\r\\n// need to explicitly return null so that we can determine whether to remove\\r\\n// the listener for .once\\r\\nvar genGuard = function (condition) { return (\\\"if(\\\" + condition + \\\")return null;\\\"); };\\r\\n\\r\\nvar modifierCode = {\\r\\n  stop: '$event.stopPropagation();',\\r\\n  prevent: '$event.preventDefault();',\\r\\n  self: genGuard(\\\"$event.target !== $event.currentTarget\\\"),\\r\\n  ctrl: genGuard(\\\"!$event.ctrlKey\\\"),\\r\\n  shift: genGuard(\\\"!$event.shiftKey\\\"),\\r\\n  alt: genGuard(\\\"!$event.altKey\\\"),\\r\\n  meta: genGuard(\\\"!$event.metaKey\\\"),\\r\\n  left: genGuard(\\\"'button' in $event && $event.button !== 0\\\"),\\r\\n  middle: genGuard(\\\"'button' in $event && $event.button !== 1\\\"),\\r\\n  right: genGuard(\\\"'button' in $event && $event.button !== 2\\\")\\r\\n};\\r\\n\\r\\nfunction genHandlers (\\r\\n  events,\\r\\n  isNative\\r\\n) {\\r\\n  var res = isNative ? 'nativeOn:{' : 'on:{';\\r\\n  for (var name in events) {\\r\\n    res += \\\"\\\\\\\"\\\" + name + \\\"\\\\\\\":\\\" + (genHandler(name, events[name])) + \\\",\\\";\\r\\n  }\\r\\n  return res.slice(0, -1) + '}'\\r\\n}\\r\\n\\r\\nfunction genHandler (\\r\\n  name,\\r\\n  handler\\r\\n) {\\r\\n  if (!handler) {\\r\\n    return 'function(){}'\\r\\n  }\\r\\n\\r\\n  if (Array.isArray(handler)) {\\r\\n    return (\\\"[\\\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \\\"]\\\")\\r\\n  }\\r\\n\\r\\n  var isMethodPath = simplePathRE.test(handler.value);\\r\\n  var isFunctionExpression = fnExpRE.test(handler.value);\\r\\n\\r\\n  if (!handler.modifiers) {\\r\\n    if (isMethodPath || isFunctionExpression) {\\r\\n      return handler.value\\r\\n    }\\r\\n    return (\\\"function($event){\\\" + (handler.value) + \\\"}\\\") // inline statement\\r\\n  } else {\\r\\n    var code = '';\\r\\n    var genModifierCode = '';\\r\\n    var keys = [];\\r\\n    for (var key in handler.modifiers) {\\r\\n      if (modifierCode[key]) {\\r\\n        genModifierCode += modifierCode[key];\\r\\n        // left/right\\r\\n        if (keyCodes[key]) {\\r\\n          keys.push(key);\\r\\n        }\\r\\n      } else if (key === 'exact') {\\r\\n        var modifiers = (handler.modifiers);\\r\\n        genModifierCode += genGuard(\\r\\n          ['ctrl', 'shift', 'alt', 'meta']\\r\\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\\r\\n            .map(function (keyModifier) { return (\\\"$event.\\\" + keyModifier + \\\"Key\\\"); })\\r\\n            .join('||')\\r\\n        );\\r\\n      } else {\\r\\n        keys.push(key);\\r\\n      }\\r\\n    }\\r\\n    if (keys.length) {\\r\\n      code += genKeyFilter(keys);\\r\\n    }\\r\\n    // Make sure modifiers like prevent and stop get executed after key filtering\\r\\n    if (genModifierCode) {\\r\\n      code += genModifierCode;\\r\\n    }\\r\\n    var handlerCode = isMethodPath\\r\\n      ? (\\\"return \\\" + (handler.value) + \\\"($event)\\\")\\r\\n      : isFunctionExpression\\r\\n        ? (\\\"return (\\\" + (handler.value) + \\\")($event)\\\")\\r\\n        : handler.value;\\r\\n    return (\\\"function($event){\\\" + code + handlerCode + \\\"}\\\")\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genKeyFilter (keys) {\\r\\n  return (\\\"if(!('button' in $event)&&\\\" + (keys.map(genFilterCode).join('&&')) + \\\")return null;\\\")\\r\\n}\\r\\n\\r\\nfunction genFilterCode (key) {\\r\\n  var keyVal = parseInt(key, 10);\\r\\n  if (keyVal) {\\r\\n    return (\\\"$event.keyCode!==\\\" + keyVal)\\r\\n  }\\r\\n  var keyCode = keyCodes[key];\\r\\n  var keyName = keyNames[key];\\r\\n  return (\\r\\n    \\\"_k($event.keyCode,\\\" +\\r\\n    (JSON.stringify(key)) + \\\",\\\" +\\r\\n    (JSON.stringify(keyCode)) + \\\",\\\" +\\r\\n    \\\"$event.key,\\\" +\\r\\n    \\\"\\\" + (JSON.stringify(keyName)) +\\r\\n    \\\")\\\"\\r\\n  )\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction on (el, dir) {\\r\\n  if (false) {}\\r\\n  el.wrapListeners = function (code) { return (\\\"_g(\\\" + code + \\\",\\\" + (dir.value) + \\\")\\\"); };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction bind$1 (el, dir) {\\r\\n  el.wrapData = function (code) {\\r\\n    return (\\\"_b(\\\" + code + \\\",'\\\" + (el.tag) + \\\"',\\\" + (dir.value) + \\\",\\\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \\\")\\\")\\r\\n  };\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar baseDirectives = {\\r\\n  on: on,\\r\\n  bind: bind$1,\\r\\n  cloak: noop\\r\\n};\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nvar CodegenState = function CodegenState (options) {\\r\\n  this.options = options;\\r\\n  this.warn = options.warn || baseWarn;\\r\\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\\r\\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\\r\\n  this.directives = extend(extend({}, baseDirectives), options.directives);\\r\\n  var isReservedTag = options.isReservedTag || no;\\r\\n  this.maybeComponent = function (el) { return !(isReservedTag(el.tag) && !el.component); };\\r\\n  this.onceId = 0;\\r\\n  this.staticRenderFns = [];\\r\\n  this.pre = false;\\r\\n};\\r\\n\\r\\n\\r\\n\\r\\nfunction generate (\\r\\n  ast,\\r\\n  options\\r\\n) {\\r\\n  var state = new CodegenState(options);\\r\\n  var code = ast ? genElement(ast, state) : '_c(\\\"div\\\")';\\r\\n  return {\\r\\n    render: (\\\"with(this){return \\\" + code + \\\"}\\\"),\\r\\n    staticRenderFns: state.staticRenderFns\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genElement (el, state) {\\r\\n  if (el.parent) {\\r\\n    el.pre = el.pre || el.parent.pre;\\r\\n  }\\r\\n\\r\\n  if (el.staticRoot && !el.staticProcessed) {\\r\\n    return genStatic(el, state)\\r\\n  } else if (el.once && !el.onceProcessed) {\\r\\n    return genOnce(el, state)\\r\\n  } else if (el.for && !el.forProcessed) {\\r\\n    return genFor(el, state)\\r\\n  } else if (el.if && !el.ifProcessed) {\\r\\n    return genIf(el, state)\\r\\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\\r\\n    return genChildren(el, state) || 'void 0'\\r\\n  } else if (el.tag === 'slot') {\\r\\n    return genSlot(el, state)\\r\\n  } else {\\r\\n    // component or element\\r\\n    var code;\\r\\n    if (el.component) {\\r\\n      code = genComponent(el.component, el, state);\\r\\n    } else {\\r\\n      var data;\\r\\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\\r\\n        data = genData$2(el, state);\\r\\n      }\\r\\n\\r\\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\\r\\n      code = \\\"_c('\\\" + (el.tag) + \\\"'\\\" + (data ? (\\\",\\\" + data) : '') + (children ? (\\\",\\\" + children) : '') + \\\")\\\";\\r\\n    }\\r\\n    // module transforms\\r\\n    for (var i = 0; i < state.transforms.length; i++) {\\r\\n      code = state.transforms[i](el, code);\\r\\n    }\\r\\n    return code\\r\\n  }\\r\\n}\\r\\n\\r\\n// hoist static sub-trees out\\r\\nfunction genStatic (el, state) {\\r\\n  el.staticProcessed = true;\\r\\n  // Some elements (templates) need to behave differently inside of a v-pre\\r\\n  // node.  All pre nodes are static roots, so we can use this as a location to\\r\\n  // wrap a state change and reset it upon exiting the pre node.\\r\\n  var originalPreState = state.pre;\\r\\n  if (el.pre) {\\r\\n    state.pre = el.pre;\\r\\n  }\\r\\n  state.staticRenderFns.push((\\\"with(this){return \\\" + (genElement(el, state)) + \\\"}\\\"));\\r\\n  state.pre = originalPreState;\\r\\n  return (\\\"_m(\\\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \\\")\\\")\\r\\n}\\r\\n\\r\\n// v-once\\r\\nfunction genOnce (el, state) {\\r\\n  el.onceProcessed = true;\\r\\n  if (el.if && !el.ifProcessed) {\\r\\n    return genIf(el, state)\\r\\n  } else if (el.staticInFor) {\\r\\n    var key = '';\\r\\n    var parent = el.parent;\\r\\n    while (parent) {\\r\\n      if (parent.for) {\\r\\n        key = parent.key;\\r\\n        break\\r\\n      }\\r\\n      parent = parent.parent;\\r\\n    }\\r\\n    if (!key) {\\r\\n      \\\"production\\\" !== 'production' && state.warn(\\r\\n        \\\"v-once can only be used inside v-for that is keyed. \\\"\\r\\n      );\\r\\n      return genElement(el, state)\\r\\n    }\\r\\n    return (\\\"_o(\\\" + (genElement(el, state)) + \\\",\\\" + (state.onceId++) + \\\",\\\" + key + \\\")\\\")\\r\\n  } else {\\r\\n    return genStatic(el, state)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genIf (\\r\\n  el,\\r\\n  state,\\r\\n  altGen,\\r\\n  altEmpty\\r\\n) {\\r\\n  el.ifProcessed = true; // avoid recursion\\r\\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\\r\\n}\\r\\n\\r\\nfunction genIfConditions (\\r\\n  conditions,\\r\\n  state,\\r\\n  altGen,\\r\\n  altEmpty\\r\\n) {\\r\\n  if (!conditions.length) {\\r\\n    return altEmpty || '_e()'\\r\\n  }\\r\\n\\r\\n  var condition = conditions.shift();\\r\\n  if (condition.exp) {\\r\\n    return (\\\"(\\\" + (condition.exp) + \\\")?\\\" + (genTernaryExp(condition.block)) + \\\":\\\" + (genIfConditions(conditions, state, altGen, altEmpty)))\\r\\n  } else {\\r\\n    return (\\\"\\\" + (genTernaryExp(condition.block)))\\r\\n  }\\r\\n\\r\\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\\r\\n  function genTernaryExp (el) {\\r\\n    return altGen\\r\\n      ? altGen(el, state)\\r\\n      : el.once\\r\\n        ? genOnce(el, state)\\r\\n        : genElement(el, state)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genFor (\\r\\n  el,\\r\\n  state,\\r\\n  altGen,\\r\\n  altHelper\\r\\n) {\\r\\n  var exp = el.for;\\r\\n  var alias = el.alias;\\r\\n  var iterator1 = el.iterator1 ? (\\\",\\\" + (el.iterator1)) : '';\\r\\n  var iterator2 = el.iterator2 ? (\\\",\\\" + (el.iterator2)) : '';\\r\\n\\r\\n  if (false\\r\\n  ) {}\\r\\n\\r\\n  el.forProcessed = true; // avoid recursion\\r\\n  return (altHelper || '_l') + \\\"((\\\" + exp + \\\"),\\\" +\\r\\n    \\\"function(\\\" + alias + iterator1 + iterator2 + \\\"){\\\" +\\r\\n      \\\"return \\\" + ((altGen || genElement)(el, state)) +\\r\\n    '})'\\r\\n}\\r\\n\\r\\nfunction genData$2 (el, state) {\\r\\n  var data = '{';\\r\\n\\r\\n  // directives first.\\r\\n  // directives may mutate the el's other properties before they are generated.\\r\\n  var dirs = genDirectives(el, state);\\r\\n  if (dirs) { data += dirs + ','; }\\r\\n\\r\\n  // key\\r\\n  if (el.key) {\\r\\n    data += \\\"key:\\\" + (el.key) + \\\",\\\";\\r\\n  }\\r\\n  // ref\\r\\n  if (el.ref) {\\r\\n    data += \\\"ref:\\\" + (el.ref) + \\\",\\\";\\r\\n  }\\r\\n  if (el.refInFor) {\\r\\n    data += \\\"refInFor:true,\\\";\\r\\n  }\\r\\n  // pre\\r\\n  if (el.pre) {\\r\\n    data += \\\"pre:true,\\\";\\r\\n  }\\r\\n  // record original tag name for components using \\\"is\\\" attribute\\r\\n  if (el.component) {\\r\\n    data += \\\"tag:\\\\\\\"\\\" + (el.tag) + \\\"\\\\\\\",\\\";\\r\\n  }\\r\\n  // module data generation functions\\r\\n  for (var i = 0; i < state.dataGenFns.length; i++) {\\r\\n    data += state.dataGenFns[i](el);\\r\\n  }\\r\\n  // attributes\\r\\n  if (el.attrs) {\\r\\n    data += \\\"attrs:{\\\" + (genProps(el.attrs)) + \\\"},\\\";\\r\\n  }\\r\\n  // DOM props\\r\\n  if (el.props) {\\r\\n    data += \\\"domProps:{\\\" + (genProps(el.props)) + \\\"},\\\";\\r\\n  }\\r\\n  // event handlers\\r\\n  if (el.events) {\\r\\n    data += (genHandlers(el.events, false)) + \\\",\\\";\\r\\n  }\\r\\n  if (el.nativeEvents) {\\r\\n    data += (genHandlers(el.nativeEvents, true)) + \\\",\\\";\\r\\n  }\\r\\n  // slot target\\r\\n  // only for non-scoped slots\\r\\n  if (el.slotTarget && !el.slotScope) {\\r\\n    data += \\\"slot:\\\" + (el.slotTarget) + \\\",\\\";\\r\\n  }\\r\\n  // scoped slots\\r\\n  if (el.scopedSlots) {\\r\\n    data += (genScopedSlots(el.scopedSlots, state)) + \\\",\\\";\\r\\n  }\\r\\n  // component v-model\\r\\n  if (el.model) {\\r\\n    data += \\\"model:{value:\\\" + (el.model.value) + \\\",callback:\\\" + (el.model.callback) + \\\",expression:\\\" + (el.model.expression) + \\\"},\\\";\\r\\n  }\\r\\n  // inline-template\\r\\n  if (el.inlineTemplate) {\\r\\n    var inlineTemplate = genInlineTemplate(el, state);\\r\\n    if (inlineTemplate) {\\r\\n      data += inlineTemplate + \\\",\\\";\\r\\n    }\\r\\n  }\\r\\n  data = data.replace(/,$/, '') + '}';\\r\\n  // v-bind data wrap\\r\\n  if (el.wrapData) {\\r\\n    data = el.wrapData(data);\\r\\n  }\\r\\n  // v-on data wrap\\r\\n  if (el.wrapListeners) {\\r\\n    data = el.wrapListeners(data);\\r\\n  }\\r\\n  return data\\r\\n}\\r\\n\\r\\nfunction genDirectives (el, state) {\\r\\n  var dirs = el.directives;\\r\\n  if (!dirs) { return }\\r\\n  var res = 'directives:[';\\r\\n  var hasRuntime = false;\\r\\n  var i, l, dir, needRuntime;\\r\\n  for (i = 0, l = dirs.length; i < l; i++) {\\r\\n    dir = dirs[i];\\r\\n    needRuntime = true;\\r\\n    var gen = state.directives[dir.name];\\r\\n    if (gen) {\\r\\n      // compile-time directive that manipulates AST.\\r\\n      // returns true if it also needs a runtime counterpart.\\r\\n      needRuntime = !!gen(el, dir, state.warn);\\r\\n    }\\r\\n    if (needRuntime) {\\r\\n      hasRuntime = true;\\r\\n      res += \\\"{name:\\\\\\\"\\\" + (dir.name) + \\\"\\\\\\\",rawName:\\\\\\\"\\\" + (dir.rawName) + \\\"\\\\\\\"\\\" + (dir.value ? (\\\",value:(\\\" + (dir.value) + \\\"),expression:\\\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\\\",arg:\\\\\\\"\\\" + (dir.arg) + \\\"\\\\\\\"\\\") : '') + (dir.modifiers ? (\\\",modifiers:\\\" + (JSON.stringify(dir.modifiers))) : '') + \\\"},\\\";\\r\\n    }\\r\\n  }\\r\\n  if (hasRuntime) {\\r\\n    return res.slice(0, -1) + ']'\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genInlineTemplate (el, state) {\\r\\n  var ast = el.children[0];\\r\\n  if (false) {}\\r\\n  if (ast.type === 1) {\\r\\n    var inlineRenderFns = generate(ast, state.options);\\r\\n    return (\\\"inlineTemplate:{render:function(){\\\" + (inlineRenderFns.render) + \\\"},staticRenderFns:[\\\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\\\"function(){\\\" + code + \\\"}\\\"); }).join(',')) + \\\"]}\\\")\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genScopedSlots (\\r\\n  slots,\\r\\n  state\\r\\n) {\\r\\n  return (\\\"scopedSlots:_u([\\\" + (Object.keys(slots).map(function (key) {\\r\\n      return genScopedSlot(key, slots[key], state)\\r\\n    }).join(',')) + \\\"])\\\")\\r\\n}\\r\\n\\r\\nfunction genScopedSlot (\\r\\n  key,\\r\\n  el,\\r\\n  state\\r\\n) {\\r\\n  if (el.for && !el.forProcessed) {\\r\\n    return genForScopedSlot(key, el, state)\\r\\n  }\\r\\n  var fn = \\\"function(\\\" + (String(el.slotScope)) + \\\"){\\\" +\\r\\n    \\\"return \\\" + (el.tag === 'template'\\r\\n      ? el.if\\r\\n        ? (\\\"(\\\" + (el.if) + \\\")?\\\" + (genChildren(el, state) || 'undefined') + \\\":undefined\\\")\\r\\n        : genChildren(el, state) || 'undefined'\\r\\n      : genElement(el, state)) + \\\"}\\\";\\r\\n  return (\\\"{key:\\\" + key + \\\",fn:\\\" + fn + \\\"}\\\")\\r\\n}\\r\\n\\r\\nfunction genForScopedSlot (\\r\\n  key,\\r\\n  el,\\r\\n  state\\r\\n) {\\r\\n  var exp = el.for;\\r\\n  var alias = el.alias;\\r\\n  var iterator1 = el.iterator1 ? (\\\",\\\" + (el.iterator1)) : '';\\r\\n  var iterator2 = el.iterator2 ? (\\\",\\\" + (el.iterator2)) : '';\\r\\n  el.forProcessed = true; // avoid recursion\\r\\n  return \\\"_l((\\\" + exp + \\\"),\\\" +\\r\\n    \\\"function(\\\" + alias + iterator1 + iterator2 + \\\"){\\\" +\\r\\n      \\\"return \\\" + (genScopedSlot(key, el, state)) +\\r\\n    '})'\\r\\n}\\r\\n\\r\\nfunction genChildren (\\r\\n  el,\\r\\n  state,\\r\\n  checkSkip,\\r\\n  altGenElement,\\r\\n  altGenNode\\r\\n) {\\r\\n  var children = el.children;\\r\\n  if (children.length) {\\r\\n    var el$1 = children[0];\\r\\n    // optimize single v-for\\r\\n    if (children.length === 1 &&\\r\\n      el$1.for &&\\r\\n      el$1.tag !== 'template' &&\\r\\n      el$1.tag !== 'slot'\\r\\n    ) {\\r\\n      var normalizationType = checkSkip && state.maybeComponent(el$1) ? \\\",1\\\" : \\\"\\\";\\r\\n      return (\\\"\\\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\\r\\n    }\\r\\n    var normalizationType$1 = checkSkip\\r\\n      ? getNormalizationType(children, state.maybeComponent)\\r\\n      : 0;\\r\\n    var gen = altGenNode || genNode;\\r\\n    return (\\\"[\\\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \\\"]\\\" + (normalizationType$1 ? (\\\",\\\" + normalizationType$1) : ''))\\r\\n  }\\r\\n}\\r\\n\\r\\n// determine the normalization needed for the children array.\\r\\n// 0: no normalization needed\\r\\n// 1: simple normalization needed (possible 1-level deep nested array)\\r\\n// 2: full normalization needed\\r\\nfunction getNormalizationType (\\r\\n  children,\\r\\n  maybeComponent\\r\\n) {\\r\\n  var res = 0;\\r\\n  for (var i = 0; i < children.length; i++) {\\r\\n    var el = children[i];\\r\\n    if (el.type !== 1) {\\r\\n      continue\\r\\n    }\\r\\n    if (needsNormalization(el) ||\\r\\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\\r\\n      res = 2;\\r\\n      break\\r\\n    }\\r\\n    if (maybeComponent(el) ||\\r\\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\\r\\n      res = 1;\\r\\n    }\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction needsNormalization (el) {\\r\\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\\r\\n}\\r\\n\\r\\nfunction genNode (node, state) {\\r\\n  if (node.type === 1) {\\r\\n    return genElement(node, state)\\r\\n  } else if (node.type === 3 && node.isComment) {\\r\\n    return genComment(node)\\r\\n  } else {\\r\\n    return genText(node)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction genText (text) {\\r\\n  return (\\\"_v(\\\" + (text.type === 2\\r\\n    ? text.expression // no need for () because already wrapped in _s()\\r\\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \\\")\\\")\\r\\n}\\r\\n\\r\\nfunction genComment (comment) {\\r\\n  return (\\\"_e(\\\" + (JSON.stringify(comment.text)) + \\\")\\\")\\r\\n}\\r\\n\\r\\nfunction genSlot (el, state) {\\r\\n  var slotName = el.slotName || '\\\"default\\\"';\\r\\n  var children = genChildren(el, state);\\r\\n  var res = \\\"_t(\\\" + slotName + (children ? (\\\",\\\" + children) : '');\\r\\n  var attrs = el.attrs && (\\\"{\\\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \\\":\\\" + (a.value)); }).join(',')) + \\\"}\\\");\\r\\n  var bind$$1 = el.attrsMap['v-bind'];\\r\\n  if ((attrs || bind$$1) && !children) {\\r\\n    res += \\\",null\\\";\\r\\n  }\\r\\n  if (attrs) {\\r\\n    res += \\\",\\\" + attrs;\\r\\n  }\\r\\n  if (bind$$1) {\\r\\n    res += (attrs ? '' : ',null') + \\\",\\\" + bind$$1;\\r\\n  }\\r\\n  return res + ')'\\r\\n}\\r\\n\\r\\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\\r\\nfunction genComponent (\\r\\n  componentName,\\r\\n  el,\\r\\n  state\\r\\n) {\\r\\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\\r\\n  return (\\\"_c(\\\" + componentName + \\\",\\\" + (genData$2(el, state)) + (children ? (\\\",\\\" + children) : '') + \\\")\\\")\\r\\n}\\r\\n\\r\\nfunction genProps (props) {\\r\\n  var res = '';\\r\\n  for (var i = 0; i < props.length; i++) {\\r\\n    var prop = props[i];\\r\\n    /* istanbul ignore if */\\r\\n    {\\r\\n      res += \\\"\\\\\\\"\\\" + (prop.name) + \\\"\\\\\\\":\\\" + (transformSpecialNewlines(prop.value)) + \\\",\\\";\\r\\n    }\\r\\n  }\\r\\n  return res.slice(0, -1)\\r\\n}\\r\\n\\r\\n// #3895, #4268\\r\\nfunction transformSpecialNewlines (text) {\\r\\n  return text\\r\\n    .replace(/\\\\u2028/g, '\\\\\\\\u2028')\\r\\n    .replace(/\\\\u2029/g, '\\\\\\\\u2029')\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// these keywords should not appear inside expressions, but operators like\\r\\n// typeof, instanceof and in are allowed\\r\\nvar prohibitedKeywordRE = new RegExp('\\\\\\\\b' + (\\r\\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\\r\\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\\r\\n  'extends,finally,continue,debugger,function,arguments'\\r\\n).split(',').join('\\\\\\\\b|\\\\\\\\b') + '\\\\\\\\b');\\r\\n\\r\\n// these unary operators should not be used as property/method names\\r\\nvar unaryOperatorsRE = new RegExp('\\\\\\\\b' + (\\r\\n  'delete,typeof,void'\\r\\n).split(',').join('\\\\\\\\s*\\\\\\\\([^\\\\\\\\)]*\\\\\\\\)|\\\\\\\\b') + '\\\\\\\\s*\\\\\\\\([^\\\\\\\\)]*\\\\\\\\)');\\r\\n\\r\\n// strip strings in expressions\\r\\nvar stripStringRE = /'(?:[^'\\\\\\\\]|\\\\\\\\.)*'|\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"|`(?:[^`\\\\\\\\]|\\\\\\\\.)*\\\\$\\\\{|\\\\}(?:[^`\\\\\\\\]|\\\\\\\\.)*`|`(?:[^`\\\\\\\\]|\\\\\\\\.)*`/g;\\r\\n\\r\\n// detect problematic expressions in a template\\r\\nfunction detectErrors (ast) {\\r\\n  var errors = [];\\r\\n  if (ast) {\\r\\n    checkNode(ast, errors);\\r\\n  }\\r\\n  return errors\\r\\n}\\r\\n\\r\\nfunction checkNode (node, errors) {\\r\\n  if (node.type === 1) {\\r\\n    for (var name in node.attrsMap) {\\r\\n      if (dirRE.test(name)) {\\r\\n        var value = node.attrsMap[name];\\r\\n        if (value) {\\r\\n          if (name === 'v-for') {\\r\\n            checkFor(node, (\\\"v-for=\\\\\\\"\\\" + value + \\\"\\\\\\\"\\\"), errors);\\r\\n          } else if (onRE.test(name)) {\\r\\n            checkEvent(value, (name + \\\"=\\\\\\\"\\\" + value + \\\"\\\\\\\"\\\"), errors);\\r\\n          } else {\\r\\n            checkExpression(value, (name + \\\"=\\\\\\\"\\\" + value + \\\"\\\\\\\"\\\"), errors);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    if (node.children) {\\r\\n      for (var i = 0; i < node.children.length; i++) {\\r\\n        checkNode(node.children[i], errors);\\r\\n      }\\r\\n    }\\r\\n  } else if (node.type === 2) {\\r\\n    checkExpression(node.expression, node.text, errors);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checkEvent (exp, text, errors) {\\r\\n  var stipped = exp.replace(stripStringRE, '');\\r\\n  var keywordMatch = stipped.match(unaryOperatorsRE);\\r\\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\\r\\n    errors.push(\\r\\n      \\\"avoid using JavaScript unary operator as property name: \\\" +\\r\\n      \\\"\\\\\\\"\\\" + (keywordMatch[0]) + \\\"\\\\\\\" in expression \\\" + (text.trim())\\r\\n    );\\r\\n  }\\r\\n  checkExpression(exp, text, errors);\\r\\n}\\r\\n\\r\\nfunction checkFor (node, text, errors) {\\r\\n  checkExpression(node.for || '', text, errors);\\r\\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\\r\\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\\r\\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\\r\\n}\\r\\n\\r\\nfunction checkIdentifier (\\r\\n  ident,\\r\\n  type,\\r\\n  text,\\r\\n  errors\\r\\n) {\\r\\n  if (typeof ident === 'string') {\\r\\n    try {\\r\\n      new Function((\\\"var \\\" + ident + \\\"=_\\\"));\\r\\n    } catch (e) {\\r\\n      errors.push((\\\"invalid \\\" + type + \\\" \\\\\\\"\\\" + ident + \\\"\\\\\\\" in expression: \\\" + (text.trim())));\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checkExpression (exp, text, errors) {\\r\\n  try {\\r\\n    new Function((\\\"return \\\" + exp));\\r\\n  } catch (e) {\\r\\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\\r\\n    if (keywordMatch) {\\r\\n      errors.push(\\r\\n        \\\"avoid using JavaScript keyword as property name: \\\" +\\r\\n        \\\"\\\\\\\"\\\" + (keywordMatch[0]) + \\\"\\\\\\\"\\\\n  Raw expression: \\\" + (text.trim())\\r\\n      );\\r\\n    } else {\\r\\n      errors.push(\\r\\n        \\\"invalid expression: \\\" + (e.message) + \\\" in\\\\n\\\\n\\\" +\\r\\n        \\\"    \\\" + exp + \\\"\\\\n\\\\n\\\" +\\r\\n        \\\"  Raw expression: \\\" + (text.trim()) + \\\"\\\\n\\\"\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nfunction createFunction (code, errors) {\\r\\n  try {\\r\\n    return new Function(code)\\r\\n  } catch (err) {\\r\\n    errors.push({ err: err, code: code });\\r\\n    return noop\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createCompileToFunctionFn (compile) {\\r\\n  var cache = Object.create(null);\\r\\n\\r\\n  return function compileToFunctions (\\r\\n    template,\\r\\n    options,\\r\\n    vm\\r\\n  ) {\\r\\n    options = extend({}, options);\\r\\n    var warn$$1 = options.warn || warn;\\r\\n    delete options.warn;\\r\\n\\r\\n    /* istanbul ignore if */\\r\\n    if (false) {}\\r\\n\\r\\n    // check cache\\r\\n    var key = options.delimiters\\r\\n      ? String(options.delimiters) + template\\r\\n      : template;\\r\\n    if (cache[key]) {\\r\\n      return cache[key]\\r\\n    }\\r\\n\\r\\n    // compile\\r\\n    var compiled = compile(template, options);\\r\\n\\r\\n    // check compilation errors/tips\\r\\n    if (false) {}\\r\\n\\r\\n    // turn code into functions\\r\\n    var res = {};\\r\\n    var fnGenErrors = [];\\r\\n    res.render = createFunction(compiled.render, fnGenErrors);\\r\\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\\r\\n      return createFunction(code, fnGenErrors)\\r\\n    });\\r\\n\\r\\n    // check function generation errors.\\r\\n    // this should only happen if there is a bug in the compiler itself.\\r\\n    // mostly for codegen development use\\r\\n    /* istanbul ignore if */\\r\\n    if (false) {}\\r\\n\\r\\n    return (cache[key] = res)\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction createCompilerCreator (baseCompile) {\\r\\n  return function createCompiler (baseOptions) {\\r\\n    function compile (\\r\\n      template,\\r\\n      options\\r\\n    ) {\\r\\n      var finalOptions = Object.create(baseOptions);\\r\\n      var errors = [];\\r\\n      var tips = [];\\r\\n      finalOptions.warn = function (msg, tip) {\\r\\n        (tip ? tips : errors).push(msg);\\r\\n      };\\r\\n\\r\\n      if (options) {\\r\\n        // merge custom modules\\r\\n        if (options.modules) {\\r\\n          finalOptions.modules =\\r\\n            (baseOptions.modules || []).concat(options.modules);\\r\\n        }\\r\\n        // merge custom directives\\r\\n        if (options.directives) {\\r\\n          finalOptions.directives = extend(\\r\\n            Object.create(baseOptions.directives || null),\\r\\n            options.directives\\r\\n          );\\r\\n        }\\r\\n        // copy other options\\r\\n        for (var key in options) {\\r\\n          if (key !== 'modules' && key !== 'directives') {\\r\\n            finalOptions[key] = options[key];\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      var compiled = baseCompile(template, finalOptions);\\r\\n      if (false) {}\\r\\n      compiled.errors = errors;\\r\\n      compiled.tips = tips;\\r\\n      return compiled\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      compile: compile,\\r\\n      compileToFunctions: createCompileToFunctionFn(compile)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// `createCompilerCreator` allows creating compilers that use alternative\\r\\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\\r\\n// Here we just export a default compiler using the default parts.\\r\\nvar createCompiler = createCompilerCreator(function baseCompile (\\r\\n  template,\\r\\n  options\\r\\n) {\\r\\n  var ast = parse(template.trim(), options);\\r\\n  if (options.optimize !== false) {\\r\\n    optimize(ast, options);\\r\\n  }\\r\\n  var code = generate(ast, options);\\r\\n  return {\\r\\n    ast: ast,\\r\\n    render: code.render,\\r\\n    staticRenderFns: code.staticRenderFns\\r\\n  }\\r\\n});\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar ref$1 = createCompiler(baseOptions);\\r\\nvar compile = ref$1.compile;\\r\\nvar compileToFunctions = ref$1.compileToFunctions;\\r\\n\\r\\n/*  */\\r\\n\\r\\n// check whether current browser encodes a char inside attribute values\\r\\nvar div;\\r\\nfunction getShouldDecode (href) {\\r\\n  div = div || document.createElement('div');\\r\\n  div.innerHTML = href ? \\\"<a href=\\\\\\\"\\\\n\\\\\\\"/>\\\" : \\\"<div a=\\\\\\\"\\\\n\\\\\\\"/>\\\";\\r\\n  return div.innerHTML.indexOf('&#10;') > 0\\r\\n}\\r\\n\\r\\n// #3663: IE encodes newlines inside attribute values while other browsers don't\\r\\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\\r\\n// #6828: chrome encodes content in a[href]\\r\\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar idToTemplate = cached(function (id) {\\r\\n  var el = query(id);\\r\\n  return el && el.innerHTML\\r\\n});\\r\\n\\r\\nvar mount = Vue.prototype.$mount;\\r\\nVue.prototype.$mount = function (\\r\\n  el,\\r\\n  hydrating\\r\\n) {\\r\\n  el = el && query(el);\\r\\n\\r\\n  /* istanbul ignore if */\\r\\n  if (el === document.body || el === document.documentElement) {\\r\\n    \\\"production\\\" !== 'production' && warn(\\r\\n      \\\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\\\"\\r\\n    );\\r\\n    return this\\r\\n  }\\r\\n\\r\\n  var options = this.$options;\\r\\n  // resolve template/el and convert to render function\\r\\n  if (!options.render) {\\r\\n    var template = options.template;\\r\\n    if (template) {\\r\\n      if (typeof template === 'string') {\\r\\n        if (template.charAt(0) === '#') {\\r\\n          template = idToTemplate(template);\\r\\n          /* istanbul ignore if */\\r\\n          if (false) {}\\r\\n        }\\r\\n      } else if (template.nodeType) {\\r\\n        template = template.innerHTML;\\r\\n      } else {\\r\\n        if (false) {}\\r\\n        return this\\r\\n      }\\r\\n    } else if (el) {\\r\\n      template = getOuterHTML(el);\\r\\n    }\\r\\n    if (template) {\\r\\n      /* istanbul ignore if */\\r\\n      if (false) {}\\r\\n\\r\\n      var ref = compileToFunctions(template, {\\r\\n        shouldDecodeNewlines: shouldDecodeNewlines,\\r\\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\\r\\n        delimiters: options.delimiters,\\r\\n        comments: options.comments\\r\\n      }, this);\\r\\n      var render = ref.render;\\r\\n      var staticRenderFns = ref.staticRenderFns;\\r\\n      options.render = render;\\r\\n      options.staticRenderFns = staticRenderFns;\\r\\n\\r\\n      /* istanbul ignore if */\\r\\n      if (false) {}\\r\\n    }\\r\\n  }\\r\\n  return mount.call(this, el, hydrating)\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get outerHTML of elements, taking care\\r\\n * of SVG elements in IE as well.\\r\\n */\\r\\nfunction getOuterHTML (el) {\\r\\n  if (el.outerHTML) {\\r\\n    return el.outerHTML\\r\\n  } else {\\r\\n    var container = document.createElement('div');\\r\\n    container.appendChild(el.cloneNode(true));\\r\\n    return container.innerHTML\\r\\n  }\\r\\n}\\r\\n\\r\\nVue.compile = compileToFunctions;\\r\\n\\r\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (Vue);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(25).setImmediate))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBaUMsRUFBRTtBQUNyRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFvQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBLElBQUksS0FBcUMsRUFBRSxpREFxRjFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBc0QsRUFBRSxFQUszRDtBQUNILGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTLHFCQUFxQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUQsRUFBRSxFQUUxRDtBQUNQO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQ3NDO0FBQzVDLElBQUksRUFFRDtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUNzQztBQUM1QyxJQUFJLEVBRUQ7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNLEtBQTRELEVBQUUsRUFLakU7QUFDSDtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FFUTtBQUNaLElBQUksRUFFRDtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXNELEVBQUUsRUFPM0Q7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXNELEVBQUUsRUFHM0Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBcUM7QUFDekQsTUFBTSxTQUFrQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FDb0I7QUFDMUIsSUFBSSxFQUVEO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQTZDLEVBQUUsRUFFbEQ7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxZQUFZLEtBQTZELEVBQUUsRUFFbEU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsMkJBQTJCLEVBQUU7QUFDdkUsS0FBSztBQUNMO0FBQ0EsMENBQTBDLDRCQUE0QixFQUFFO0FBQ3hFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QyxNQUFNLEtBQXFDLEVBQUUsRUFNMUM7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUMsRUFBRSxFQVMxQzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsS0FBcUMsRUFBRSxFQU9qRDs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRiw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCLGlFQUFpRTtBQUN6RixZQUFZLDBGQUEwRjtBQUN0RyxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLHNDQVUxQzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QyxFQUFFO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0QkFBNEIsRUFBRTtBQUNsRixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0IsRUFBRTtBQUNyRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXNFLEVBQUUsRUFFM0U7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUUsRUFBRSxFQUUxRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMscUNBQXFDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJDQUEyQyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw4QkFBOEIsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx1Q0FBdUM7O0FBRXpFLHFDQUFxQywwQkFBMEI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUE0RCxFQUFFLEVBTWpFOztBQUVMOztBQUVBO0FBQ0EsUUFBUSxLQUM0QztBQUNwRCxNQUFNLEVBS0Q7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUN0QixVQUFVLEVBSUQ7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFlBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBcUMsRUFBRSxFQWExQztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNB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LFFBQVEsS0FBcUMsRUFBRSxFQWUxQzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBVzFDOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFhMUM7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxLQUFxQyxFQUFFLEVBRTFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLFlBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBa0QsRUFBRSxFQUt2RDtBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQW1FLEVBQUUsRUFFeEU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsS0FBbUUsRUFBRSxFQUd4RTtBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsa0VBQUcsRUFBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIFZ1ZS5qcyB2Mi41LjE4XHJcbiAqIChjKSAyMDE0LTIwMTggRXZhbiBZb3VcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyogICovXHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcclxuXHJcbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxyXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XHJcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGVmICh2KSB7XHJcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xyXG4gIHJldHVybiB2ID09PSB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcclxuICByZXR1cm4gdiA9PT0gZmFsc2VcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXHJcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcclxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xyXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cclxuICovXHJcbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXHJcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcclxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcclxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcclxuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xyXG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGxcclxuICAgID8gJydcclxuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcclxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXHJcbiAgICAgIDogU3RyaW5nKHZhbClcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxyXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcclxuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcclxuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwIChcclxuICBzdHIsXHJcbiAgZXhwZWN0c0xvd2VyQ2FzZVxyXG4pIHtcclxuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcclxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxyXG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXHJcbiAqL1xyXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXHJcbiAqL1xyXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XHJcbiAgaWYgKGFyci5sZW5ndGgpIHtcclxuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cclxuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcclxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcclxuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xyXG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cclxuICovXHJcbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxyXG4gKi9cclxudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcclxufSk7XHJcblxyXG4vKipcclxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cclxuICovXHJcbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcclxufSk7XHJcblxyXG4vKipcclxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxyXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcclxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXHJcbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cclxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAqL1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XHJcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xyXG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGxcclxuICAgICAgPyBsID4gMVxyXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXHJcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcclxuICAgICAgOiBmbi5jYWxsKGN0eClcclxuICB9XHJcblxyXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcclxuICByZXR1cm4gYm91bmRGblxyXG59XHJcblxyXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XHJcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxyXG59XHJcblxyXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXHJcbiAgPyBuYXRpdmVCaW5kXHJcbiAgOiBwb2x5ZmlsbEJpbmQ7XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xyXG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcclxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XHJcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XHJcbiAgfVxyXG4gIHJldHVybiByZXRcclxufVxyXG5cclxuLyoqXHJcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XHJcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIHRvXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xyXG4gIHZhciByZXMgPSB7fTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGFycltpXSkge1xyXG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcblxyXG4vKipcclxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXHJcbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxyXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxyXG5cclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XHJcblxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxyXG4gKi9cclxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XHJcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XHJcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxyXG4gIH0sIFtdKS5qb2luKCcsJylcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxyXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XHJcbiAqL1xyXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxyXG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcclxuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XHJcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XHJcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XHJcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xyXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxyXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcclxuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XHJcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XHJcbiAgfVxyXG4gIHJldHVybiAtMVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cclxuICovXHJcbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XHJcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcclxuXHJcbnZhciBBU1NFVF9UWVBFUyA9IFtcclxuICAnY29tcG9uZW50JyxcclxuICAnZGlyZWN0aXZlJyxcclxuICAnZmlsdGVyJ1xyXG5dO1xyXG5cclxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcclxuICAnYmVmb3JlQ3JlYXRlJyxcclxuICAnY3JlYXRlZCcsXHJcbiAgJ2JlZm9yZU1vdW50JyxcclxuICAnbW91bnRlZCcsXHJcbiAgJ2JlZm9yZVVwZGF0ZScsXHJcbiAgJ3VwZGF0ZWQnLFxyXG4gICdiZWZvcmVEZXN0cm95JyxcclxuICAnZGVzdHJveWVkJyxcclxuICAnYWN0aXZhdGVkJyxcclxuICAnZGVhY3RpdmF0ZWQnLFxyXG4gICdlcnJvckNhcHR1cmVkJ1xyXG5dO1xyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcbnZhciBjb25maWcgPSAoe1xyXG4gIC8qKlxyXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxyXG4gICAqL1xyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cclxuICAgKi9cclxuICBzaWxlbnQ6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xyXG4gICAqL1xyXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXHJcbiAgICovXHJcbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcclxuICAgKi9cclxuICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcblxyXG4gIC8qKlxyXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXHJcbiAgICovXHJcbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxyXG5cclxuICAvKipcclxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcclxuICAgKi9cclxuICB3YXJuSGFuZGxlcjogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXHJcbiAgICovXHJcbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cclxuICAgKi9cclxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXHJcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAqL1xyXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxyXG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICovXHJcbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXHJcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxyXG4gICAqL1xyXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxyXG4gICAqL1xyXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcclxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICovXHJcbiAgbXVzdFVzZVByb3A6IG5vLFxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcclxuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxyXG4gICAqL1xyXG4gIGFzeW5jOiB0cnVlLFxyXG5cclxuICAvKipcclxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xyXG4gICAqL1xyXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcclxuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcclxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgdmFsdWU6IHZhbCxcclxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cclxuICovXHJcbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xyXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcclxuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cclxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmpcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XHJcbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xyXG5cclxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xyXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xyXG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcclxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XHJcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xyXG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XHJcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcclxudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcclxudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XHJcblxyXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXHJcbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XHJcblxyXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XHJcbmlmIChpbkJyb3dzZXIpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIG9wdHMgPSB7fTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbn1cclxuXHJcbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxyXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxyXG52YXIgX2lzU2VydmVyO1xyXG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXHJcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcclxuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfaXNTZXJ2ZXJcclxufTtcclxuXHJcbi8vIGRldGVjdCBkZXZ0b29sc1xyXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xyXG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxyXG59XHJcblxyXG52YXIgaGFzU3ltYm9sID1cclxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXHJcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XHJcblxyXG52YXIgX1NldDtcclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xyXG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxyXG4gIF9TZXQgPSBTZXQ7XHJcbn0gZWxzZSB7XHJcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxyXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNldCAoKSB7XHJcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH1cclxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcclxuICAgIH07XHJcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XHJcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XHJcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNldDtcclxuICB9KCkpO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB3YXJuID0gbm9vcDtcclxudmFyIHRpcCA9IG5vb3A7XHJcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXHJcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcclxuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcclxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXHJcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XHJcblxyXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xyXG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xyXG5cclxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcclxuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xyXG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcclxuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcclxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcclxuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcclxuICAgICAgcmV0dXJuICc8Um9vdD4nXHJcbiAgICB9XHJcbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxyXG4gICAgICA/IHZtLm9wdGlvbnNcclxuICAgICAgOiB2bS5faXNWdWVcclxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcclxuICAgICAgICA6IHZtIHx8IHt9O1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xyXG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcclxuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xyXG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXHJcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXHJcbiAgICApXHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcclxuICAgIHZhciByZXMgPSAnJztcclxuICAgIHdoaWxlIChuKSB7XHJcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XHJcbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XHJcbiAgICAgIG4gPj49IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfTtcclxuXHJcbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xyXG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XHJcbiAgICAgIHZhciB0cmVlID0gW107XHJcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xyXG4gICAgICB3aGlsZSAodm0pIHtcclxuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcclxuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XHJcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xyXG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cmVlLnB1c2godm0pO1xyXG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcclxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxyXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcclxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxyXG4gICAgICAgIC5qb2luKCdcXG4nKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB1aWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxyXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gKi9cclxudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XHJcbiAgdGhpcy5pZCA9IHVpZCsrO1xyXG4gIHRoaXMuc3VicyA9IFtdO1xyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xyXG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XHJcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcclxufTtcclxuXHJcbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcclxuICBpZiAoRGVwLnRhcmdldCkge1xyXG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xyXG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XHJcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XHJcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXHJcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XHJcbiAgICAvLyBvcmRlclxyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHN1YnNbaV0udXBkYXRlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxyXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXHJcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxyXG5EZXAudGFyZ2V0ID0gbnVsbDtcclxudmFyIHRhcmdldFN0YWNrID0gW107XHJcblxyXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcclxuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XHJcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcclxuICB0YXJnZXRTdGFjay5wb3AoKTtcclxuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxyXG4gIHRhZyxcclxuICBkYXRhLFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRleHQsXHJcbiAgZWxtLFxyXG4gIGNvbnRleHQsXHJcbiAgY29tcG9uZW50T3B0aW9ucyxcclxuICBhc3luY0ZhY3RvcnlcclxuKSB7XHJcbiAgdGhpcy50YWcgPSB0YWc7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICB0aGlzLmVsbSA9IGVsbTtcclxuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xyXG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XHJcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLnJhdyA9IGZhbHNlO1xyXG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcclxuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XHJcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcclxuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XHJcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcclxuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcclxuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcclxuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xyXG59O1xyXG5cclxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcclxuXHJcbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XHJcblxyXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XHJcblxyXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XHJcbiAgbm9kZS50ZXh0ID0gdGV4dDtcclxuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XHJcbiAgcmV0dXJuIG5vZGVcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XHJcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcclxufVxyXG5cclxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcclxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xyXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcclxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcclxuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxyXG4gICAgdm5vZGUudGFnLFxyXG4gICAgdm5vZGUuZGF0YSxcclxuICAgIC8vICM3OTc1XHJcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcclxuICAgIC8vIGEgY2hpbGQuXHJcbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxyXG4gICAgdm5vZGUudGV4dCxcclxuICAgIHZub2RlLmVsbSxcclxuICAgIHZub2RlLmNvbnRleHQsXHJcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxyXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XHJcbiAgKTtcclxuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcclxuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcclxuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xyXG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XHJcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcclxuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xyXG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XHJcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcclxuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xyXG4gIHJldHVybiBjbG9uZWRcclxufVxyXG5cclxuLypcclxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXHJcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxyXG4gKi9cclxuXHJcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xyXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcclxuXHJcbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcclxuICAncHVzaCcsXHJcbiAgJ3BvcCcsXHJcbiAgJ3NoaWZ0JyxcclxuICAndW5zaGlmdCcsXHJcbiAgJ3NwbGljZScsXHJcbiAgJ3NvcnQnLFxyXG4gICdyZXZlcnNlJ1xyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xyXG4gKi9cclxubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXHJcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xyXG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcclxuICAgIHZhciBpbnNlcnRlZDtcclxuICAgIHN3aXRjaCAobWV0aG9kKSB7XHJcbiAgICAgIGNhc2UgJ3B1c2gnOlxyXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcclxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnc3BsaWNlJzpcclxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XHJcbiAgICAvLyBub3RpZnkgY2hhbmdlXHJcbiAgICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcclxuXHJcbi8qKlxyXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcclxuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxyXG4gKi9cclxudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xyXG5cclxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xyXG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxyXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XHJcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XHJcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxyXG4gKi9cclxudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XHJcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xyXG4gIHRoaXMudm1Db3VudCA9IDA7XHJcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICBpZiAoaGFzUHJvdG8pIHtcclxuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcclxuICAgIH1cclxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy53YWxrKHZhbHVlKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xyXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cclxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXHJcbiAqL1xyXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxyXG4gKi9cclxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gaGVscGVyc1xyXG5cclxuLyoqXHJcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xyXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xyXG4gKi9cclxuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXHJcbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcclxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xyXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXHJcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXHJcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcclxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIG9iO1xyXG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xyXG4gICAgb2IgPSB2YWx1ZS5fX29iX187XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIHNob3VsZE9ic2VydmUgJiZcclxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXHJcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXHJcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxyXG4gICAgIXZhbHVlLl9pc1Z1ZVxyXG4gICkge1xyXG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xyXG4gIH1cclxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xyXG4gICAgb2Iudm1Db3VudCsrO1xyXG4gIH1cclxuICByZXR1cm4gb2JcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcclxuICBvYmosXHJcbiAga2V5LFxyXG4gIHZhbCxcclxuICBjdXN0b21TZXR0ZXIsXHJcbiAgc2hhbGxvd1xyXG4pIHtcclxuICB2YXIgZGVwID0gbmV3IERlcCgpO1xyXG5cclxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcclxuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcclxuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xyXG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XHJcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgdmFsID0gb2JqW2tleV07XHJcbiAgfVxyXG5cclxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xyXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xyXG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cclxuICAgICAgaWYgKHNldHRlcikge1xyXG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YWwgPSBuZXdWYWw7XHJcbiAgICAgIH1cclxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcclxuICAgICAgZGVwLm5vdGlmeSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXHJcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcclxuICogYWxyZWFkeSBleGlzdC5cclxuICovXHJcbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXHJcbiAgKSB7XHJcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XHJcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xyXG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHZhbFxyXG4gIH1cclxuICBpZiAoIW9iKSB7XHJcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgIHJldHVybiB2YWxcclxuICB9XHJcbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcclxuICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgcmV0dXJuIHZhbFxyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxyXG4gICkge1xyXG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XHJcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xyXG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcclxuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcclxuICBpZiAoIW9iKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgb2IuZGVwLm5vdGlmeSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcclxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcclxuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBlID0gdmFsdWVbaV07XHJcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XHJcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxyXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxyXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cclxuICovXHJcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcclxuICovXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XHJcbiAgICBpZiAoIXZtKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcclxuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xyXG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxyXG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgdG9WYWwgPSB0b1trZXldO1xyXG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcclxuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XHJcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXHJcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXHJcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcclxuICAgICkge1xyXG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdG9cclxufVxyXG5cclxuLyoqXHJcbiAqIERhdGFcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxyXG4gIHBhcmVudFZhbCxcclxuICBjaGlsZFZhbCxcclxuICB2bVxyXG4pIHtcclxuICBpZiAoIXZtKSB7XHJcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xyXG4gICAgaWYgKCFjaGlsZFZhbCkge1xyXG4gICAgICByZXR1cm4gcGFyZW50VmFsXHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmVudFZhbCkge1xyXG4gICAgICByZXR1cm4gY2hpbGRWYWxcclxuICAgIH1cclxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcclxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxyXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXHJcbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcclxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XHJcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXHJcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxyXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XHJcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXHJcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxyXG4gICAgICAgIDogY2hpbGRWYWw7XHJcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcclxuICAgICAgICA6IHBhcmVudFZhbDtcclxuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXHJcbiAgcGFyZW50VmFsLFxyXG4gIGNoaWxkVmFsLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmICghdm0pIHtcclxuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50VmFsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXHJcbn07XHJcblxyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VIb29rIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWxcclxuKSB7XHJcbiAgcmV0dXJuIGNoaWxkVmFsXHJcbiAgICA/IHBhcmVudFZhbFxyXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcclxuICAgICAgICA/IGNoaWxkVmFsXHJcbiAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICA6IHBhcmVudFZhbFxyXG59XHJcblxyXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xyXG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcclxufSk7XHJcblxyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICBpZiAoY2hpbGRWYWwpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbn1cclxuXHJcbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcclxufSk7XHJcblxyXG4vKipcclxuICogV2F0Y2hlcnMuXHJcbiAqXHJcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcclxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXHJcbiAqL1xyXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXHJcbiAgcGFyZW50VmFsLFxyXG4gIGNoaWxkVmFsLFxyXG4gIHZtLFxyXG4gIGtleVxyXG4pIHtcclxuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxyXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxyXG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xyXG4gIH1cclxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxyXG4gIHZhciByZXQgPSB7fTtcclxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcclxuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xyXG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcclxuICAgIH1cclxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcclxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxyXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcblxyXG4vKipcclxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cclxuICovXHJcbnN0cmF0cy5wcm9wcyA9XHJcbnN0cmF0cy5tZXRob2RzID1cclxuc3RyYXRzLmluamVjdCA9XHJcbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcclxuICB9XHJcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cclxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxyXG4gKi9cclxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcclxuICAgID8gcGFyZW50VmFsXHJcbiAgICA6IGNoaWxkVmFsXHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcclxuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XHJcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xyXG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xyXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXHJcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xyXG4gICAgICAnaWQ6ICcgKyBuYW1lXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxyXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XHJcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcclxuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIHZhciBpLCB2YWwsIG5hbWU7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XHJcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICB2YWwgPSBwcm9wc1tpXTtcclxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XHJcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xyXG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xyXG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcclxuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxuICBvcHRpb25zLnByb3BzID0gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xyXG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcclxuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxyXG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XHJcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcclxuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxyXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcclxuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xyXG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xyXG4gIGlmIChkaXJzKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xyXG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xyXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcclxuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcclxuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cclxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXHJcbiAgcGFyZW50LFxyXG4gIGNoaWxkLFxyXG4gIHZtXHJcbikge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcclxuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcclxuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcclxuICBcclxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXHJcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxyXG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cclxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXHJcbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xyXG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcclxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoaWxkLm1peGlucykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICB2YXIga2V5O1xyXG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xyXG4gICAgbWVyZ2VGaWVsZChrZXkpO1xyXG4gIH1cclxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XHJcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XHJcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb25zXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcclxuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcclxuICBvcHRpb25zLFxyXG4gIHR5cGUsXHJcbiAgaWQsXHJcbiAgd2Fybk1pc3NpbmdcclxuKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcclxuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxyXG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cclxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cclxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXHJcbiAgICAgIG9wdGlvbnNcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXHJcbiAga2V5LFxyXG4gIHByb3BPcHRpb25zLFxyXG4gIHByb3BzRGF0YSxcclxuICB2bVxyXG4pIHtcclxuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XHJcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xyXG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xyXG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcclxuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcclxuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXHJcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxyXG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xyXG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XHJcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcclxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xyXG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxyXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXHJcbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xyXG4gIH1cclxuICBpZiAoXHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xyXG4gICAgIShmYWxzZSlcclxuICApIHtcclxuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcclxuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXHJcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIH1cclxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xyXG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXHJcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcclxuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcclxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cclxuICB9XHJcbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcclxuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XHJcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXHJcbiAgICA/IGRlZi5jYWxsKHZtKVxyXG4gICAgOiBkZWZcclxufVxyXG5cclxuLyoqXHJcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxyXG4gIHByb3AsXHJcbiAgbmFtZSxcclxuICB2YWx1ZSxcclxuICB2bSxcclxuICBhYnNlbnRcclxuKSB7XHJcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcclxuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xyXG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XHJcbiAgaWYgKHR5cGUpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICB0eXBlID0gW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xyXG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XHJcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXZhbGlkKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XHJcbiAgaWYgKHZhbGlkYXRvcikge1xyXG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xyXG4gIHZhciB2YWxpZDtcclxuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcclxuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcclxuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xyXG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB2YWxpZDogdmFsaWQsXHJcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcclxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXHJcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XHJcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcclxuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xyXG4gICAgICByZXR1cm4gaVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gLTFcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xyXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XHJcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gIHZhciByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcclxuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcclxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XHJcbiAgfVxyXG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xyXG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxyXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XHJcbiAgfVxyXG4gIHJldHVybiBtZXNzYWdlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XHJcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XHJcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xyXG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcclxuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xyXG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuXHJcbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcclxuICBpZiAodm0pIHtcclxuICAgIHZhciBjdXIgPSB2bTtcclxuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XHJcbiAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xyXG4gICAgICBpZiAoaG9va3MpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcclxuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xyXG4gICAgfVxyXG4gIH1cclxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgY2FsbGJhY2tzID0gW107XHJcbnZhciBwZW5kaW5nID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XHJcbiAgcGVuZGluZyA9IGZhbHNlO1xyXG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvcGllc1tpXSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvdGFza3MgYW5kIChtYWNybykgdGFza3MuXHJcbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXHJcbi8vIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxyXG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxyXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXHJcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cclxuLy8gSGVyZSB3ZSB1c2UgbWljcm90YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgKG1hY3JvKSB0YXNrIHdoZW5cclxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxyXG52YXIgbWljcm9UaW1lckZ1bmM7XHJcbnZhciBtYWNyb1RpbWVyRnVuYztcclxudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xyXG5cclxuLy8gRGV0ZXJtaW5lIChtYWNybykgdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cclxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxyXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXHJcbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XHJcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xyXG4gIH07XHJcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXHJcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XHJcbiAgLy8gUGhhbnRvbUpTXHJcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXHJcbikpIHtcclxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xyXG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcclxuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xyXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcclxuICB9O1xyXG59IGVsc2Uge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBEZXRlcm1pbmUgbWljcm90YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXHJcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcclxuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcclxuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxyXG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXHJcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXHJcbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cclxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICAvLyBmYWxsYmFjayB0byBtYWNyb1xyXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxyXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgKG1hY3JvKSB0YXNrIGluc3RlYWQgb2YgYSBtaWNyb3Rhc2suXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xyXG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7ICAgIFxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XHJcbiAgdmFyIF9yZXNvbHZlO1xyXG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjYikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNiLmNhbGwoY3R4KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcclxuICAgICAgX3Jlc29sdmUoY3R4KTtcclxuICAgIH1cclxuICB9KTtcclxuICBpZiAoIXBlbmRpbmcpIHtcclxuICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xyXG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgbWFyaztcclxudmFyIG1lYXN1cmU7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoXHJcbiAgICBwZXJmICYmXHJcbiAgICBwZXJmLm1hcmsgJiZcclxuICAgIHBlcmYubWVhc3VyZSAmJlxyXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXHJcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcclxuICApIHtcclxuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcclxuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xyXG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XHJcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXHJcblxyXG52YXIgaW5pdFByb3h5O1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxyXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXHJcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXHJcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xyXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcclxuICApO1xyXG5cclxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcclxuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXHJcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXHJcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcclxuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXHJcbiAgICAgIHRhcmdldFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xyXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xyXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXHJcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXHJcbiAgICAgIHRhcmdldFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB2YXIgaGFzUHJveHkgPVxyXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XHJcblxyXG4gIGlmIChoYXNQcm94eSkge1xyXG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xyXG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcclxuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhhc0hhbmRsZXIgPSB7XHJcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XHJcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XHJcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcclxuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xyXG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cclxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGdldEhhbmRsZXIgPSB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XHJcbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcclxuICAgIGlmIChoYXNQcm94eSkge1xyXG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcclxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxyXG4gICAgICAgID8gZ2V0SGFuZGxlclxyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcclxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XHJcblxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcclxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcclxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcclxuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XHJcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcclxuICB2YXIgaSwga2V5cztcclxuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xyXG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodmFsLl9fb2JfXykge1xyXG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XHJcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xyXG4gIH1cclxuICBpZiAoaXNBKSB7XHJcbiAgICBpID0gdmFsLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cclxuICB9IGVsc2Uge1xyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICBpID0ga2V5cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xyXG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcclxuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxyXG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xyXG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6IG5hbWUsXHJcbiAgICBvbmNlOiBvbmNlJCQxLFxyXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcclxuICAgIHBhc3NpdmU6IHBhc3NpdmVcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcclxuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcclxuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcclxuXHJcbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XHJcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xyXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcclxuICAgIH1cclxuICB9XHJcbiAgaW52b2tlci5mbnMgPSBmbnM7XHJcbiAgcmV0dXJuIGludm9rZXJcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcclxuICBvbixcclxuICBvbGRPbixcclxuICBhZGQsXHJcbiAgcmVtb3ZlJCQxLFxyXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcclxuICBmb3IgKG5hbWUgaW4gb24pIHtcclxuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xyXG4gICAgb2xkID0gb2xkT25bbmFtZV07XHJcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XHJcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XHJcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XHJcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgICB9XHJcbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XHJcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XHJcbiAgICAgIG9sZC5mbnMgPSBjdXI7XHJcbiAgICAgIG9uW25hbWVdID0gb2xkO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcclxuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xyXG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XHJcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xyXG4gIH1cclxuICB2YXIgaW52b2tlcjtcclxuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcclxuXHJcbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xyXG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxyXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcclxuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcclxuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcclxuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XHJcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcclxuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXHJcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XHJcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcclxuICBkYXRhLFxyXG4gIEN0b3IsXHJcbiAgdGFnXHJcbikge1xyXG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxyXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxyXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xyXG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciByZXMgPSB7fTtcclxuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xyXG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XHJcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xyXG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxyXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRpcChcclxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xyXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xyXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcclxuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcclxuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcclxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxyXG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxyXG4gIHJlcyxcclxuICBoYXNoLFxyXG4gIGtleSxcclxuICBhbHRLZXksXHJcbiAgcHJlc2VydmVcclxuKSB7XHJcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XHJcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcclxuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XHJcbiAgICAgIGlmICghcHJlc2VydmUpIHtcclxuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XHJcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xyXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcclxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cclxuLy9cclxuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcclxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxyXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XHJcblxyXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcclxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXHJcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxyXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjaGlsZHJlblxyXG59XHJcblxyXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxyXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxyXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxyXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cclxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxyXG4gICAgICA6IHVuZGVmaW5lZFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XHJcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XHJcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjID0gY2hpbGRyZW5baV07XHJcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cclxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xyXG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xyXG4gICAgLy8gIG5lc3RlZFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcclxuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XHJcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcclxuICAgICAgICAgIGMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xyXG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXHJcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXHJcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcclxuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxyXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxyXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXHJcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcclxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXHJcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcclxuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzLnB1c2goYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcclxuICBpZiAoXHJcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcclxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcclxuICApIHtcclxuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBpc09iamVjdChjb21wKVxyXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxyXG4gICAgOiBjb21wXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxyXG4gIGZhY3RvcnksXHJcbiAgZGF0YSxcclxuICBjb250ZXh0LFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRhZ1xyXG4pIHtcclxuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcclxuICByZXR1cm4gbm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxyXG4gIGZhY3RvcnksXHJcbiAgYmFzZUN0b3IsXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXHJcbiAgfVxyXG5cclxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcclxuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xyXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xyXG4gICAgdmFyIHN5bmMgPSB0cnVlO1xyXG5cclxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xyXG4gICAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcclxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XHJcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcclxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXHJcbiAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXHJcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcclxuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcclxuXHJcbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxyXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcblxyXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XHJcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XHJcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xyXG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xyXG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXHJcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzeW5jID0gZmFsc2U7XHJcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XHJcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXHJcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxyXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcclxuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcclxuICAgICAgICByZXR1cm4gY1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcclxuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XHJcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXHJcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHRhcmdldDtcclxuXHJcbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XHJcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XHJcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xyXG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XHJcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIGlmIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxyXG4gIHZtLFxyXG4gIGxpc3RlbmVycyxcclxuICBvbGRMaXN0ZW5lcnNcclxuKSB7XHJcbiAgdGFyZ2V0ID0gdm07XHJcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xyXG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xyXG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcclxuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXHJcbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxyXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XHJcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgZnVuY3Rpb24gb24gKCkge1xyXG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XHJcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgb24uZm4gPSBmbjtcclxuICAgIHZtLiRvbihldmVudCwgb24pO1xyXG4gICAgcmV0dXJuIHZtXHJcbiAgfTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIC8vIGFsbFxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICByZXR1cm4gdm1cclxuICAgIH1cclxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdm0uJG9mZihldmVudFtpXSwgZm4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgIGlmICghY2JzKSB7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgaWYgKCFmbikge1xyXG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgdmFyIGNiO1xyXG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkkMS0tKSB7XHJcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcclxuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XHJcbiAgICAgICAgdGlwKFxyXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXHJcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXHJcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcclxuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XHJcbiAgICBpZiAoY2JzKSB7XHJcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXHJcbiAgY2hpbGRyZW4sXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICB2YXIgc2xvdHMgPSB7fTtcclxuICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICByZXR1cm4gc2xvdHNcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xyXG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxyXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcclxuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcclxuICAgIH1cclxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxyXG4gICAgLy8gc2FtZSBjb250ZXh0LlxyXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcclxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xyXG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xyXG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxyXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xyXG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xyXG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNsb3RzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xyXG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxyXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcclxuICByZXNcclxuKSB7XHJcbiAgcmVzID0gcmVzIHx8IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XHJcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xyXG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xyXG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcclxuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuXHJcbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcclxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcclxuICAgIH1cclxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XHJcbiAgfVxyXG5cclxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xyXG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XHJcblxyXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xyXG4gIHZtLiRyZWZzID0ge307XHJcblxyXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcclxuICB2bS5faW5hY3RpdmUgPSBudWxsO1xyXG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xyXG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcclxuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcclxuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XHJcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xyXG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcclxuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XHJcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcclxuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xyXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXHJcbiAgICBpZiAoIXByZXZWbm9kZSkge1xyXG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHVwZGF0ZXNcclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XHJcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcclxuICAgIGlmIChwcmV2RWwpIHtcclxuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxyXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcclxuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XHJcbiAgICB9XHJcbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXHJcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xyXG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcclxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xyXG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xyXG4gICAgfVxyXG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcclxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cclxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcclxuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcclxuICAgIH1cclxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxyXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxyXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XHJcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXHJcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xyXG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cclxuICAgIHZtLiRvZmYoKTtcclxuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxyXG4gICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXHJcbiAgICBpZiAodm0uJHZub2RlKSB7XHJcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcclxuICB2bSxcclxuICBlbCxcclxuICBoeWRyYXRpbmdcclxuKSB7XHJcbiAgdm0uJGVsID0gZWw7XHJcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcclxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXHJcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcclxuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XHJcblxyXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcclxuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcclxuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xyXG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcclxuXHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XHJcbiAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcclxuXHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xyXG4gICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxyXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcclxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XHJcbiAgICAgIGlmICh2bS5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcclxuICBoeWRyYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcclxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xyXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xyXG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcclxuICB9XHJcbiAgcmV0dXJuIHZtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcclxuICB2bSxcclxuICBwcm9wc0RhdGEsXHJcbiAgbGlzdGVuZXJzLFxyXG4gIHBhcmVudFZub2RlLFxyXG4gIHJlbmRlckNoaWxkcmVuXHJcbikge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXHJcbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cclxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcclxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcclxuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcclxuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcclxuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcclxuICApO1xyXG5cclxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcclxuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxyXG5cclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XHJcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XHJcbiAgfVxyXG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xyXG5cclxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcclxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcclxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcclxuXHJcbiAgLy8gdXBkYXRlIHByb3BzXHJcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcclxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcclxuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xyXG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XHJcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XHJcbiAgICB9XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXHJcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xyXG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XHJcblxyXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXHJcbiAgaWYgKGhhc0NoaWxkcmVuKSB7XHJcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xyXG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xyXG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xyXG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XHJcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xyXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XHJcbiAgaWYgKGRpcmVjdCkge1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcclxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcclxuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xyXG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcclxuICBwdXNoVGFyZ2V0KCk7XHJcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XHJcbiAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcclxuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcclxuICB9XHJcbiAgcG9wVGFyZ2V0KCk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XHJcblxyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XHJcbnZhciBoYXMgPSB7fTtcclxudmFyIGNpcmN1bGFyID0ge307XHJcbnZhciB3YWl0aW5nID0gZmFsc2U7XHJcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xyXG52YXIgaW5kZXggPSAwO1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xyXG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICBoYXMgPSB7fTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgY2lyY3VsYXIgPSB7fTtcclxuICB9XHJcbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xyXG4gIGZsdXNoaW5nID0gdHJ1ZTtcclxuICB2YXIgd2F0Y2hlciwgaWQ7XHJcblxyXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXHJcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxyXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcclxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxyXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cclxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XHJcblxyXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxyXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xyXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcclxuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xyXG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xyXG4gICAgfVxyXG4gICAgaWQgPSB3YXRjaGVyLmlkO1xyXG4gICAgaGFzW2lkXSA9IG51bGw7XHJcbiAgICB3YXRjaGVyLnJ1bigpO1xyXG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xyXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXHJcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcclxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgd2F0Y2hlci52bVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxyXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XHJcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XHJcblxyXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcclxuXHJcbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXHJcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcclxuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XHJcblxyXG4gIC8vIGRldnRvb2wgaG9va1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcclxuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xyXG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XHJcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xyXG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXHJcbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xyXG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cclxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxyXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xyXG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcclxuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cclxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXHJcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XHJcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcclxuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XHJcbiAgICBoYXNbaWRdID0gdHJ1ZTtcclxuICAgIGlmICghZmx1c2hpbmcpIHtcclxuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcclxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cclxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xyXG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXHJcbiAgICBpZiAoIXdhaXRpbmcpIHtcclxuICAgICAgd2FpdGluZyA9IHRydWU7XHJcblxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XHJcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcbnZhciB1aWQkMSA9IDA7XHJcblxyXG4vKipcclxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXHJcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxyXG4gKi9cclxudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcclxuICB2bSxcclxuICBleHBPckZuLFxyXG4gIGNiLFxyXG4gIG9wdGlvbnMsXHJcbiAgaXNSZW5kZXJXYXRjaGVyXHJcbikge1xyXG4gIHRoaXMudm0gPSB2bTtcclxuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XHJcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XHJcbiAgfVxyXG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xyXG4gIC8vIG9wdGlvbnNcclxuICBpZiAob3B0aW9ucykge1xyXG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XHJcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcclxuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xyXG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XHJcbiAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcclxuICB9XHJcbiAgdGhpcy5jYiA9IGNiO1xyXG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXHJcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXHJcbiAgdGhpcy5kZXBzID0gW107XHJcbiAgdGhpcy5uZXdEZXBzID0gW107XHJcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xyXG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXHJcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxyXG4gICAgOiAnJztcclxuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XHJcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XHJcbiAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xyXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXHJcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XHJcbiAgICA/IHVuZGVmaW5lZFxyXG4gICAgOiB0aGlzLmdldCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgcHVzaFRhcmdldCh0aGlzKTtcclxuICB2YXIgdmFsdWU7XHJcbiAgdmFyIHZtID0gdGhpcy52bTtcclxuICB0cnkge1xyXG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IGVcclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXHJcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcclxuICAgIGlmICh0aGlzLmRlZXApIHtcclxuICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xyXG4gIHZhciBpZCA9IGRlcC5pZDtcclxuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcclxuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XHJcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xyXG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XHJcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcclxuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcclxuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xyXG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XHJcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XHJcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcclxuICB0bXAgPSB0aGlzLmRlcHM7XHJcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xyXG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcclxuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAodGhpcy5sYXp5KSB7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xyXG4gICAgdGhpcy5ydW4oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XHJcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xyXG4gICAgaWYgKFxyXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxyXG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cclxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxyXG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXHJcbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgICB0aGlzLmRlZXBcclxuICAgICkge1xyXG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXHJcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cclxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XHJcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xyXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxyXG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxyXG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cclxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgZ2V0OiBub29wLFxyXG4gIHNldDogbm9vcFxyXG59O1xyXG5cclxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXHJcbiAgfTtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xyXG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XHJcbiAgfTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcclxuICB2bS5fd2F0Y2hlcnMgPSBbXTtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xyXG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cclxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XHJcbiAgaWYgKG9wdHMuZGF0YSkge1xyXG4gICAgaW5pdERhdGEodm0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XHJcbiAgfVxyXG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cclxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xyXG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xyXG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XHJcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XHJcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcclxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cclxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xyXG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcclxuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICBpZiAoIWlzUm9vdCkge1xyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcclxuICB9XHJcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcclxuICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxyXG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcclxuICAgICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcclxuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXHJcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcclxuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcclxuICAgICAgICAgICAgdm1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcclxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XHJcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXHJcbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XHJcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xyXG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XHJcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xyXG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXHJcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXHJcbiAgICA6IGRhdGEgfHwge307XHJcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XHJcbiAgICBkYXRhID0ge307XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcclxuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcclxuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcclxuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XHJcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXHJcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xyXG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBvYnNlcnZlIGRhdGFcclxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XHJcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xyXG4gIHB1c2hUYXJnZXQoKTtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xyXG4gICAgcmV0dXJuIHt9XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHBvcFRhcmdldCgpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcclxuXHJcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XHJcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXHJcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XHJcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1NTUikge1xyXG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxyXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXHJcbiAgICAgICAgdm0sXHJcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXHJcbiAgICAgICAgbm9vcCxcclxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxyXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcclxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcclxuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XHJcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xyXG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcclxuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxyXG4gIHRhcmdldCxcclxuICBrZXksXHJcbiAgdXNlckRlZlxyXG4pIHtcclxuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxyXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcclxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxyXG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXHJcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxyXG4gICAgICA6IG5vb3A7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcclxuICB9XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xyXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcclxuICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XHJcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XHJcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXHJcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcclxuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xyXG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xyXG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxyXG4gIHZtLFxyXG4gIGV4cE9yRm4sXHJcbiAgaGFuZGxlcixcclxuICBvcHRpb25zXHJcbikge1xyXG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XHJcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcclxuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcclxuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcclxuICB9XHJcbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcclxuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcclxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcclxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXHJcbiAgdmFyIGRhdGFEZWYgPSB7fTtcclxuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcclxuICB2YXIgcHJvcHNEZWYgPSB7fTtcclxuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xyXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG4gICAgfTtcclxuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcclxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxyXG4gICAgZXhwT3JGbixcclxuICAgIGNiLFxyXG4gICAgb3B0aW9uc1xyXG4gICkge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xyXG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXHJcbiAgICB9XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XHJcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XHJcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xyXG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcclxuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgaWYgKHByb3ZpZGUpIHtcclxuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxyXG4gICAgICA6IHByb3ZpZGU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcclxuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICBpZiAocmVzdWx0KSB7XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcclxuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXHJcbiAgICAgICAgICAgIHZtXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XHJcbiAgaWYgKGluamVjdCkge1xyXG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcclxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcclxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcclxuICAgICAgfSlcclxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xyXG4gICAgICB2YXIgc291cmNlID0gdm07XHJcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcclxuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xyXG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcclxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcclxuICB2YWwsXHJcbiAgcmVuZGVyXHJcbikge1xyXG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xyXG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGlzRGVmKHJldCkpIHtcclxuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXHJcbiAgbmFtZSxcclxuICBmYWxsYmFjayxcclxuICBwcm9wcyxcclxuICBiaW5kT2JqZWN0XHJcbikge1xyXG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcclxuICB2YXIgbm9kZXM7XHJcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxyXG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICAgIGlmIChiaW5kT2JqZWN0KSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXHJcbiAgICAgICAgICB0aGlzXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XHJcbiAgfVxyXG5cclxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcclxuICBpZiAodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5vZGVzXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XHJcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xyXG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cclxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXHJcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXHJcbiAgZXZlbnRLZXlDb2RlLFxyXG4gIGtleSxcclxuICBidWlsdEluS2V5Q29kZSxcclxuICBldmVudEtleU5hbWUsXHJcbiAgYnVpbHRJbktleU5hbWVcclxuKSB7XHJcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcclxuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xyXG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcclxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcclxuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcclxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xyXG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxyXG4gIGRhdGEsXHJcbiAgdGFnLFxyXG4gIHZhbHVlLFxyXG4gIGFzUHJvcCxcclxuICBpc1N5bmNcclxuKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaGFzaDtcclxuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcclxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxyXG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBoYXNoID0gZGF0YTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcclxuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxyXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcclxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkgJiYgIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkpIHtcclxuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XHJcblxyXG4gICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBjYW1lbGl6ZWRLZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcclxuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcclxuICBpbmRleCxcclxuICBpc0luRm9yXHJcbikge1xyXG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XHJcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xyXG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxyXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxyXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XHJcbiAgICByZXR1cm4gdHJlZVxyXG4gIH1cclxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXHJcbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcclxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxyXG4gICAgbnVsbCxcclxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcclxuICApO1xyXG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XHJcbiAgcmV0dXJuIHRyZWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXHJcbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFya09uY2UgKFxyXG4gIHRyZWUsXHJcbiAgaW5kZXgsXHJcbiAga2V5XHJcbikge1xyXG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xyXG4gIHJldHVybiB0cmVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxyXG4gIHRyZWUsXHJcbiAga2V5LFxyXG4gIGlzT25jZVxyXG4pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xyXG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xyXG4gIG5vZGUua2V5ID0ga2V5O1xyXG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcclxuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XHJcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XHJcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XHJcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XHJcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcclxuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xyXG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XHJcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xyXG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcclxuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xyXG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XHJcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xyXG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcclxuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xyXG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcclxuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcclxuICBkYXRhLFxyXG4gIHByb3BzLFxyXG4gIGNoaWxkcmVuLFxyXG4gIHBhcmVudCxcclxuICBDdG9yXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcclxuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXHJcbiAgdmFyIGNvbnRleHRWbTtcclxuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xyXG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cclxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxyXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxyXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xyXG4gIH1cclxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XHJcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XHJcblxyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XHJcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcclxuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xyXG5cclxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgaWYgKGlzQ29tcGlsZWQpIHtcclxuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxyXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXHJcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcclxuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcclxuICB9XHJcblxyXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XHJcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcclxuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XHJcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2bm9kZVxyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xyXG4gIH1cclxufVxyXG5cclxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgcHJvcHNEYXRhLFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dFZtLFxyXG4gIGNoaWxkcmVuXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIHZhciBwcm9wcyA9IHt9O1xyXG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cclxuICB9XHJcblxyXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxyXG4gICAgZGF0YSxcclxuICAgIHByb3BzLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBjb250ZXh0Vm0sXHJcbiAgICBDdG9yXHJcbiAgKTtcclxuXHJcbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcclxuXHJcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xyXG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XHJcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcclxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcclxuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cclxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XHJcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XHJcbiAgfVxyXG4gIGlmIChkYXRhLnNsb3QpIHtcclxuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xyXG4gIH1cclxuICByZXR1cm4gY2xvbmVcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcclxuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qICAqL1xyXG5cclxuLyogICovXHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXHJcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xyXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgIGlmIChcclxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcclxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxyXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxyXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcclxuICAgICAgKTtcclxuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxyXG4gICAgICBjaGlsZCxcclxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcclxuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXHJcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXHJcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xyXG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xyXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcclxuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcclxuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcclxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XHJcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXHJcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxyXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cclxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcclxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgZGF0YSxcclxuICBjb250ZXh0LFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRhZ1xyXG4pIHtcclxuICBpZiAoaXNVbmRlZihDdG9yKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xyXG5cclxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcclxuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XHJcbiAgfVxyXG5cclxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXHJcbiAgLy8gcmVqZWN0LlxyXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxyXG4gIHZhciBhc3luY0ZhY3Rvcnk7XHJcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XHJcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xyXG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcclxuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxyXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cclxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxyXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcclxuICAgICAgICBhc3luY0ZhY3RvcnksXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHRhZ1xyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkYXRhID0gZGF0YSB8fCB7fTtcclxuXHJcbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxyXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XHJcblxyXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcclxuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcclxuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XHJcbiAgfVxyXG5cclxuICAvLyBleHRyYWN0IHByb3BzXHJcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcclxuXHJcbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcclxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcclxuICB9XHJcblxyXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXHJcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcclxuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcclxuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xyXG5cclxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcclxuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcclxuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XHJcblxyXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XHJcbiAgICBkYXRhID0ge307XHJcbiAgICBpZiAoc2xvdCkge1xyXG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXHJcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xyXG5cclxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxyXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xyXG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXHJcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxyXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcclxuICAgIGFzeW5jRmFjdG9yeVxyXG4gICk7XHJcblxyXG4gIHJldHVybiB2bm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcclxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XHJcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxyXG4pIHtcclxuICB2YXIgb3B0aW9ucyA9IHtcclxuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcclxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXHJcbiAgICBwYXJlbnQ6IHBhcmVudFxyXG4gIH07XHJcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcclxuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xyXG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcclxuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xyXG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xyXG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcclxuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xyXG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcclxuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcclxuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcclxuICAgIGYxKGEsIGIpO1xyXG4gICAgZjIoYSwgYik7XHJcbiAgfTtcclxuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XHJcbiAgcmV0dXJuIG1lcmdlZFxyXG59XHJcblxyXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXHJcbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xyXG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xyXG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcclxuICA7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcclxuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcclxuICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xyXG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcclxuICAgIGlmIChcclxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcclxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxyXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXHJcbiAgICApIHtcclxuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xyXG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XHJcblxyXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxyXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZSxcclxuICBhbHdheXNOb3JtYWxpemVcclxuKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XHJcbiAgICBjaGlsZHJlbiA9IGRhdGE7XHJcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcclxuICB9XHJcbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZVxyXG4pIHtcclxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcclxuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXHJcbiAgICAgIGNvbnRleHRcclxuICAgICk7XHJcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXHJcbiAgfVxyXG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXHJcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XHJcbiAgICB0YWcgPSBkYXRhLmlzO1xyXG4gIH1cclxuICBpZiAoIXRhZykge1xyXG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxyXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxyXG4gIH1cclxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcclxuICApIHtcclxuICAgIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xyXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXHJcbiAgICAgICAgY29udGV4dFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXHJcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcclxuICApIHtcclxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xyXG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcclxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xyXG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xyXG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgfVxyXG4gIHZhciB2bm9kZSwgbnM7XHJcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgQ3RvcjtcclxuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XHJcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xyXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXHJcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XHJcbiAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xyXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xyXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxyXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxyXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXHJcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xyXG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxyXG4gICAgcmV0dXJuIHZub2RlXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcclxuICB2bm9kZS5ucyA9IG5zO1xyXG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xyXG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XHJcbiAgICBucyA9IHVuZGVmaW5lZDtcclxuICAgIGZvcmNlID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcclxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcclxuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyByZWYgIzUzMThcclxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcclxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcclxuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcclxuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xyXG4gIH1cclxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcclxuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xyXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXHJcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xyXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXHJcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xyXG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XHJcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XHJcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXHJcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cclxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXHJcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcclxuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XHJcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXHJcbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXHJcbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XHJcblxyXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXHJcbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxyXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICB9LCB0cnVlKTtcclxuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICB9LCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xyXG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcclxuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xyXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XHJcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcclxuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xyXG5cclxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcclxuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xyXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXHJcbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XHJcbiAgICAvLyByZW5kZXIgc2VsZlxyXG4gICAgdmFyIHZub2RlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xyXG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcclxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xyXG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XHJcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBzZXQgcGFyZW50XHJcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB1aWQkMyA9IDA7XHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xyXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIC8vIGEgdWlkXHJcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcclxuXHJcbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xyXG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcclxuICAgICAgbWFyayhzdGFydFRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcclxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XHJcbiAgICAvLyBtZXJnZSBvcHRpb25zXHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xyXG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxyXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXHJcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxyXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXHJcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXHJcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGluaXRQcm94eSh2bSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcclxuICAgIH1cclxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcclxuICAgIHZtLl9zZWxmID0gdm07XHJcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcclxuICAgIGluaXRFdmVudHModm0pO1xyXG4gICAgaW5pdFJlbmRlcih2bSk7XHJcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xyXG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcclxuICAgIGluaXRTdGF0ZSh2bSk7XHJcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXHJcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xyXG4gICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xyXG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcclxuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxyXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xyXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcclxuXHJcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xyXG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XHJcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XHJcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcclxuXHJcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xyXG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcclxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcclxuICBpZiAoQ3Rvci5zdXBlcikge1xyXG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XHJcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XHJcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcclxuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXHJcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cclxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcclxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XHJcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXHJcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xyXG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb25zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcclxuICB2YXIgbW9kaWZpZWQ7XHJcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcclxuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XHJcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcclxuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XHJcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XHJcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxyXG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBtb2RpZmllZFxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xyXG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXHJcbiAgLy8gYmV0d2VlbiBtZXJnZXNcclxuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcclxuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xyXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcclxuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBsYXRlc3RcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXHJcbiAgKSB7XHJcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XHJcbiAgfVxyXG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbn1cclxuXHJcbmluaXRNaXhpbihWdWUpO1xyXG5zdGF0ZU1peGluKFZ1ZSk7XHJcbmV2ZW50c01peGluKFZ1ZSk7XHJcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XHJcbnJlbmRlck1peGluKFZ1ZSk7XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xyXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XHJcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcclxuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcclxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XHJcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XHJcbiAgLyoqXHJcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXHJcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxyXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxyXG4gICAqL1xyXG4gIFZ1ZS5jaWQgPSAwO1xyXG4gIHZhciBjaWQgPSAxO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxyXG4gICAqL1xyXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xyXG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xyXG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XHJcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xyXG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcclxuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xyXG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgIFN1Yi5jaWQgPSBjaWQrKztcclxuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxyXG4gICAgICBTdXBlci5vcHRpb25zLFxyXG4gICAgICBleHRlbmRPcHRpb25zXHJcbiAgICApO1xyXG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcblxyXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cclxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXHJcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXHJcbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcclxuICAgIH1cclxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxyXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcclxuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXHJcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xyXG4gICAgfSk7XHJcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXHJcbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxyXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxyXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XHJcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XHJcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXHJcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcclxuICAgIHJldHVybiBTdWJcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xyXG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcclxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcclxuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxyXG4gICAgICBpZCxcclxuICAgICAgZGVmaW5pdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XHJcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XHJcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcclxuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcclxufVxyXG5cclxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcclxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcclxuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcclxuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XHJcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcclxuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcclxuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcclxuICAgIGlmIChjYWNoZWROb2RlKSB7XHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xyXG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XHJcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXHJcbiAgY2FjaGUsXHJcbiAga2V5LFxyXG4gIGtleXMsXHJcbiAgY3VycmVudFxyXG4pIHtcclxuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcclxuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcclxuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xyXG4gIH1cclxuICBjYWNoZVtrZXldID0gbnVsbDtcclxuICByZW1vdmUoa2V5cywga2V5KTtcclxufVxyXG5cclxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xyXG5cclxudmFyIEtlZXBBbGl2ZSA9IHtcclxuICBuYW1lOiAna2VlcC1hbGl2ZScsXHJcbiAgYWJzdHJhY3Q6IHRydWUsXHJcblxyXG4gIHByb3BzOiB7XHJcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICB9LFxyXG5cclxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcclxuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdGhpcy5rZXlzID0gW107XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcclxuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xyXG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcclxuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xyXG4gICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcclxuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxyXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XHJcbiAgICAgICAgLy8gZXhjbHVkZWRcclxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB2bm9kZVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xyXG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcclxuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xyXG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcclxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xyXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcclxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcclxuICAgICAgICA6IHZub2RlLmtleTtcclxuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxyXG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcclxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcclxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcclxuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xyXG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xyXG4gIC8vIGNvbmZpZ1xyXG4gIHZhciBjb25maWdEZWYgPSB7fTtcclxuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xyXG5cclxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cclxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cclxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxyXG4gIFZ1ZS51dGlsID0ge1xyXG4gICAgd2Fybjogd2FybixcclxuICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXHJcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcclxuICB9O1xyXG5cclxuICBWdWUuc2V0ID0gc2V0O1xyXG4gIFZ1ZS5kZWxldGUgPSBkZWw7XHJcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XHJcblxyXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcclxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cclxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcclxuXHJcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcclxuXHJcbiAgaW5pdFVzZShWdWUpO1xyXG4gIGluaXRNaXhpbiQxKFZ1ZSk7XHJcbiAgaW5pdEV4dGVuZChWdWUpO1xyXG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xyXG59XHJcblxyXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcclxuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcclxuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcclxufSk7XHJcblxyXG5WdWUudmVyc2lvbiA9ICcyLjUuMTgnO1xyXG5cclxuLyogICovXHJcblxyXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcclxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXHJcbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XHJcblxyXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXHJcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcclxudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xyXG4gIHJldHVybiAoXHJcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxyXG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcclxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxyXG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxyXG4gIClcclxufTtcclxuXHJcbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XHJcblxyXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXHJcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXHJcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcclxuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcclxuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcclxuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcclxuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcclxuKTtcclxuXHJcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5cclxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcclxufTtcclxuXHJcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xyXG59O1xyXG5cclxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2VcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcclxuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcclxuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XHJcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XHJcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcclxuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxyXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxyXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxyXG4gICAgICA6IHBhcmVudC5jbGFzc1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxyXG4gIHN0YXRpY0NsYXNzLFxyXG4gIGR5bmFtaWNDbGFzc1xyXG4pIHtcclxuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcclxuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgcmV0dXJuICcnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xyXG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxyXG4gIH1cclxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxyXG4gIH1cclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHZhbHVlXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgcmV0dXJuICcnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xyXG4gIHZhciByZXMgPSAnJztcclxuICB2YXIgc3RyaW5naWZpZWQ7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XHJcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxyXG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xyXG4gIHZhciByZXMgPSAnJztcclxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZVtrZXldKSB7XHJcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxyXG4gICAgICByZXMgKz0ga2V5O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIG5hbWVzcGFjZU1hcCA9IHtcclxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXHJcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXHJcbn07XHJcblxyXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcclxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXHJcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcclxuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXHJcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcclxuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXHJcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xyXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcclxuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcclxuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcclxuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xyXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xyXG4pO1xyXG5cclxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XHJcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXHJcbnZhciBpc1NWRyA9IG1ha2VNYXAoXHJcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcclxuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxyXG4gIHRydWVcclxuKTtcclxuXHJcbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XHJcblxyXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcclxuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcclxuICBpZiAoaXNTVkcodGFnKSkge1xyXG4gICAgcmV0dXJuICdzdmcnXHJcbiAgfVxyXG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxyXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcclxuICBpZiAodGFnID09PSAnbWF0aCcpIHtcclxuICAgIHJldHVybiAnbWF0aCdcclxuICB9XHJcbn1cclxuXHJcbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFpbkJyb3dzZXIpIHtcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcclxuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cclxuICB9XHJcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcclxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxyXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxyXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XHJcbiAgICApKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XHJcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xyXG4gICAgaWYgKCFzZWxlY3RlZCkge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3RlZFxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZWxcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xyXG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xyXG4gICAgcmV0dXJuIGVsbVxyXG4gIH1cclxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxyXG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xyXG4gIH1cclxuICByZXR1cm4gZWxtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcclxuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XHJcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcclxufVxyXG5cclxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLnRhZ05hbWVcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcclxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xyXG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcclxufVxyXG5cclxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxyXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxyXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcclxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxyXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxyXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcclxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXHJcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcclxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXHJcbiAgdGFnTmFtZTogdGFnTmFtZSxcclxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXHJcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHJlZiA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcclxuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcclxuICB9LFxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcclxuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xyXG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XHJcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xyXG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxyXG5cclxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xyXG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XHJcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcclxuICBpZiAoaXNSZW1vdmFsKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XHJcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XHJcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XHJcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcclxuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcclxuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xyXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcclxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiAqXHJcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxyXG4gKlxyXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XHJcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxyXG4gKi9cclxuXHJcbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XHJcblxyXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcclxuXHJcbmZ1bmN0aW9uIGNoaWxkcmVuSWdub3JlZCAodm5vZGUpIHtcclxuICByZXR1cm4gdm5vZGUgJiYgdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmRvbVByb3BzICYmIChcclxuICAgIHZub2RlLmRhdGEuZG9tUHJvcHMuaW5uZXJIVE1MIHx8IHZub2RlLmRhdGEuZG9tUHJvcHMudGV4dENvbnRlbnRcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xyXG4gIHJldHVybiAoXHJcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxyXG4gICAgICAoXHJcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXHJcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXHJcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxyXG4gICAgICAgICFjaGlsZHJlbklnbm9yZWQoYSkgJiYgIWNoaWxkcmVuSWdub3JlZChiKSAmJlxyXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcclxuICAgICAgKSB8fCAoXHJcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxyXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxyXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXHJcbiAgICAgIClcclxuICAgIClcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcclxuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxyXG4gIHZhciBpO1xyXG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XHJcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcclxuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcclxuICB2YXIgaSwga2V5O1xyXG4gIHZhciBtYXAgPSB7fTtcclxuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xyXG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xyXG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XHJcbiAgfVxyXG4gIHJldHVybiBtYXBcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xyXG4gIHZhciBpLCBqO1xyXG4gIHZhciBjYnMgPSB7fTtcclxuXHJcbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XHJcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xyXG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcclxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XHJcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcclxuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcclxuICAgIHJldHVybiByZW1vdmUkJDFcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcclxuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxyXG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICFpblZQcmUgJiZcclxuICAgICAgIXZub2RlLm5zICYmXHJcbiAgICAgICEoXHJcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcclxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcclxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXHJcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcclxuICAgICAgICB9KVxyXG4gICAgICApICYmXHJcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcclxuICAgIClcclxuICB9XHJcblxyXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXHJcbiAgICB2bm9kZSxcclxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcclxuICAgIHBhcmVudEVsbSxcclxuICAgIHJlZkVsbSxcclxuICAgIG5lc3RlZCxcclxuICAgIG93bmVyQXJyYXksXHJcbiAgICBpbmRleFxyXG4gICkge1xyXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcclxuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcclxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cclxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcclxuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXHJcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xyXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xyXG4gICAgaWYgKGlzRGVmKHRhZykpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xyXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXHJcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXHJcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xyXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcclxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcclxuICAgICAgc2V0U2NvcGUodm5vZGUpO1xyXG5cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIHtcclxuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XHJcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XHJcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XHJcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcclxuICAgIGlmIChpc0RlZihpKSkge1xyXG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XHJcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxyXG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcclxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXHJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXHJcbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XHJcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcclxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xyXG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xyXG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgc2V0U2NvcGUodm5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXHJcbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcclxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xyXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXHJcbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXHJcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcclxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXHJcbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XHJcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XHJcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcclxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXHJcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcclxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XHJcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XHJcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcclxuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcclxuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XHJcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcclxuICAgIH1cclxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXHJcbiAgICBpZiAoaXNEZWYoaSkpIHtcclxuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxyXG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cclxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxyXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cclxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcclxuICAgIHZhciBpO1xyXG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XHJcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cclxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXHJcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcclxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXHJcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxyXG4gICAgKSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xyXG4gICAgdmFyIGksIGo7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cclxuICAgIH1cclxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xyXG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xyXG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xyXG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcclxuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xyXG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxyXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XHJcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xyXG4gICAgICBpZiAoaXNEZWYocm0pKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXHJcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxyXG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcclxuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXHJcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xyXG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XHJcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJtKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XHJcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xyXG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcclxuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xyXG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcclxuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XHJcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcclxuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XHJcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xyXG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcclxuXHJcbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cclxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcclxuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXHJcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcclxuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcclxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcclxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xyXG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xyXG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XHJcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcclxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcclxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcclxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XHJcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xyXG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcclxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XHJcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxyXG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXHJcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxyXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxyXG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xyXG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcclxuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xyXG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XHJcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcclxuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcclxuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xyXG4gICAgdmFyIHNlZW5LZXlzID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xyXG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xyXG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XHJcbiAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxyXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XHJcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXHJcbiAgICBvbGRWbm9kZSxcclxuICAgIHZub2RlLFxyXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxyXG4gICAgb3duZXJBcnJheSxcclxuICAgIGluZGV4LFxyXG4gICAgcmVtb3ZlT25seVxyXG4gICkge1xyXG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xyXG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcclxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XHJcblxyXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XHJcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxyXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXHJcbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cclxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXHJcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxyXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXHJcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXHJcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxyXG4gICAgKSB7XHJcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xyXG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XHJcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XHJcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcclxuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcclxuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XHJcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XHJcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XHJcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xyXG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXHJcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxyXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xyXG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XHJcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcclxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cclxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xyXG5cclxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxyXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XHJcbiAgICB2bm9kZS5lbG0gPSBlbG07XHJcblxyXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcclxuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XHJcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXHJcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxyXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xyXG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xyXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XHJcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xyXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcclxuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXHJcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcclxuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xyXG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcclxuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxyXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXHJcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgIClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XHJcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcclxuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XHJcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XHJcblxyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XHJcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcclxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xyXG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcclxuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XHJcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcclxuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxyXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cclxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XHJcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XHJcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcclxuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XHJcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXHJcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xyXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcclxuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXHJcbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxyXG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxyXG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XHJcbiAgICAgICAgdmFyIHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcclxuICAgICAgICBjcmVhdGVFbG0oXHJcbiAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcclxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXHJcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcclxuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXHJcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxyXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcclxuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XHJcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XHJcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcclxuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gIzY1MTNcclxuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxyXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cclxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcclxuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xyXG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XHJcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XHJcbiAgICByZXR1cm4gdm5vZGUuZWxtXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBkaXJlY3RpdmVzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcclxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcclxuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcclxuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XHJcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XHJcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcclxuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xyXG5cclxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcclxuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcclxuXHJcbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XHJcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xyXG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xyXG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xyXG4gICAgaWYgKCFvbGREaXIpIHtcclxuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxyXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XHJcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxyXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XHJcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XHJcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XHJcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoaXNDcmVhdGUpIHtcclxuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhbGxJbnNlcnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcclxuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICghaXNDcmVhdGUpIHtcclxuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcclxuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcclxuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXHJcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxyXG4gIGRpcnMsXHJcbiAgdm1cclxuKSB7XHJcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgaWYgKCFkaXJzKSB7XHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgdmFyIGksIGRpcjtcclxuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgZGlyID0gZGlyc1tpXTtcclxuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xyXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xyXG4gICAgfVxyXG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XHJcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcclxuICB9XHJcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcclxuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XHJcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xyXG4gIGlmIChmbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGJhc2VNb2R1bGVzID0gW1xyXG4gIHJlZixcclxuICBkaXJlY3RpdmVzXHJcbl07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIGtleSwgY3VyLCBvbGQ7XHJcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XHJcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcclxuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xyXG4gIH1cclxuXHJcbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcclxuICAgIGN1ciA9IGF0dHJzW2tleV07XHJcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xyXG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XHJcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXHJcbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xyXG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcclxuICB9XHJcbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcclxuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XHJcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcclxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XHJcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xyXG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcclxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XHJcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXHJcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXHJcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXHJcbiAgICAgICAgPyAndHJ1ZSdcclxuICAgICAgICA6IGtleTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xyXG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xyXG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXHJcbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXHJcbiAgICAvLyBpbW1lZGlhdGVseS5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKFxyXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxyXG4gICAgICAoZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBlbC50YWdOYW1lID09PSAnSU5QVVQnKSAmJlxyXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxyXG4gICAgKSB7XHJcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XHJcbiAgICAgIH07XHJcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XHJcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXHJcbiAgICB9XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXR0cnMgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcclxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuICBpZiAoXHJcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXHJcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcclxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXHJcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcclxuICAgICAgKVxyXG4gICAgKVxyXG4gICkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XHJcblxyXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcclxuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xyXG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XHJcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcclxuICB9XHJcblxyXG4gIC8vIHNldCB0aGUgY2xhc3NcclxuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcclxuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XHJcbiAgfVxyXG59XHJcblxyXG52YXIga2xhc3MgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcclxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcclxuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcclxuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcclxuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgdmFyIGN1cmx5ID0gMDtcclxuICB2YXIgc3F1YXJlID0gMDtcclxuICB2YXIgcGFyZW4gPSAwO1xyXG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwcmV2ID0gYztcclxuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcclxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XHJcbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcclxuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXHJcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxyXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcclxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXHJcbiAgICApIHtcclxuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXHJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xyXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcclxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXHJcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxyXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcclxuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXHJcbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXHJcbiAgICAgICAgdmFyIGogPSBpIC0gMTtcclxuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xyXG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xyXG4gICAgcHVzaEZpbHRlcigpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XHJcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xyXG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgfVxyXG5cclxuICBpZiAoZmlsdGVycykge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXhwcmVzc2lvblxyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xyXG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICBpZiAoaSA8IDApIHtcclxuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXHJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcclxuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcclxuICBtb2R1bGVzLFxyXG4gIGtleVxyXG4pIHtcclxuICByZXR1cm4gbW9kdWxlc1xyXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXHJcbiAgICA6IFtdXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xyXG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgZWwucGxhaW4gPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcblxyXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcclxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcclxuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIHJhd05hbWUsXHJcbiAgdmFsdWUsXHJcbiAgYXJnLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xyXG4gIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxyXG4gIGVsLFxyXG4gIG5hbWUsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzLFxyXG4gIGltcG9ydGFudCxcclxuICB3YXJuXHJcbikge1xyXG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcclxuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoXHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcclxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXHJcbiAgKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xyXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcclxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxyXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxyXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XHJcbiAgICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XHJcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xyXG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xyXG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XHJcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXHJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XHJcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcclxuICB9XHJcbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XHJcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcclxuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcclxuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnRzO1xyXG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcclxuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcclxuICB9XHJcblxyXG4gIHZhciBuZXdIYW5kbGVyID0ge1xyXG4gICAgdmFsdWU6IHZhbHVlLnRyaW0oKVxyXG4gIH07XHJcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcclxuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xyXG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XHJcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xyXG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XHJcbiAgfSBlbHNlIHtcclxuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXHJcbiAgZWwsXHJcbiAgbmFtZSxcclxuICBnZXRTdGF0aWNcclxuKSB7XHJcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XHJcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxyXG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XHJcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcclxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcclxuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xyXG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxyXG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxyXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcclxuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxyXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIHJlbW92ZUZyb21NYXBcclxuKSB7XHJcbiAgdmFyIHZhbDtcclxuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XHJcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcclxuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXHJcbiAgZWwsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XHJcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XHJcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcclxuXHJcbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcclxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcclxuICBpZiAodHJpbSkge1xyXG4gICAgdmFsdWVFeHByZXNzaW9uID1cclxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcclxuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcclxuICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuICBpZiAobnVtYmVyKSB7XHJcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XHJcbiAgfVxyXG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XHJcblxyXG4gIGVsLm1vZGVsID0ge1xyXG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxyXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXHJcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxyXG4gIHZhbHVlLFxyXG4gIGFzc2lnbm1lbnRcclxuKSB7XHJcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xyXG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxyXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cclxuICpcclxuICogUG9zc2libGUgY2FzZXM6XHJcbiAqXHJcbiAqIC0gdGVzdFxyXG4gKiAtIHRlc3Rba2V5XVxyXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cclxuICogLSB0ZXN0W1wiYVwiXVtrZXldXHJcbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxyXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cclxuICpcclxuICovXHJcblxyXG52YXIgbGVuLCBzdHIsIGNociwgaW5kZXgkMSwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XHJcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXHJcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXHJcbiAgdmFsID0gdmFsLnRyaW0oKTtcclxuICBsZW4gPSB2YWwubGVuZ3RoO1xyXG5cclxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XHJcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXHJcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleHA6IHZhbCxcclxuICAgICAgICBrZXk6IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RyID0gdmFsO1xyXG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XHJcblxyXG4gIHdoaWxlICghZW9mKCkpIHtcclxuICAgIGNociA9IG5leHQoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcclxuICAgICAgcGFyc2VCcmFja2V0KGNocik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXHJcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHQgKCkge1xyXG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVvZiAoKSB7XHJcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xyXG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XHJcbiAgdmFyIGluQnJhY2tldCA9IDE7XHJcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxyXG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xyXG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcclxuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHdhcm4kMTtcclxuXHJcbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcclxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cclxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XHJcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xyXG5cclxuZnVuY3Rpb24gbW9kZWwgKFxyXG4gIGVsLFxyXG4gIGRpcixcclxuICBfd2FyblxyXG4pIHtcclxuICB3YXJuJDEgPSBfd2FybjtcclxuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XHJcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XHJcbiAgdmFyIHRhZyA9IGVsLnRhZztcclxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcclxuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xyXG4gICAgICB3YXJuJDEoXHJcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcclxuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChlbC5jb21wb25lbnQpIHtcclxuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xyXG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHdhcm4kMShcclxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXHJcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXHJcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcclxuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxyXG4gIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XHJcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XHJcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XHJcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxyXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXHJcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcclxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXHJcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcclxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXHJcbiAgICApXHJcbiAgKTtcclxuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcclxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xyXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXHJcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xyXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXHJcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXHJcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xyXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcclxuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xyXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxyXG4gICAgbnVsbCwgdHJ1ZVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XHJcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XHJcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xyXG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNlbGVjdCAoXHJcbiAgZWwsXHJcbiAgdmFsdWUsXHJcbiAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXHJcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xyXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcclxuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcclxuXHJcbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcclxuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XHJcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xyXG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xyXG5cclxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXHJcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XHJcbiAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcclxuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xyXG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xyXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcclxuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xyXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xyXG4gIHZhciB0cmltID0gcmVmLnRyaW07XHJcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcclxuICB2YXIgZXZlbnQgPSBsYXp5XHJcbiAgICA/ICdjaGFuZ2UnXHJcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcclxuICAgICAgPyBSQU5HRV9UT0tFTlxyXG4gICAgICA6ICdpbnB1dCc7XHJcblxyXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XHJcbiAgaWYgKHRyaW0pIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcclxuICB9XHJcbiAgaWYgKG51bWJlcikge1xyXG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcclxuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcclxuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XHJcbiAgfVxyXG5cclxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XHJcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xyXG4gIGlmICh0cmltIHx8IG51bWJlcikge1xyXG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxyXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXHJcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcclxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cclxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XHJcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XHJcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xyXG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcclxuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XHJcbiAgfVxyXG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XHJcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XHJcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xyXG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcclxuICB9XHJcbn1cclxuXHJcbnZhciB0YXJnZXQkMTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XHJcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcclxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xyXG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIGlmIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZCQxIChcclxuICBldmVudCxcclxuICBoYW5kbGVyLFxyXG4gIGNhcHR1cmUsXHJcbiAgcGFzc2l2ZVxyXG4pIHtcclxuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcclxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgZXZlbnQsXHJcbiAgICBoYW5kbGVyLFxyXG4gICAgc3VwcG9ydHNQYXNzaXZlXHJcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cclxuICAgICAgOiBjYXB0dXJlXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxyXG4gIGV2ZW50LFxyXG4gIGhhbmRsZXIsXHJcbiAgY2FwdHVyZSxcclxuICBfdGFyZ2V0XHJcbikge1xyXG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgZXZlbnQsXHJcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxyXG4gICAgY2FwdHVyZVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XHJcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcclxuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcclxuICBub3JtYWxpemVFdmVudHMob24pO1xyXG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XHJcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbnZhciBldmVudHMgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXHJcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIga2V5LCBjdXI7XHJcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XHJcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcclxuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gIH1cclxuXHJcbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XHJcbiAgICAgIGVsbVtrZXldID0gJyc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAoa2V5IGluIHByb3BzKSB7XHJcbiAgICBjdXIgPSBwcm9wc1trZXldO1xyXG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXHJcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xyXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcclxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxyXG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cclxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxyXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxyXG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcclxuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxyXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xyXG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcclxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XHJcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcclxuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsbVtrZXldID0gY3VyO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXHJcblxyXG5cclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcclxuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcclxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxyXG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcclxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXHJcbiAgKSlcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcclxuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXHJcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXHJcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xyXG4gIC8vICM2MTU3XHJcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXHJcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cclxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xyXG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcclxuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcclxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xyXG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XHJcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XHJcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXHJcbn1cclxuXHJcbnZhciBkb21Qcm9wcyA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcclxuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xyXG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgaWYgKGl0ZW0pIHtcclxuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xyXG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc1xyXG59KTtcclxuXHJcbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xyXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcclxuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cclxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxyXG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXHJcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcclxuICAgIDogc3R5bGVcclxufVxyXG5cclxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxyXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcclxuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcclxuICB9XHJcbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxyXG59XHJcblxyXG4vKipcclxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xyXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XHJcbiAgdmFyIHJlcyA9IHt9O1xyXG4gIHZhciBzdHlsZURhdGE7XHJcblxyXG4gIGlmIChjaGVja0NoaWxkKSB7XHJcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XHJcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XHJcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcclxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XHJcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcclxuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcclxuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xyXG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGNzc1ZhclJFID0gL14tLS87XHJcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcclxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XHJcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcclxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxyXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XHJcbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xyXG5cclxudmFyIGVtcHR5U3R5bGU7XHJcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcclxuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcclxuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XHJcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XHJcbiAgICByZXR1cm4gcHJvcFxyXG4gIH1cclxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xyXG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xyXG4gICAgICByZXR1cm4gbmFtZVxyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuXHJcbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxyXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXHJcbiAgKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjdXIsIG5hbWU7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XHJcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XHJcblxyXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXHJcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xyXG5cclxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XHJcblxyXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcclxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXHJcbiAgLy8gdG8gbXV0YXRlIGl0LlxyXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxyXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxyXG4gICAgOiBzdHlsZTtcclxuXHJcbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xyXG5cclxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcclxuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xyXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xyXG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XHJcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xyXG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xyXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBzdHlsZSA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxyXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cclxuICogU1ZHIGVsZW1lbnRzIGluIElFXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcclxuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgfVxyXG4gICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcclxuICBpZiAoIWRlZiQkMSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICB9XHJcbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcclxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcclxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcclxudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuXHJcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcclxudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xyXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xyXG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xyXG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcclxuaWYgKGhhc1RyYW5zaXRpb24pIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xyXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xyXG4gIH1cclxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XHJcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXHJcbnZhciByYWYgPSBpbkJyb3dzZXJcclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcclxuICAgIDogc2V0VGltZW91dFxyXG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xyXG5cclxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xyXG4gIHJhZihmdW5jdGlvbiAoKSB7XHJcbiAgICByYWYoZm4pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcclxuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xyXG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xyXG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xyXG4gIH1cclxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcclxuICBlbCxcclxuICBleHBlY3RlZFR5cGUsXHJcbiAgY2JcclxuKSB7XHJcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcclxuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcclxuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxyXG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICB2YXIgZW5kZWQgPSAwO1xyXG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbiAgICBjYigpO1xyXG4gIH07XHJcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcclxuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgZW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgIGVuZCgpO1xyXG4gICAgfVxyXG4gIH0sIHRpbWVvdXQgKyAxKTtcclxuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxuXHJcbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XHJcblxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xyXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuXHJcbiAgdmFyIHR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSAwO1xyXG4gIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXHJcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XHJcbiAgICAgICAgPyBUUkFOU0lUSU9OXHJcbiAgICAgICAgOiBBTklNQVRJT05cclxuICAgICAgOiBudWxsO1xyXG4gICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMDtcclxuICB9XHJcbiAgdmFyIGhhc1RyYW5zZm9ybSA9XHJcbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXHJcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcclxuICB9KSlcclxufVxyXG5cclxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xyXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXHJcbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXHJcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcclxuZnVuY3Rpb24gdG9NcyAocykge1xyXG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xyXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcclxuXHJcbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcclxuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgZWwuX2xlYXZlQ2IoKTtcclxuICB9XHJcblxyXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcclxuICBpZiAoaXNVbmRlZihkYXRhKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcclxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcclxuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XHJcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcclxuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcclxuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xyXG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XHJcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcclxuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcclxuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xyXG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcclxuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XHJcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcclxuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XHJcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xyXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxyXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXHJcbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcclxuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XHJcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xyXG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XHJcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcclxuICB9XHJcblxyXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcclxuXHJcbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXHJcbiAgICA/IGFwcGVhckNsYXNzXHJcbiAgICA6IGVudGVyQ2xhc3M7XHJcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcclxuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcclxuICAgID8gYXBwZWFyVG9DbGFzc1xyXG4gICAgOiBlbnRlclRvQ2xhc3M7XHJcblxyXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxyXG4gICAgOiBiZWZvcmVFbnRlcjtcclxuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcclxuICAgIDogZW50ZXI7XHJcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXHJcbiAgICA6IGFmdGVyRW50ZXI7XHJcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXHJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXHJcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xyXG5cclxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXHJcbiAgICBpc09iamVjdChkdXJhdGlvbilcclxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxyXG4gICAgICA6IGR1cmF0aW9uXHJcbiAgKTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcclxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xyXG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xyXG5cclxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgICAgfVxyXG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcclxuICAgIH1cclxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcclxuICB9KTtcclxuXHJcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcclxuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXHJcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XHJcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxyXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXHJcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXHJcbiAgICAgICkge1xyXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xyXG4gICAgICB9XHJcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxyXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xyXG4gIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XHJcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XHJcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcclxuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICB9XHJcblxyXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgY2IoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcclxuICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcblxyXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XHJcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xyXG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XHJcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcclxuICAgIHJldHVybiBybSgpXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcclxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcclxuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XHJcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcclxuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xyXG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xyXG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XHJcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XHJcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xyXG5cclxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXHJcbiAgICBpc09iamVjdChkdXJhdGlvbilcclxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxyXG4gICAgICA6IGR1cmF0aW9uXHJcbiAgKTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xyXG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcclxuICB9XHJcblxyXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XHJcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBybSgpO1xyXG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xyXG4gICAgfVxyXG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwZXJmb3JtTGVhdmUoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XHJcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXHJcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxyXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XHJcbiAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgY2IoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXHJcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXHJcbiAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXHJcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcclxuICAgICAgdm5vZGUuY29udGV4dFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcclxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXHJcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxyXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xyXG4gIGlmIChpc1VuZGVmKGZuKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xyXG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xyXG4gICAgLy8gaW52b2tlclxyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXHJcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcclxuICAgICAgICA/IGludm9rZXJGbnNbMF1cclxuICAgICAgICA6IGludm9rZXJGbnNcclxuICAgIClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgZW50ZXIodm5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XHJcbiAgY3JlYXRlOiBfZW50ZXIsXHJcbiAgYWN0aXZhdGU6IF9lbnRlcixcclxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgIH1cclxuICB9XHJcbn0gOiB7fTtcclxuXHJcbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXHJcbiAgYXR0cnMsXHJcbiAga2xhc3MsXHJcbiAgZXZlbnRzLFxyXG4gIGRvbVByb3BzLFxyXG4gIHN0eWxlLFxyXG4gIHRyYW5zaXRpb25cclxuXTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXHJcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXHJcbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XHJcblxyXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcclxuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cclxuICovXHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKGlzSUU5KSB7XHJcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcclxuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBkaXJlY3RpdmUgPSB7XHJcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XHJcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAvLyAjNjkwM1xyXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcclxuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcclxuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoaXNJRTkpIHtcclxuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxyXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXHJcbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xyXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cclxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xyXG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcclxuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xyXG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXHJcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcclxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxyXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xyXG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcclxuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcclxuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xyXG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXHJcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XHJcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XHJcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFpc011bHRpcGxlKSB7XHJcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcclxuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXHJcbiAgICA/IG9wdGlvbi5fdmFsdWVcclxuICAgIDogb3B0aW9uLnZhbHVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xyXG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcclxuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxyXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XHJcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XHJcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XHJcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxyXG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xyXG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcclxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXHJcbiAgICA6IHZub2RlXHJcbn1cclxuXHJcbnZhciBzaG93ID0ge1xyXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XHJcblxyXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcclxuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcclxuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcclxuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxyXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcclxuICAgIGVsLFxyXG4gICAgYmluZGluZyxcclxuICAgIHZub2RlLFxyXG4gICAgb2xkVm5vZGUsXHJcbiAgICBpc0Rlc3Ryb3lcclxuICApIHtcclxuICAgIGlmICghaXNEZXN0cm95KSB7XHJcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcclxuICBtb2RlbDogZGlyZWN0aXZlLFxyXG4gIHNob3c6IHNob3dcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcclxuICBuYW1lOiBTdHJpbmcsXHJcbiAgYXBwZWFyOiBCb29sZWFuLFxyXG4gIGNzczogQm9vbGVhbixcclxuICBtb2RlOiBTdHJpbmcsXHJcbiAgdHlwZTogU3RyaW5nLFxyXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcclxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXHJcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxyXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cclxufTtcclxuXHJcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxyXG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxyXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XHJcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdm5vZGVcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xyXG4gIHZhciBkYXRhID0ge307XHJcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xyXG4gIC8vIHByb3BzXHJcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XHJcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XHJcbiAgfVxyXG4gIC8vIGV2ZW50cy5cclxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcclxuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xyXG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XHJcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xyXG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XHJcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XHJcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcclxuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcclxuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcclxufVxyXG5cclxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xyXG5cclxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XHJcblxyXG52YXIgVHJhbnNpdGlvbiA9IHtcclxuICBuYW1lOiAndHJhbnNpdGlvbicsXHJcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcclxuICBhYnN0cmFjdDogdHJ1ZSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXHJcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcclxuICAgICAgICB0aGlzLiRwYXJlbnRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcclxuXHJcbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xyXG4gICAgKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxyXG4gICAgICAgIHRoaXMuJHBhcmVudFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG5cclxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcclxuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxyXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XHJcbiAgICAgIHJldHVybiByYXdDaGlsZFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxyXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxyXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjaGlsZCkge1xyXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xyXG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cclxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcclxuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cclxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcclxuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXHJcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XHJcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xyXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcclxuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXHJcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcclxuICAgICAgICA6IGNoaWxkLmtleTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XHJcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xyXG5cclxuICAgIC8vIG1hcmsgdi1zaG93XHJcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcclxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcclxuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIG9sZENoaWxkICYmXHJcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcclxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcclxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcclxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcclxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxyXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXHJcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcclxuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxyXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcclxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xyXG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcclxuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmF3Q2hpbGRcclxuICB9XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBwcm9wcyA9IGV4dGVuZCh7XHJcbiAgdGFnOiBTdHJpbmcsXHJcbiAgbW92ZUNsYXNzOiBTdHJpbmdcclxufSwgdHJhbnNpdGlvblByb3BzKTtcclxuXHJcbmRlbGV0ZSBwcm9wcy5tb2RlO1xyXG5cclxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcclxuICBwcm9wczogcHJvcHMsXHJcblxyXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xyXG4gICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XHJcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcclxuICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcclxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxyXG4gICAgICAgIHRoaXMkMS5rZXB0LFxyXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcclxuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcclxuICAgICAgKTtcclxuICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xyXG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcclxuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XHJcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcclxuICAgICAgaWYgKGMudGFnKSB7XHJcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XHJcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xyXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcclxuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgdmFyIGtlcHQgPSBbXTtcclxuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XHJcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xyXG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcclxuICB9LFxyXG5cclxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xyXG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcclxuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xyXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cclxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xyXG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xyXG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XHJcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcclxuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcclxuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgbWV0aG9kczoge1xyXG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcclxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XHJcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XHJcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoYy5lbG0uX21vdmVDYikge1xyXG4gICAgYy5lbG0uX21vdmVDYigpO1xyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcclxuICAgIGMuZWxtLl9lbnRlckNiKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xyXG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xyXG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xyXG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xyXG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xyXG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcclxuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcclxuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICB9XHJcbn1cclxuXHJcbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XHJcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcclxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXHJcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcclxuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcclxuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xyXG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcclxuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcclxuXHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xyXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcclxuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XHJcblxyXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXHJcblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xyXG5cclxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxyXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcclxuICBlbCxcclxuICBoeWRyYXRpbmdcclxuKSB7XHJcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XHJcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXHJcbn07XHJcblxyXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAoaW5Ccm93c2VyKSB7XHJcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XHJcbiAgICAgIGlmIChkZXZ0b29scykge1xyXG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXHJcbiAgICAgICAgaXNDaHJvbWVcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXHJcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXHJcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXHJcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxyXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICkge1xyXG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcclxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXHJcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xyXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0sIDApO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcclxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xyXG5cclxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcclxuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XHJcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcclxuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxyXG59KTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VUZXh0IChcclxuICB0ZXh0LFxyXG4gIGRlbGltaXRlcnNcclxuKSB7XHJcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XHJcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIHRva2VucyA9IFtdO1xyXG4gIHZhciByYXdUb2tlbnMgPSBbXTtcclxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcclxuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xyXG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xyXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxyXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XHJcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcclxuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLy8gdGFnIHRva2VuXHJcbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XHJcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XHJcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcclxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gIH1cclxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xyXG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcclxuICAgIHRva2VuczogcmF3VG9rZW5zXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XHJcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcclxuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0aWNDbGFzcykge1xyXG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XHJcbiAgfVxyXG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICBpZiAoY2xhc3NCaW5kaW5nKSB7XHJcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xyXG4gIHZhciBkYXRhID0gJyc7XHJcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XHJcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcclxuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbnZhciBrbGFzcyQxID0ge1xyXG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcclxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxyXG4gIGdlbkRhdGE6IGdlbkRhdGFcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xyXG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xyXG4gIGlmIChzdGF0aWNTdHlsZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xyXG4gICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcclxuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcclxuICB9XHJcblxyXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICBpZiAoc3R5bGVCaW5kaW5nKSB7XHJcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XHJcbiAgdmFyIGRhdGEgPSAnJztcclxuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcclxuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcclxuICB9XHJcbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xyXG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG52YXIgc3R5bGUkMSA9IHtcclxuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXHJcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxyXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgZGVjb2RlcjtcclxuXHJcbnZhciBoZSA9IHtcclxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xyXG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxyXG4gIH1cclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxyXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcclxuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXHJcbik7XHJcblxyXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cclxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxyXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXHJcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXHJcbik7XHJcblxyXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXHJcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxyXG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXHJcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcclxuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xyXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcclxuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xyXG4gICd0aXRsZSx0cix0cmFjaydcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cclxuICovXHJcblxyXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcclxudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xyXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcclxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcclxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xyXG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xyXG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XHJcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XHJcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcclxudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcclxuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxyXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcclxudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xyXG5cclxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXHJcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcclxudmFyIHJlQ2FjaGUgPSB7fTtcclxuXHJcbnZhciBkZWNvZGluZ01hcCA9IHtcclxuICAnJmx0Oyc6ICc8JyxcclxuICAnJmd0Oyc6ICc+JyxcclxuICAnJnF1b3Q7JzogJ1wiJyxcclxuICAnJmFtcDsnOiAnJicsXHJcbiAgJyYjMTA7JzogJ1xcbicsXHJcbiAgJyYjOTsnOiAnXFx0J1xyXG59O1xyXG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcclxudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTB8IzkpOy9nO1xyXG5cclxuLy8gIzU5OTJcclxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xyXG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xyXG5cclxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XHJcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xyXG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XHJcbiAgdmFyIHN0YWNrID0gW107XHJcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XHJcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XHJcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICB2YXIgbGFzdCwgbGFzdFRhZztcclxuICB3aGlsZSAoaHRtbCkge1xyXG4gICAgbGFzdCA9IGh0bWw7XHJcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxyXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcclxuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcclxuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcclxuICAgICAgICAvLyBDb21tZW50OlxyXG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxyXG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xyXG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xyXG5cclxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvY3R5cGU6XHJcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XHJcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xyXG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbmQgdGFnOlxyXG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcclxuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcclxuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhcnQgdGFnOlxyXG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xyXG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XHJcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcclxuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xyXG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xyXG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XHJcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XHJcbiAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcclxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcclxuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XHJcbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XHJcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xyXG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xyXG4gICAgICAgIHRleHQgPSBodG1sO1xyXG4gICAgICAgIGh0bWwgPSAnJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xyXG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xyXG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xyXG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XHJcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcclxuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgICB9KTtcclxuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xyXG4gICAgICBodG1sID0gcmVzdCQxO1xyXG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XHJcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcclxuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXHJcbiAgcGFyc2VFbmRUYWcoKTtcclxuXHJcbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xyXG4gICAgaW5kZXggKz0gbjtcclxuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xyXG4gICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IHtcclxuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcclxuICAgICAgICBhdHRyczogW10sXHJcbiAgICAgICAgc3RhcnQ6IGluZGV4XHJcbiAgICAgIH07XHJcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIGVuZCwgYXR0cjtcclxuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XHJcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcclxuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xyXG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xyXG4gICAgICAgIHJldHVybiBtYXRjaFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcclxuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcclxuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcclxuXHJcbiAgICBpZiAoZXhwZWN0SFRNTCkge1xyXG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcclxuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XHJcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcclxuXHJcbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcclxuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XHJcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xyXG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXHJcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxyXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcclxuICAgICAgYXR0cnNbaV0gPSB7XHJcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcclxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1bmFyeSkge1xyXG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcclxuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcclxuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xyXG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxyXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XHJcblxyXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgIGlmICh0YWdOYW1lKSB7XHJcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcclxuICAgICAgcG9zID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zID49IDApIHtcclxuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcclxuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXHJcbiAgICAgICAgICBvcHRpb25zLndhcm5cclxuICAgICAgICApIHtcclxuICAgICAgICAgIG9wdGlvbnMud2FybihcclxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXHJcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcclxuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XHJcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xyXG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcclxuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xyXG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcclxudmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XHJcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xyXG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcclxuXHJcbnZhciBhcmdSRSA9IC86KC4qKSQvO1xyXG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcclxudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcclxuXHJcbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XHJcblxyXG4vLyBjb25maWd1cmFibGUgc3RhdGVcclxudmFyIHdhcm4kMjtcclxudmFyIGRlbGltaXRlcnM7XHJcbnZhciB0cmFuc2Zvcm1zO1xyXG52YXIgcHJlVHJhbnNmb3JtcztcclxudmFyIHBvc3RUcmFuc2Zvcm1zO1xyXG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcclxudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XHJcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXHJcbiAgdGFnLFxyXG4gIGF0dHJzLFxyXG4gIHBhcmVudFxyXG4pIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogMSxcclxuICAgIHRhZzogdGFnLFxyXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcclxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxyXG4gICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICBjaGlsZHJlbjogW11cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlIChcclxuICB0ZW1wbGF0ZSxcclxuICBvcHRpb25zXHJcbikge1xyXG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuXHJcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XHJcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XHJcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcclxuXHJcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xyXG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcclxuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcclxuXHJcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcclxuXHJcbiAgdmFyIHN0YWNrID0gW107XHJcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcclxuICB2YXIgcm9vdDtcclxuICB2YXIgY3VycmVudFBhcmVudDtcclxuICB2YXIgaW5WUHJlID0gZmFsc2U7XHJcbiAgdmFyIGluUHJlID0gZmFsc2U7XHJcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XHJcbiAgICBpZiAoIXdhcm5lZCkge1xyXG4gICAgICB3YXJuZWQgPSB0cnVlO1xyXG4gICAgICB3YXJuJDIobXNnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xyXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXHJcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcclxuICAgICAgaW5WUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgaW5QcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xyXG4gICAgd2Fybjogd2FybiQyLFxyXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxyXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxyXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxyXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXHJcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxyXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXHJcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XHJcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cclxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXHJcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XHJcblxyXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xyXG4gICAgICBpZiAobnMpIHtcclxuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcclxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcclxuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xyXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWluVlByZSkge1xyXG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICBpblByZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluVlByZSkge1xyXG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcclxuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcclxuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcclxuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xyXG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcclxuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcclxuICAgICAgICAvLyBlbGVtZW50LXNjb3BlIHN0dWZmXHJcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKFxyXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcclxuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcclxuICAgICAgICAgICAgd2Fybk9uY2UoXHJcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xyXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxyXG4gICAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgICByb290ID0gZWxlbWVudDtcclxuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcclxuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXHJcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcclxuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xyXG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xyXG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxyXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXHJcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXHJcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcclxuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxyXG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xyXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF1bmFyeSkge1xyXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcclxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcclxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xyXG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XHJcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBwb3Agc3RhY2tcclxuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcclxuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChpc0lFICYmXHJcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcclxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxyXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcclxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xyXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xyXG4gICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XHJcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogMixcclxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcclxuICAgICAgICAgICAgdGV4dDogdGV4dFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XHJcbiAgICAgICAgdHlwZTogMyxcclxuICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcm9vdFxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xyXG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XHJcbiAgICBlbC5wcmUgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xyXG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcclxuICBpZiAobCkge1xyXG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBhdHRyc1tpXSA9IHtcclxuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcclxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xyXG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xyXG4gICAgZWwucGxhaW4gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xyXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcclxuXHJcbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcclxuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcclxuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcclxuICB9XHJcbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xyXG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gIGlmIChleHApIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbC5mb3IpIHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xyXG4gICAgICAgICAgd2FybiQyKFxyXG4gICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc3Rpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXHJcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsLmtleSA9IGV4cDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XHJcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XHJcbiAgaWYgKHJlZikge1xyXG4gICAgZWwucmVmID0gcmVmO1xyXG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XHJcbiAgdmFyIGV4cDtcclxuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xyXG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcclxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB3YXJuJDIoXHJcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xyXG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xyXG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxyXG4gIHZhciByZXMgPSB7fTtcclxuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XHJcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XHJcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcclxuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xyXG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcclxuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XHJcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XHJcbiAgaWYgKGV4cCkge1xyXG4gICAgZWwuaWYgPSBleHA7XHJcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xyXG4gICAgICBleHA6IGV4cCxcclxuICAgICAgYmxvY2s6IGVsXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XHJcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcclxuICAgIGlmIChlbHNlaWYpIHtcclxuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xyXG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XHJcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xyXG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xyXG4gICAgICBleHA6IGVsLmVsc2VpZixcclxuICAgICAgYmxvY2s6IGVsXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHdhcm4kMihcclxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXHJcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xyXG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XHJcbiAgICAgICAgd2FybiQyKFxyXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXHJcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgY2hpbGRyZW4ucG9wKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xyXG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XHJcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcclxuICB9XHJcbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XHJcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XHJcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xyXG4gICAgZWwub25jZSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcclxuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcclxuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcclxuICAgICAgd2FybiQyKFxyXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXHJcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXHJcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgc2xvdFNjb3BlO1xyXG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xyXG4gICAgICAgIHdhcm4kMihcclxuICAgICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcclxuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcclxuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcclxuICAgICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xyXG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XHJcbiAgICAgICAgd2FybiQyKFxyXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xyXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xyXG4gICAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XHJcbiAgICB9XHJcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xyXG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcclxuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xyXG4gICAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XHJcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXHJcbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xyXG4gICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XHJcbiAgdmFyIGJpbmRpbmc7XHJcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xyXG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcclxuICB9XHJcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XHJcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XHJcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XHJcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcclxuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xyXG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xyXG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcclxuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xyXG4gICAgICAvLyBtb2RpZmllcnNcclxuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XHJcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XHJcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgd2FybiQyKFxyXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xyXG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XHJcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xyXG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcclxuICAgICAgICAgICAgYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcclxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXHJcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxyXG4gICAgICAgICkpIHtcclxuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xyXG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xyXG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcclxuICAgICAgICAvLyBwYXJzZSBhcmdcclxuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcclxuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XHJcbiAgICAgICAgaWYgKGFyZykge1xyXG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xyXG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgIHdhcm4kMihcclxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXHJcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcclxuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcclxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXHJcbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXHJcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcclxuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xyXG4gIHZhciBwYXJlbnQgPSBlbDtcclxuICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcclxuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xyXG4gIGlmIChtYXRjaCkge1xyXG4gICAgdmFyIHJldCA9IHt9O1xyXG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcclxuICAgIHJldHVybiByZXRcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcclxuICB2YXIgbWFwID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChcclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxyXG4gICAgKSB7XHJcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBtYXBcclxufVxyXG5cclxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XHJcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcclxuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxyXG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxyXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxyXG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xyXG4gICAgKSlcclxuICApXHJcbn1cclxuXHJcbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xyXG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xyXG4gIHZhciByZXMgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xyXG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xyXG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XHJcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XHJcbiAgdmFyIF9lbCA9IGVsO1xyXG4gIHdoaWxlIChfZWwpIHtcclxuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcclxuICAgICAgd2FybiQyKFxyXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xyXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcclxuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcclxuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcclxuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBfZWwgPSBfZWwucGFyZW50O1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xyXG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcclxuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcclxuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHR5cGVCaW5kaW5nO1xyXG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcclxuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcclxuICAgIH1cclxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcclxuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcclxuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcclxuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcclxuICAgICAgLy8gMS4gY2hlY2tib3hcclxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXHJcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XHJcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XHJcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcclxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cclxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XHJcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcclxuICAgICAgICBibG9jazogYnJhbmNoMVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gMy4gb3RoZXJcclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XHJcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcclxuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGhhc0Vsc2UpIHtcclxuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xyXG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYnJhbmNoMFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xyXG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcclxufVxyXG5cclxudmFyIG1vZGVsJDEgPSB7XHJcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxyXG59O1xyXG5cclxudmFyIG1vZHVsZXMkMSA9IFtcclxuICBrbGFzcyQxLFxyXG4gIHN0eWxlJDEsXHJcbiAgbW9kZWwkMVxyXG5dO1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XHJcbiAgaWYgKGRpci52YWx1ZSkge1xyXG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcclxuICBpZiAoZGlyLnZhbHVlKSB7XHJcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZGlyZWN0aXZlcyQxID0ge1xyXG4gIG1vZGVsOiBtb2RlbCxcclxuICB0ZXh0OiB0ZXh0LFxyXG4gIGh0bWw6IGh0bWxcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGJhc2VPcHRpb25zID0ge1xyXG4gIGV4cGVjdEhUTUw6IHRydWUsXHJcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxyXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcclxuICBpc1ByZVRhZzogaXNQcmVUYWcsXHJcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcclxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXHJcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcclxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxyXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxyXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgaXNTdGF0aWNLZXk7XHJcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XHJcblxyXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xyXG5cclxuLyoqXHJcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXHJcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcclxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cclxuICpcclxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XHJcbiAqXHJcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cclxuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xyXG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cclxuICovXHJcbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XHJcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XHJcbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XHJcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXHJcbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xyXG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cclxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcclxuICByZXR1cm4gbWFrZU1hcChcclxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXHJcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xyXG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXHJcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXHJcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXHJcbiAgICBpZiAoXHJcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXHJcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcclxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xyXG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xyXG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xyXG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XHJcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcclxuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcclxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXHJcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXHJcbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcclxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXHJcbiAgICApKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxyXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xyXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxyXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cclxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XHJcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcclxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxyXG4gICkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XHJcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5mb3IpIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xyXG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcclxuXHJcbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXHJcbnZhciBrZXlDb2RlcyA9IHtcclxuICBlc2M6IDI3LFxyXG4gIHRhYjogOSxcclxuICBlbnRlcjogMTMsXHJcbiAgc3BhY2U6IDMyLFxyXG4gIHVwOiAzOCxcclxuICBsZWZ0OiAzNyxcclxuICByaWdodDogMzksXHJcbiAgZG93bjogNDAsXHJcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cclxufTtcclxuXHJcbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcclxudmFyIGtleU5hbWVzID0ge1xyXG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxyXG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXHJcbiAgdGFiOiAnVGFiJyxcclxuICBlbnRlcjogJ0VudGVyJyxcclxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxyXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcclxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxyXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcclxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXHJcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxyXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcclxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXHJcbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxyXG59O1xyXG5cclxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxyXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXHJcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xyXG5cclxudmFyIG1vZGlmaWVyQ29kZSA9IHtcclxuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXHJcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXHJcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcclxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcclxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxyXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcclxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcclxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxyXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcclxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxyXG4gIGV2ZW50cyxcclxuICBpc05hdGl2ZVxyXG4pIHtcclxuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XHJcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcclxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xyXG4gIH1cclxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcclxuICBuYW1lLFxyXG4gIGhhbmRsZXJcclxuKSB7XHJcbiAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXHJcbiAgfVxyXG5cclxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XHJcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xyXG5cclxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XHJcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XHJcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjb2RlID0gJyc7XHJcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XHJcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xyXG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcclxuICAgICAgICAvLyBsZWZ0L3JpZ2h0XHJcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcclxuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcclxuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcclxuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXHJcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxyXG4gICAgICAgICAgICAuam9pbignfHwnKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcclxuICAgIH1cclxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXHJcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XHJcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXHJcbiAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIoJGV2ZW50KVwiKVxyXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXHJcbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcclxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XHJcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XHJcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XHJcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gIGlmIChrZXlWYWwpIHtcclxuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxyXG4gIH1cclxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XHJcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xyXG4gIHJldHVybiAoXHJcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXHJcbiAgICBcIiRldmVudC5rZXksXCIgK1xyXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xyXG4gICAgXCIpXCJcclxuICApXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XHJcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcclxuICB9XHJcbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xyXG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcclxuICBvbjogb24sXHJcbiAgYmluZDogYmluZCQxLFxyXG4gIGNsb2FrOiBub29wXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XHJcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XHJcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XHJcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xyXG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEoaXNSZXNlcnZlZFRhZyhlbC50YWcpICYmICFlbC5jb21wb25lbnQpOyB9O1xyXG4gIHRoaXMub25jZUlkID0gMDtcclxuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xyXG4gIHRoaXMucHJlID0gZmFsc2U7XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlIChcclxuICBhc3QsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xyXG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxyXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xyXG4gIGlmIChlbC5wYXJlbnQpIHtcclxuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xyXG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcclxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XHJcbiAgICB2YXIgY29kZTtcclxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcclxuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZGF0YTtcclxuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcclxuICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XHJcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2RlXHJcbiAgfVxyXG59XHJcblxyXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxyXG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xyXG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XHJcbiAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxyXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXHJcbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cclxuICB2YXIgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcclxuICBpZiAoZWwucHJlKSB7XHJcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XHJcbiAgfVxyXG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xyXG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XHJcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcclxufVxyXG5cclxuLy8gdi1vbmNlXHJcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xyXG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xyXG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xyXG4gICAgdmFyIGtleSA9ICcnO1xyXG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcclxuICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcclxuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxuICAgIGlmICgha2V5KSB7XHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcclxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSWYgKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRFbXB0eVxyXG4pIHtcclxuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxyXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxyXG4gIGNvbmRpdGlvbnMsXHJcbiAgc3RhdGUsXHJcbiAgYWx0R2VuLFxyXG4gIGFsdEVtcHR5XHJcbikge1xyXG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcclxuICB9XHJcblxyXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XHJcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcclxuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcclxuICB9XHJcblxyXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcclxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xyXG4gICAgcmV0dXJuIGFsdEdlblxyXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXHJcbiAgICAgIDogZWwub25jZVxyXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXHJcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkZvciAoXHJcbiAgZWwsXHJcbiAgc3RhdGUsXHJcbiAgYWx0R2VuLFxyXG4gIGFsdEhlbHBlclxyXG4pIHtcclxuICB2YXIgZXhwID0gZWwuZm9yO1xyXG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xyXG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcclxuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcclxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXHJcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICFlbC5rZXlcclxuICApIHtcclxuICAgIHN0YXRlLndhcm4oXHJcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xyXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcclxuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxyXG4gICAgICB0cnVlIC8qIHRpcCAqL1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxyXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcclxuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXHJcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xyXG4gICAgJ30pJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xyXG4gIHZhciBkYXRhID0gJ3snO1xyXG5cclxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxyXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXHJcbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XHJcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XHJcblxyXG4gIC8vIGtleVxyXG4gIGlmIChlbC5rZXkpIHtcclxuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xyXG4gIH1cclxuICAvLyByZWZcclxuICBpZiAoZWwucmVmKSB7XHJcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcclxuICB9XHJcbiAgaWYgKGVsLnJlZkluRm9yKSB7XHJcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcclxuICB9XHJcbiAgLy8gcHJlXHJcbiAgaWYgKGVsLnByZSkge1xyXG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xyXG4gIH1cclxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxyXG4gIGlmIChlbC5jb21wb25lbnQpIHtcclxuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XHJcbiAgfVxyXG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xyXG4gIH1cclxuICAvLyBhdHRyaWJ1dGVzXHJcbiAgaWYgKGVsLmF0dHJzKSB7XHJcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XHJcbiAgfVxyXG4gIC8vIERPTSBwcm9wc1xyXG4gIGlmIChlbC5wcm9wcykge1xyXG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xyXG4gIH1cclxuICAvLyBldmVudCBoYW5kbGVyc1xyXG4gIGlmIChlbC5ldmVudHMpIHtcclxuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xyXG4gIH1cclxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XHJcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xyXG4gIH1cclxuICAvLyBzbG90IHRhcmdldFxyXG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcclxuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XHJcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xyXG4gIH1cclxuICAvLyBzY29wZWQgc2xvdHNcclxuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcclxuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XHJcbiAgfVxyXG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXHJcbiAgaWYgKGVsLm1vZGVsKSB7XHJcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XHJcbiAgfVxyXG4gIC8vIGlubGluZS10ZW1wbGF0ZVxyXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xyXG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcclxuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xyXG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xyXG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcclxuICBpZiAoZWwud3JhcERhdGEpIHtcclxuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcclxuICB9XHJcbiAgLy8gdi1vbiBkYXRhIHdyYXBcclxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xyXG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xyXG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcclxuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cclxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XHJcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcclxuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcclxuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGRpciA9IGRpcnNbaV07XHJcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XHJcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XHJcbiAgICBpZiAoZ2VuKSB7XHJcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXHJcbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcclxuICAgIH1cclxuICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcclxuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNSdW50aW1lKSB7XHJcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xyXG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXHJcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcclxuICApKSB7XHJcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcclxuICB9XHJcbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XHJcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcclxuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXHJcbiAgc2xvdHMsXHJcbiAgc3RhdGVcclxuKSB7XHJcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcclxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxyXG4gIGtleSxcclxuICBlbCxcclxuICBzdGF0ZVxyXG4pIHtcclxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxyXG4gIH1cclxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXHJcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcclxuICAgICAgPyBlbC5pZlxyXG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxyXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xyXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcclxuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXHJcbiAga2V5LFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIHZhciBleHAgPSBlbC5mb3I7XHJcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XHJcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xyXG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcclxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xyXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcclxuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcclxuICAgICd9KSdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGNoZWNrU2tpcCxcclxuICBhbHRHZW5FbGVtZW50LFxyXG4gIGFsdEdlbk5vZGVcclxuKSB7XHJcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcclxuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICBlbCQxLmZvciAmJlxyXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxyXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXHJcbiAgICApIHtcclxuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCJcIjtcclxuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcclxuICAgIH1cclxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXHJcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxyXG4gICAgICA6IDA7XHJcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xyXG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXHJcbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXHJcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcclxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxyXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXHJcbiAgY2hpbGRyZW4sXHJcbiAgbWF5YmVDb21wb25lbnRcclxuKSB7XHJcbiAgdmFyIHJlcyA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XHJcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcclxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xyXG4gICAgICByZXMgPSAyO1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxyXG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcclxuICAgICAgcmVzID0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XHJcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XHJcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xyXG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcclxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcclxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XHJcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xyXG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XHJcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcclxuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xyXG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XHJcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XHJcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcclxuICAgIHJlcyArPSBcIixudWxsXCI7XHJcbiAgfVxyXG4gIGlmIChhdHRycykge1xyXG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XHJcbiAgfVxyXG4gIGlmIChiaW5kJCQxKSB7XHJcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcyArICcpJ1xyXG59XHJcblxyXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XHJcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXHJcbiAgY29tcG9uZW50TmFtZSxcclxuICBlbCxcclxuICBzdGF0ZVxyXG4pIHtcclxuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xyXG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIHtcclxuICAgICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxyXG59XHJcblxyXG4vLyAjMzg5NSwgIzQyNjhcclxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XHJcbiAgcmV0dXJuIHRleHRcclxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxyXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xyXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xyXG5cclxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcclxudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXHJcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcclxuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XHJcblxyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XHJcblxyXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxyXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xyXG4gIHZhciBlcnJvcnMgPSBbXTtcclxuICBpZiAoYXN0KSB7XHJcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xyXG4gIH1cclxuICByZXR1cm4gZXJyb3JzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XHJcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcclxuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XHJcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XHJcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XHJcbiAgICBlcnJvcnMucHVzaChcclxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcclxuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxyXG4gICAgKTtcclxuICB9XHJcbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xyXG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcclxuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcclxuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XHJcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxyXG4gIGlkZW50LFxyXG4gIHR5cGUsXHJcbiAgdGV4dCxcclxuICBlcnJvcnNcclxuKSB7XHJcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xyXG4gIHRyeSB7XHJcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcclxuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgZXJyb3JzLnB1c2goXHJcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xyXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSlcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKFxyXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXHJcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcclxuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XHJcbiAgICByZXR1cm4gbm9vcFxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xyXG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxyXG4gICAgdGVtcGxhdGUsXHJcbiAgICBvcHRpb25zLFxyXG4gICAgdm1cclxuICApIHtcclxuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcclxuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcclxuICAgICAgICAgIHdhcm4kJDEoXHJcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcclxuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xyXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xyXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXHJcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgY2FjaGVcclxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcclxuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXHJcbiAgICAgIDogdGVtcGxhdGU7XHJcbiAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXBpbGVcclxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICB3YXJuJCQxKFxyXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xyXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xyXG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xyXG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXHJcbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxyXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHdhcm4kJDEoXHJcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xyXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xyXG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xyXG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXHJcbiAgICAgIHRlbXBsYXRlLFxyXG4gICAgICBvcHRpb25zXHJcbiAgICApIHtcclxuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xyXG4gICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgIHZhciB0aXBzID0gW107XHJcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XHJcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XHJcbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcclxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcclxuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcclxuICAgICAgfVxyXG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xyXG4gICAgICByZXR1cm4gY29tcGlsZWRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb21waWxlOiBjb21waWxlLFxyXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxyXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXHJcbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxyXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxyXG4gIHRlbXBsYXRlLFxyXG4gIG9wdGlvbnNcclxuKSB7XHJcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XHJcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XHJcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xyXG4gIH1cclxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFzdDogYXN0LFxyXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcclxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcclxuICB9XHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XHJcbnZhciBjb21waWxlID0gcmVmJDEuY29tcGlsZTtcclxudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcclxudmFyIGRpdjtcclxuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XHJcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcclxuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxyXG59XHJcblxyXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxyXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XHJcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cclxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xyXG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcclxuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXHJcbn0pO1xyXG5cclxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XHJcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxyXG4gIGVsLFxyXG4gIGh5ZHJhdGluZ1xyXG4pIHtcclxuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XHJcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cclxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xyXG4gICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXHJcbiAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xyXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsKSB7XHJcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcclxuICAgIH1cclxuICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICBtYXJrKCdjb21waWxlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcclxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXHJcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXHJcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxyXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcclxuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcclxuXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XHJcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcclxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XHJcbiAgaWYgKGVsLm91dGVySFRNTCkge1xyXG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXHJcbiAgfVxyXG59XHJcblxyXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1\\n\")},function(module,exports){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\r\\n// css base code, injected by the css-loader\\r\\nmodule.exports = function(useSourceMap) {\\r\\n\\tvar list = [];\\r\\n\\r\\n\\t// return the list of modules as css string\\r\\n\\tlist.toString = function toString() {\\r\\n\\t\\treturn this.map(function (item) {\\r\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\r\\n\\t\\t\\tif(item[2]) {\\r\\n\\t\\t\\t\\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn content;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}).join(\"\");\\r\\n\\t};\\r\\n\\r\\n\\t// import a list of modules into the list\\r\\n\\tlist.i = function(modules, mediaQuery) {\\r\\n\\t\\tif(typeof modules === \"string\")\\r\\n\\t\\t\\tmodules = [[null, modules, \"\"]];\\r\\n\\t\\tvar alreadyImportedModules = {};\\r\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\r\\n\\t\\t\\tvar id = this[i][0];\\r\\n\\t\\t\\tif(typeof id === \"number\")\\r\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\r\\n\\t\\t}\\r\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\r\\n\\t\\t\\tvar item = modules[i];\\r\\n\\t\\t\\t// skip already imported module\\r\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\r\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\r\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\r\\n\\t\\t\\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\\r\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\r\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\r\\n\\t\\t\\t\\t} else if(mediaQuery) {\\r\\n\\t\\t\\t\\t\\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tlist.push(item);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\treturn list;\\r\\n};\\r\\n\\r\\nfunction cssWithMappingToString(item, useSourceMap) {\\r\\n\\tvar content = item[1] || \\'\\';\\r\\n\\tvar cssMapping = item[3];\\r\\n\\tif (!cssMapping) {\\r\\n\\t\\treturn content;\\r\\n\\t}\\r\\n\\r\\n\\tif (useSourceMap && typeof btoa === \\'function\\') {\\r\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\r\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\r\\n\\t\\t\\treturn \\'/*# sourceURL=\\' + cssMapping.sourceRoot + source + \\' */\\'\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\\'\\\\n\\');\\r\\n\\t}\\r\\n\\r\\n\\treturn [content].join(\\'\\\\n\\');\\r\\n}\\r\\n\\r\\n// Adapted from convert-source-map (MIT)\\r\\nfunction toComment(sourceMap) {\\r\\n\\t// eslint-disable-next-line no-undef\\r\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\r\\n\\tvar data = \\'sourceMappingURL=data:application/json;charset=utf-8;base64,\\' + base64;\\r\\n\\r\\n\\treturn \\'/*# \\' + data + \\' */\\';\\r\\n}\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH0pLmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xyXG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcclxuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XHJcblx0aWYgKCFjc3NNYXBwaW5nKSB7XHJcblx0XHRyZXR1cm4gY29udGVudDtcclxuXHR9XHJcblxyXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xyXG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXHJcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcclxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcclxuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xyXG5cclxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///2\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n\\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\\n/**\\r\\n * Translates the list format produced by css-loader into something\\r\\n * easier to manipulate.\\r\\n */\\r\\nfunction listToStyles (parentId, list) {\\r\\n  var styles = []\\r\\n  var newStyles = {}\\r\\n  for (var i = 0; i < list.length; i++) {\\r\\n    var item = list[i]\\r\\n    var id = item[0]\\r\\n    var css = item[1]\\r\\n    var media = item[2]\\r\\n    var sourceMap = item[3]\\r\\n    var part = {\\r\\n      id: parentId + ':' + i,\\r\\n      css: css,\\r\\n      media: media,\\r\\n      sourceMap: sourceMap\\r\\n    }\\r\\n    if (!newStyles[id]) {\\r\\n      styles.push(newStyles[id] = { id: id, parts: [part] })\\r\\n    } else {\\r\\n      newStyles[id].parts.push(part)\\r\\n    }\\r\\n  }\\r\\n  return styles\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"default\\\", function() { return addStylesClient; });\\n/*\\r\\n  MIT License http://www.opensource.org/licenses/mit-license.php\\r\\n  Author Tobias Koppers @sokra\\r\\n  Modified by Evan You @yyx990803\\r\\n*/\\r\\n\\r\\n\\r\\n\\r\\nvar hasDocument = typeof document !== 'undefined'\\r\\n\\r\\nif (typeof DEBUG !== 'undefined' && DEBUG) {\\r\\n  if (!hasDocument) {\\r\\n    throw new Error(\\r\\n    'vue-style-loader cannot be used in a non-browser environment. ' +\\r\\n    \\\"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\\\"\\r\\n  ) }\\r\\n}\\r\\n\\r\\n/*\\r\\ntype StyleObject = {\\r\\n  id: number;\\r\\n  parts: Array<StyleObjectPart>\\r\\n}\\r\\n\\r\\ntype StyleObjectPart = {\\r\\n  css: string;\\r\\n  media: string;\\r\\n  sourceMap: ?string\\r\\n}\\r\\n*/\\r\\n\\r\\nvar stylesInDom = {/*\\r\\n  [id: number]: {\\r\\n    id: number,\\r\\n    refs: number,\\r\\n    parts: Array<(obj?: StyleObjectPart) => void>\\r\\n  }\\r\\n*/}\\r\\n\\r\\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\\r\\nvar singletonElement = null\\r\\nvar singletonCounter = 0\\r\\nvar isProduction = false\\r\\nvar noop = function () {}\\r\\nvar options = null\\r\\nvar ssrIdKey = 'data-vue-ssr-id'\\r\\n\\r\\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\r\\n// tags it will allow on a page\\r\\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase())\\r\\n\\r\\nfunction addStylesClient (parentId, list, _isProduction, _options) {\\r\\n  isProduction = _isProduction\\r\\n\\r\\n  options = _options || {}\\r\\n\\r\\n  var styles = listToStyles(parentId, list)\\r\\n  addStylesToDom(styles)\\r\\n\\r\\n  return function update (newList) {\\r\\n    var mayRemove = []\\r\\n    for (var i = 0; i < styles.length; i++) {\\r\\n      var item = styles[i]\\r\\n      var domStyle = stylesInDom[item.id]\\r\\n      domStyle.refs--\\r\\n      mayRemove.push(domStyle)\\r\\n    }\\r\\n    if (newList) {\\r\\n      styles = listToStyles(parentId, newList)\\r\\n      addStylesToDom(styles)\\r\\n    } else {\\r\\n      styles = []\\r\\n    }\\r\\n    for (var i = 0; i < mayRemove.length; i++) {\\r\\n      var domStyle = mayRemove[i]\\r\\n      if (domStyle.refs === 0) {\\r\\n        for (var j = 0; j < domStyle.parts.length; j++) {\\r\\n          domStyle.parts[j]()\\r\\n        }\\r\\n        delete stylesInDom[domStyle.id]\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\\r\\n  for (var i = 0; i < styles.length; i++) {\\r\\n    var item = styles[i]\\r\\n    var domStyle = stylesInDom[item.id]\\r\\n    if (domStyle) {\\r\\n      domStyle.refs++\\r\\n      for (var j = 0; j < domStyle.parts.length; j++) {\\r\\n        domStyle.parts[j](item.parts[j])\\r\\n      }\\r\\n      for (; j < item.parts.length; j++) {\\r\\n        domStyle.parts.push(addStyle(item.parts[j]))\\r\\n      }\\r\\n      if (domStyle.parts.length > item.parts.length) {\\r\\n        domStyle.parts.length = item.parts.length\\r\\n      }\\r\\n    } else {\\r\\n      var parts = []\\r\\n      for (var j = 0; j < item.parts.length; j++) {\\r\\n        parts.push(addStyle(item.parts[j]))\\r\\n      }\\r\\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createStyleElement () {\\r\\n  var styleElement = document.createElement('style')\\r\\n  styleElement.type = 'text/css'\\r\\n  head.appendChild(styleElement)\\r\\n  return styleElement\\r\\n}\\r\\n\\r\\nfunction addStyle (obj /* StyleObjectPart */) {\\r\\n  var update, remove\\r\\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\\\"' + obj.id + '\\\"]')\\r\\n\\r\\n  if (styleElement) {\\r\\n    if (isProduction) {\\r\\n      // has SSR styles and in production mode.\\r\\n      // simply do nothing.\\r\\n      return noop\\r\\n    } else {\\r\\n      // has SSR styles but in dev mode.\\r\\n      // for some reason Chrome can't handle source map in server-rendered\\r\\n      // style tags - source maps in <style> only works if the style tag is\\r\\n      // created and inserted dynamically. So we remove the server rendered\\r\\n      // styles and inject new ones.\\r\\n      styleElement.parentNode.removeChild(styleElement)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (isOldIE) {\\r\\n    // use singleton mode for IE9.\\r\\n    var styleIndex = singletonCounter++\\r\\n    styleElement = singletonElement || (singletonElement = createStyleElement())\\r\\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\\r\\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\\r\\n  } else {\\r\\n    // use multi-style-tag mode in all other cases\\r\\n    styleElement = createStyleElement()\\r\\n    update = applyToTag.bind(null, styleElement)\\r\\n    remove = function () {\\r\\n      styleElement.parentNode.removeChild(styleElement)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  update(obj)\\r\\n\\r\\n  return function updateStyle (newObj /* StyleObjectPart */) {\\r\\n    if (newObj) {\\r\\n      if (newObj.css === obj.css &&\\r\\n          newObj.media === obj.media &&\\r\\n          newObj.sourceMap === obj.sourceMap) {\\r\\n        return\\r\\n      }\\r\\n      update(obj = newObj)\\r\\n    } else {\\r\\n      remove()\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar replaceText = (function () {\\r\\n  var textStore = []\\r\\n\\r\\n  return function (index, replacement) {\\r\\n    textStore[index] = replacement\\r\\n    return textStore.filter(Boolean).join('\\\\n')\\r\\n  }\\r\\n})()\\r\\n\\r\\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\\r\\n  var css = remove ? '' : obj.css\\r\\n\\r\\n  if (styleElement.styleSheet) {\\r\\n    styleElement.styleSheet.cssText = replaceText(index, css)\\r\\n  } else {\\r\\n    var cssNode = document.createTextNode(css)\\r\\n    var childNodes = styleElement.childNodes\\r\\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\\r\\n    if (childNodes.length) {\\r\\n      styleElement.insertBefore(cssNode, childNodes[index])\\r\\n    } else {\\r\\n      styleElement.appendChild(cssNode)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction applyToTag (styleElement, obj) {\\r\\n  var css = obj.css\\r\\n  var media = obj.media\\r\\n  var sourceMap = obj.sourceMap\\r\\n\\r\\n  if (media) {\\r\\n    styleElement.setAttribute('media', media)\\r\\n  }\\r\\n  if (options.ssrId) {\\r\\n    styleElement.setAttribute(ssrIdKey, obj.id)\\r\\n  }\\r\\n\\r\\n  if (sourceMap) {\\r\\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\\r\\n    // this makes source maps inside style tags work properly in Chrome\\r\\n    css += '\\\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\\r\\n    // http://stackoverflow.com/a/26603875\\r\\n    css += '\\\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\\r\\n  }\\r\\n\\r\\n  if (styleElement.styleSheet) {\\r\\n    styleElement.styleSheet.cssText = css\\r\\n  } else {\\r\\n    while (styleElement.firstChild) {\\r\\n      styleElement.removeChild(styleElement.firstChild)\\r\\n    }\\r\\n    styleElement.appendChild(document.createTextNode(css))\\r\\n  }\\r\\n}\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzliYmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz80OTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcclxuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XHJcbiAgdmFyIHN0eWxlcyA9IFtdXHJcbiAgdmFyIG5ld1N0eWxlcyA9IHt9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cclxuICAgIHZhciBpZCA9IGl0ZW1bMF1cclxuICAgIHZhciBjc3MgPSBpdGVtWzFdXHJcbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXHJcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxyXG4gICAgdmFyIHBhcnQgPSB7XHJcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXHJcbiAgICAgIGNzczogY3NzLFxyXG4gICAgICBtZWRpYTogbWVkaWEsXHJcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXHJcbiAgICB9XHJcbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcclxuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0eWxlc1xyXG59XHJcbiIsIi8qXHJcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xyXG4qL1xyXG5cclxuaW1wb3J0IGxpc3RUb1N0eWxlcyBmcm9tICcuL2xpc3RUb1N0eWxlcydcclxuXHJcbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcclxuXHJcbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XHJcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXHJcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcclxuICApIH1cclxufVxyXG5cclxuLypcclxudHlwZSBTdHlsZU9iamVjdCA9IHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XHJcbn1cclxuXHJcbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xyXG4gIGNzczogc3RyaW5nO1xyXG4gIG1lZGlhOiBzdHJpbmc7XHJcbiAgc291cmNlTWFwOiA/c3RyaW5nXHJcbn1cclxuKi9cclxuXHJcbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxyXG4gIFtpZDogbnVtYmVyXToge1xyXG4gICAgaWQ6IG51bWJlcixcclxuICAgIHJlZnM6IG51bWJlcixcclxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxyXG4gIH1cclxuKi99XHJcblxyXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXHJcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxyXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcclxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cclxudmFyIG9wdGlvbnMgPSBudWxsXHJcbnZhciBzc3JJZEtleSA9ICdkYXRhLXZ1ZS1zc3ItaWQnXHJcblxyXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZFN0eWxlc0NsaWVudCAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24sIF9vcHRpb25zKSB7XHJcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxyXG5cclxuICBvcHRpb25zID0gX29wdGlvbnMgfHwge31cclxuXHJcbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcclxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcclxuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cclxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cclxuICAgICAgZG9tU3R5bGUucmVmcy0tXHJcbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxyXG4gICAgfVxyXG4gICAgaWYgKG5ld0xpc3QpIHtcclxuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxyXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHlsZXMgPSBbXVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXHJcbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXHJcbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxyXG4gICAgaWYgKGRvbVN0eWxlKSB7XHJcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcclxuICAgICAgfVxyXG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBwYXJ0cyA9IFtdXHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXHJcbiAgICAgIH1cclxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcclxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxyXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xyXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxyXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcclxuICB2YXIgdXBkYXRlLCByZW1vdmVcclxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcclxuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcclxuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cclxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXHJcbiAgICAgIHJldHVybiBub29wXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXHJcbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXHJcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xyXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcclxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXHJcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpc09sZElFKSB7XHJcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cclxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXHJcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXHJcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcclxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcclxuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXHJcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxyXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGUob2JqKVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcclxuICAgIGlmIChuZXdPYmopIHtcclxuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcclxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXHJcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlbW92ZSgpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XHJcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxyXG4gIH1cclxufSkoKVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxyXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xyXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXHJcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuICB2YXIgY3NzID0gb2JqLmNzc1xyXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxyXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXHJcblxyXG4gIGlmIChtZWRpYSkge1xyXG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuc3NySWQpIHtcclxuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcclxuICB9XHJcblxyXG4gIGlmIChzb3VyY2VNYXApIHtcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xyXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxyXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXHJcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcclxuICB9XHJcblxyXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxyXG4gICAgfVxyXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXHJcbiAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///3\\n\")},function(module,exports){eval('var g;\\r\\n\\r\\n// This works in non-strict mode\\r\\ng = (function() {\\r\\n\\treturn this;\\r\\n})();\\r\\n\\r\\ntry {\\r\\n\\t// This works if eval is allowed (see CSP)\\r\\n\\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\\r\\n} catch (e) {\\r\\n\\t// This works if the window reference is available\\r\\n\\tif (typeof window === \"object\") g = window;\\r\\n}\\r\\n\\r\\n// g can still be undefined, but nothing to do about it...\\r\\n// We return undefined, instead of nothing here, so it\\'s\\r\\n// easier to handle this case. if(!global) { ...}\\r\\n\\r\\nmodule.exports = g;\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n.formulario[data-v-c179f5b0] {\\\\r\\\\n        width: 90%;\\\\r\\\\n        border: 1px solid #CCCCCC;\\\\r\\\\n        background-color: #FFFFFF;\\\\r\\\\n        margin: auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n        padding: 20px;\\\\r\\\\n        display: block;\\\\r\\\\n        text-align: center;\\\\r\\\\n        padding-bottom: 5%;\\\\r\\\\n        border-radius: 3px;\\\\r\\\\n        box-shadow: 0 1px 4px rgba(0, 0, 0, .3);\\\\n}\\\\ninput[data-v-c179f5b0], button[data-v-c179f5b0]{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n      margin: 5px;\\\\r\\\\n      padding: 1%;\\\\n}\\\\n@media only screen and (min-width:768px) {\\\\n.formulario[data-v-c179f5b0] {\\\\r\\\\n        width: 30%;\\\\r\\\\n        margin: 0 auto;\\\\r\\\\n        margin-top: 10%;\\\\n}\\\\ninput[data-v-c179f5b0], button[data-v-c179f5b0]{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\n}\\\\nbutton[data-v-c179f5b0]{\\\\r\\\\n        padding: 2%;\\\\n}\\\\n}\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/src/components/Signup.vue\"],\"names\":[],\"mappings\":\";AA8CA;QACA,WAAA;QACA,0BAAA;QACA,0BAAA;QACA,aAAA;QACA,gBAAA;QACA,cAAA;QACA,eAAA;QACA,mBAAA;QACA,mBAAA;QACA,mBAAA;QACA,wCAAA;CACA;AACA;MACA,WAAA;MACA,YAAA;MACA,YAAA;MACA,YAAA;CAEA;AAEA;AACA;QACA,WAAA;QACA,eAAA;QACA,gBAAA;CAEA;AACA;MACA,WAAA;MACA,YAAA;CACA;AAEA;QACA,YAAA;CACA;CACA\",\"file\":\"Signup.vue\",\"sourcesContent\":[\"<template>\\\\r\\\\n<div id=\\\\\"register\\\\\">\\\\r\\\\n<div class=\\\\\"formulario\\\\\">\\\\r\\\\n    <h1>Crear cuenta</h1>\\\\r\\\\n     <input type=\\\\\"text\\\\\" name=\\\\\"username\\\\\" v-model=\\\\\"input.username\\\\\" placeholder=\\\\\"Usuario\\\\\">\\\\r\\\\n      <input type=\\\\\"password\\\\\" name=\\\\\"password\\\\\" v-model=\\\\\"input.email\\\\\" placeholder=\\\\\"Email\\\\\">\\\\r\\\\n      <input type=\\\\\"text\\\\\" name=\\\\\"username\\\\\" v-model=\\\\\"input.password\\\\\" placeholder=\\\\\"Contrasea\\\\\">\\\\r\\\\n      <input type=\\\\\"password\\\\\" name=\\\\\"password\\\\\" v-model=\\\\\"input.tipo\\\\\" placeholder=\\\\\"Tipo\\\\\">\\\\r\\\\n       <button type=\\\\\"button\\\\\" v-on:click=\\\\\"signup()\\\\\">Registrar</button>\\\\r\\\\n</div>\\\\r\\\\n</div>\\\\r\\\\n</template>\\\\r\\\\n\\\\r\\\\n<script>\\\\r\\\\n    export default {\\\\r\\\\n        name: \\'register\\',\\\\r\\\\ndata() {\\\\r\\\\n    return {\\\\r\\\\n        input: {\\\\r\\\\n            username: \\\\\"\\\\\",\\\\r\\\\n            email: \\\\\"\\\\\",\\\\r\\\\n            password: \\\\\"\\\\\",\\\\r\\\\n            tipo: \\\\\"\\\\\"\\\\r\\\\n\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n},\\\\r\\\\nmethods: {\\\\r\\\\n            signup() {\\\\r\\\\n                if(this.input.username != \\\\\"\\\\\" && this.input.password != \\\\\"\\\\\") {\\\\r\\\\n                    if(this.input.username == this.$parent.mockAccount.username && this.input.password == this.$parent.mockAccount.password) {\\\\r\\\\n                        this.$emit(\\\\\"authenticated\\\\\", true);\\\\r\\\\n                      //  localStorage.setItem(\\'user\\',input.username)\\\\r\\\\n                        this.$router.replace({ name: \\\\\"secure\\\\\" });\\\\r\\\\n                    } else {\\\\r\\\\n                        console.log(\\\\\"The username and / or password is incorrect\\\\\");\\\\r\\\\n                    }\\\\r\\\\n                } else {\\\\r\\\\n                    console.log(\\\\\"A username and password must be present\\\\\");\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n<\\/script>\\\\r\\\\n<style scoped>\\\\r\\\\n\\\\r\\\\n    .formulario {\\\\r\\\\n        width: 90%;\\\\r\\\\n        border: 1px solid #CCCCCC;\\\\r\\\\n        background-color: #FFFFFF;\\\\r\\\\n        margin: auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n        padding: 20px;\\\\r\\\\n        display: block;\\\\r\\\\n        text-align: center;\\\\r\\\\n        padding-bottom: 5%;\\\\r\\\\n        border-radius: 3px;\\\\r\\\\n        box-shadow: 0 1px 4px rgba(0, 0, 0, .3);\\\\r\\\\n    }\\\\r\\\\n    input, button{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n      margin: 5px;\\\\r\\\\n      padding: 1%;\\\\r\\\\n\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    @media only screen and (min-width:768px) {\\\\r\\\\n    .formulario {\\\\r\\\\n        width: 30%;\\\\r\\\\n        margin: 0 auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n\\\\r\\\\n    }\\\\r\\\\n    input, button{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    button{\\\\r\\\\n        padding: 2%;\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n</style>\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TaWdudXAudnVlPzA3ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBK0M7QUFDbEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLG1DQUFtQyx1QkFBdUIsc0NBQXNDLHNDQUFzQyx5QkFBeUIsNEJBQTRCLDBCQUEwQiwyQkFBMkIsK0JBQStCLCtCQUErQiwrQkFBK0Isb0RBQW9ELEdBQUcsa0RBQWtELHFCQUFxQixzQkFBc0Isc0JBQXNCLHNCQUFzQixHQUFHLDRDQUE0QyxnQ0FBZ0MsdUJBQXVCLDJCQUEyQiw0QkFBNEIsR0FBRyxrREFBa0QscUJBQXFCLHNCQUFzQixHQUFHLDBCQUEwQix3QkFBd0IsR0FBRyxHQUFHLFlBQVksc0lBQXNJLE1BQU0sVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLEtBQUssS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxpckJBQWlyQix5Q0FBeUMsZ0JBQWdCLG9CQUFvQixxSUFBcUksU0FBUyxLQUFLLGVBQWUsMEJBQTBCLG9GQUFvRixrSkFBa0osZ0VBQWdFLDJIQUEySCxtQkFBbUIsRUFBRSx5QkFBeUIsT0FBTyx5RkFBeUYseUJBQXlCLHFCQUFxQixPQUFPLGlGQUFpRixxQkFBcUIsaUJBQWlCLGFBQWEsU0FBUyx3REFBd0QsdUJBQXVCLHNDQUFzQyxzQ0FBc0MseUJBQXlCLDRCQUE0QiwwQkFBMEIsMkJBQTJCLCtCQUErQiwrQkFBK0IsK0JBQStCLG9EQUFvRCxTQUFTLHNCQUFzQixxQkFBcUIsc0JBQXNCLHNCQUFzQixzQkFBc0IsYUFBYSxzREFBc0QscUJBQXFCLHVCQUF1QiwyQkFBMkIsNEJBQTRCLGFBQWEsc0JBQXNCLHFCQUFxQixzQkFBc0IsU0FBUyxtQkFBbUIsd0JBQXdCLFNBQVMsS0FBSywrQkFBK0I7O0FBRTV3SCIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5mb3JtdWxhcmlvW2RhdGEtdi1jMTc5ZjViMF0ge1xcclxcbiAgICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0NDQ0M7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcclxcbiAgICAgICAgbWFyZ2luOiBhdXRvO1xcclxcbiAgICAgICAgbWFyZ2luLXRvcDogMTAlO1xcclxcbiAgICAgICAgcGFkZGluZzogMjBweDtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDUlO1xcclxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgLjMpO1xcbn1cXG5pbnB1dFtkYXRhLXYtYzE3OWY1YjBdLCBidXR0b25bZGF0YS12LWMxNzlmNWIwXXtcXHJcXG4gICAgICB3aWR0aDogOTAlO1xcclxcbiAgICAgIGhlaWdodDogNDAlO1xcclxcbiAgICAgIG1hcmdpbjogNXB4O1xcclxcbiAgICAgIHBhZGRpbmc6IDElO1xcbn1cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NzY4cHgpIHtcXG4uZm9ybXVsYXJpb1tkYXRhLXYtYzE3OWY1YjBdIHtcXHJcXG4gICAgICAgIHdpZHRoOiAzMCU7XFxyXFxuICAgICAgICBtYXJnaW46IDAgYXV0bztcXHJcXG4gICAgICAgIG1hcmdpbi10b3A6IDEwJTtcXG59XFxuaW5wdXRbZGF0YS12LWMxNzlmNWIwXSwgYnV0dG9uW2RhdGEtdi1jMTc5ZjViMF17XFxyXFxuICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICBoZWlnaHQ6IDQwJTtcXG59XFxuYnV0dG9uW2RhdGEtdi1jMTc5ZjViMF17XFxyXFxuICAgICAgICBwYWRkaW5nOiAyJTtcXG59XFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9LZWluZXIvRHJvcGJveC9VTklOT1JURS9zYWx1ZHRlY2gvc3JjL2NvbXBvbmVudHMvc3JjL2NvbXBvbmVudHMvU2lnbnVwLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBOENBO1FBQ0EsV0FBQTtRQUNBLDBCQUFBO1FBQ0EsMEJBQUE7UUFDQSxhQUFBO1FBQ0EsZ0JBQUE7UUFDQSxjQUFBO1FBQ0EsZUFBQTtRQUNBLG1CQUFBO1FBQ0EsbUJBQUE7UUFDQSxtQkFBQTtRQUNBLHdDQUFBO0NBQ0E7QUFDQTtNQUNBLFdBQUE7TUFDQSxZQUFBO01BQ0EsWUFBQTtNQUNBLFlBQUE7Q0FFQTtBQUVBO0FBQ0E7UUFDQSxXQUFBO1FBQ0EsZUFBQTtRQUNBLGdCQUFBO0NBRUE7QUFDQTtNQUNBLFdBQUE7TUFDQSxZQUFBO0NBQ0E7QUFFQTtRQUNBLFlBQUE7Q0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJTaWdudXAudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG48ZGl2IGlkPVxcXCJyZWdpc3RlclxcXCI+XFxyXFxuPGRpdiBjbGFzcz1cXFwiZm9ybXVsYXJpb1xcXCI+XFxyXFxuICAgIDxoMT5DcmVhciBjdWVudGE8L2gxPlxcclxcbiAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcInVzZXJuYW1lXFxcIiB2LW1vZGVsPVxcXCJpbnB1dC51c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIlVzdWFyaW9cXFwiPlxcclxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgbmFtZT1cXFwicGFzc3dvcmRcXFwiIHYtbW9kZWw9XFxcImlucHV0LmVtYWlsXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWxcXFwiPlxcclxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJ1c2VybmFtZVxcXCIgdi1tb2RlbD1cXFwiaW5wdXQucGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJDb250cmFzZcOxYVxcXCI+XFxyXFxuICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBuYW1lPVxcXCJwYXNzd29yZFxcXCIgdi1tb2RlbD1cXFwiaW5wdXQudGlwb1xcXCIgcGxhY2Vob2xkZXI9XFxcIlRpcG9cXFwiPlxcclxcbiAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgdi1vbjpjbGljaz1cXFwic2lnbnVwKClcXFwiPlJlZ2lzdHJhcjwvYnV0dG9uPlxcclxcbjwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuXFxyXFxuPHNjcmlwdD5cXHJcXG4gICAgZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICAgICAgbmFtZTogJ3JlZ2lzdGVyJyxcXHJcXG5kYXRhKCkge1xcclxcbiAgICByZXR1cm4ge1xcclxcbiAgICAgICAgaW5wdXQ6IHtcXHJcXG4gICAgICAgICAgICB1c2VybmFtZTogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAgZW1haWw6IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBcXFwiXFxcIixcXHJcXG4gICAgICAgICAgICB0aXBvOiBcXFwiXFxcIlxcclxcblxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufSxcXHJcXG5tZXRob2RzOiB7XFxyXFxuICAgICAgICAgICAgc2lnbnVwKCkge1xcclxcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlucHV0LnVzZXJuYW1lICE9IFxcXCJcXFwiICYmIHRoaXMuaW5wdXQucGFzc3dvcmQgIT0gXFxcIlxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudXNlcm5hbWUgPT0gdGhpcy4kcGFyZW50Lm1vY2tBY2NvdW50LnVzZXJuYW1lICYmIHRoaXMuaW5wdXQucGFzc3dvcmQgPT0gdGhpcy4kcGFyZW50Lm1vY2tBY2NvdW50LnBhc3N3b3JkKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdChcXFwiYXV0aGVudGljYXRlZFxcXCIsIHRydWUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXInLGlucHV0LnVzZXJuYW1lKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5yZXBsYWNlKHsgbmFtZTogXFxcInNlY3VyZVxcXCIgfSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJUaGUgdXNlcm5hbWUgYW5kIC8gb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0XFxcIik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiQSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgbXVzdCBiZSBwcmVzZW50XFxcIik7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGUgc2NvcGVkPlxcclxcblxcclxcbiAgICAuZm9ybXVsYXJpbyB7XFxyXFxuICAgICAgICB3aWR0aDogOTAlO1xcclxcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcXHJcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxyXFxuICAgICAgICBtYXJnaW46IGF1dG87XFxyXFxuICAgICAgICBtYXJnaW4tdG9wOiAxMCU7XFxyXFxuICAgICAgICBwYWRkaW5nOiAyMHB4O1xcclxcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgICAgICBwYWRkaW5nLWJvdHRvbTogNSU7XFxyXFxuICAgICAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAuMyk7XFxyXFxuICAgIH1cXHJcXG4gICAgaW5wdXQsIGJ1dHRvbntcXHJcXG4gICAgICB3aWR0aDogOTAlO1xcclxcbiAgICAgIGhlaWdodDogNDAlO1xcclxcbiAgICAgIG1hcmdpbjogNXB4O1xcclxcbiAgICAgIHBhZGRpbmc6IDElO1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NjhweCkge1xcclxcbiAgICAuZm9ybXVsYXJpbyB7XFxyXFxuICAgICAgICB3aWR0aDogMzAlO1xcclxcbiAgICAgICAgbWFyZ2luOiAwIGF1dG87XFxyXFxuICAgICAgICBtYXJnaW4tdG9wOiAxMCU7XFxyXFxuXFxyXFxuICAgIH1cXHJcXG4gICAgaW5wdXQsIGJ1dHRvbntcXHJcXG4gICAgICB3aWR0aDogOTAlO1xcclxcbiAgICAgIGhlaWdodDogNDAlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGJ1dHRvbntcXHJcXG4gICAgICAgIHBhZGRpbmc6IDIlO1xcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc3R5bGU+XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n#secure[data-v-1b3ea807] {\\\\n        background-color: #FFFFFF;\\\\n        border: 1px solid #CCCCCC;\\\\n        padding: 20px;\\\\n        margin-top: 10px;\\\\n}\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/src/components/Secure.vue\"],\"names\":[],\"mappings\":\";AAmBA;QACA,0BAAA;QACA,0BAAA;QACA,cAAA;QACA,iBAAA;CACA\",\"file\":\"Secure.vue\",\"sourcesContent\":[\"<template>\\\\n    <div id=\\\\\"secure\\\\\">\\\\n        <h1>Secure Area</h1>\\\\n        <p>\\\\n            This is a secure area\\\\n        </p>\\\\n    </div>\\\\n</template>\\\\n\\\\n<script>\\\\n    export default {\\\\n        name: \\'Secure\\',\\\\n        data() {\\\\n            return {};\\\\n        }\\\\n    }\\\\n<\\/script>\\\\n\\\\n<style scoped>\\\\n    #secure {\\\\n        background-color: #FFFFFF;\\\\n        border: 1px solid #CCCCCC;\\\\n        padding: 20px;\\\\n        margin-top: 10px;\\\\n    }\\\\n</style>\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TZWN1cmUudnVlP2QwODIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBK0M7QUFDbEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLCtCQUErQixvQ0FBb0Msb0NBQW9DLHdCQUF3QiwyQkFBMkIsR0FBRyxVQUFVLHNJQUFzSSxNQUFNLFdBQVcsV0FBVyxVQUFVLFdBQVcsdU9BQXVPLDJDQUEyQyx3QkFBd0IsV0FBVyxPQUFPLDRDQUE0QyxvQ0FBb0Msb0NBQW9DLHdCQUF3QiwyQkFBMkIsT0FBTywrQkFBK0I7O0FBRTkzQiIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbiNzZWN1cmVbZGF0YS12LTFiM2VhODA3XSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcXG4gICAgICAgIHBhZGRpbmc6IDIwcHg7XFxuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvS2VpbmVyL0Ryb3Bib3gvVU5JTk9SVEUvc2FsdWR0ZWNoL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL1NlY3VyZS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQW1CQTtRQUNBLDBCQUFBO1FBQ0EsMEJBQUE7UUFDQSxjQUFBO1FBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiU2VjdXJlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXYgaWQ9XFxcInNlY3VyZVxcXCI+XFxuICAgICAgICA8aDE+U2VjdXJlIEFyZWE8L2gxPlxcbiAgICAgICAgPHA+XFxuICAgICAgICAgICAgVGhpcyBpcyBhIHNlY3VyZSBhcmVhXFxuICAgICAgICA8L3A+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG4gICAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICAgICAgbmFtZTogJ1NlY3VyZScsXFxuICAgICAgICBkYXRhKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7fTtcXG4gICAgICAgIH1cXG4gICAgfVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuICAgICNzZWN1cmUge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0NDQ0M7XFxuICAgICAgICBwYWRkaW5nOiAyMHB4O1xcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcXG4gICAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///6\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n.formulario[data-v-9fcfedee] {\\\\r\\\\n        width: 90%;\\\\r\\\\n        border: 1px solid #CCCCCC;\\\\r\\\\n        background-color: #FFFFFF;\\\\r\\\\n        margin: auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n        padding: 20px;\\\\r\\\\n        display: block;\\\\r\\\\n        text-align: center;\\\\r\\\\n        padding-bottom: 5%;\\\\r\\\\n        border-radius: 3px;\\\\r\\\\n        box-shadow: 0 1px 4px rgba(0, 0, 0, .3);\\\\n}\\\\ninput[data-v-9fcfedee], button[data-v-9fcfedee]{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n      margin: 5px;\\\\r\\\\n      padding: 1%;\\\\n}\\\\n@media only screen and (min-width:768px) {\\\\n.formulario[data-v-9fcfedee] {\\\\r\\\\n        width: 30%;\\\\r\\\\n        margin: 0 auto;\\\\r\\\\n        margin-top: 10%;\\\\n}\\\\ninput[data-v-9fcfedee], button[data-v-9fcfedee]{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\n}\\\\nbutton[data-v-9fcfedee]{\\\\r\\\\n        padding: 2%;\\\\n}\\\\n}\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/src/components/Login.vue\"],\"names\":[],\"mappings\":\";AA2CA;QACA,WAAA;QACA,0BAAA;QACA,0BAAA;QACA,aAAA;QACA,gBAAA;QACA,cAAA;QACA,eAAA;QACA,mBAAA;QACA,mBAAA;QACA,mBAAA;QACA,wCAAA;CACA;AACA;MACA,WAAA;MACA,YAAA;MACA,YAAA;MACA,YAAA;CAEA;AAEA;AACA;QACA,WAAA;QACA,eAAA;QACA,gBAAA;CAEA;AACA;MACA,WAAA;MACA,YAAA;CACA;AAEA;QACA,YAAA;CACA;CACA\",\"file\":\"Login.vue\",\"sourcesContent\":[\"<template>\\\\r\\\\n  <div id=\\\\\"Login\\\\\">\\\\r\\\\n    <div class=\\\\\"formulario\\\\\">\\\\r\\\\n      <h1>Inicio de sesin</h1>\\\\r\\\\n      <input type=\\\\\"text\\\\\" name=\\\\\"username\\\\\" v-model=\\\\\"input.username\\\\\" placeholder=\\\\\"Usuario\\\\\">\\\\r\\\\n      <input type=\\\\\"password\\\\\" name=\\\\\"password\\\\\" v-model=\\\\\"input.password\\\\\" placeholder=\\\\\"Contrasea\\\\\">\\\\r\\\\n      <button type=\\\\\"button\\\\\" v-on:click=\\\\\"login()\\\\\">Login</button>\\\\r\\\\n      <router-link to=\\\\\"signup\\\\\">Crear cuenta</router-link>\\\\r\\\\n    </div>\\\\r\\\\n  </div>\\\\r\\\\n</template>\\\\r\\\\n\\\\r\\\\n<script>\\\\r\\\\n export default {\\\\r\\\\n        name: \\'Login\\',\\\\r\\\\ndata() {\\\\r\\\\n    return {\\\\r\\\\n        input: {\\\\r\\\\n            username: \\\\\"\\\\\",\\\\r\\\\n            password: \\\\\"\\\\\"\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n},\\\\r\\\\n        methods: {\\\\r\\\\n            login() {\\\\r\\\\n                if(this.input.username != \\\\\"\\\\\" && this.input.password != \\\\\"\\\\\") {\\\\r\\\\n                    if(this.input.username == this.$parent.mockAccount.username && this.input.password == this.$parent.mockAccount.password) {\\\\r\\\\n                        this.$emit(\\\\\"authenticated\\\\\", true);\\\\r\\\\n                      //  localStorage.setItem(\\'user\\',input.username)\\\\r\\\\n                        this.$router.replace({ name: \\\\\"secure\\\\\" });\\\\r\\\\n                    } else {\\\\r\\\\n                        console.log(\\\\\"The username and / or password is incorrect\\\\\");\\\\r\\\\n                    }\\\\r\\\\n                } else {\\\\r\\\\n                    console.log(\\\\\"A username and password must be present\\\\\");\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n<\\/script>\\\\r\\\\n\\\\r\\\\n<style scoped>\\\\r\\\\n\\\\r\\\\n    .formulario {\\\\r\\\\n        width: 90%;\\\\r\\\\n        border: 1px solid #CCCCCC;\\\\r\\\\n        background-color: #FFFFFF;\\\\r\\\\n        margin: auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n        padding: 20px;\\\\r\\\\n        display: block;\\\\r\\\\n        text-align: center;\\\\r\\\\n        padding-bottom: 5%;\\\\r\\\\n        border-radius: 3px;\\\\r\\\\n        box-shadow: 0 1px 4px rgba(0, 0, 0, .3);\\\\r\\\\n    }\\\\r\\\\n    input, button{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n      margin: 5px;\\\\r\\\\n      padding: 1%;\\\\r\\\\n\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    @media only screen and (min-width:768px) {\\\\r\\\\n    .formulario {\\\\r\\\\n        width: 30%;\\\\r\\\\n        margin: 0 auto;\\\\r\\\\n        margin-top: 10%;\\\\r\\\\n\\\\r\\\\n    }\\\\r\\\\n    input, button{\\\\r\\\\n      width: 90%;\\\\r\\\\n      height: 40%;\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    button{\\\\r\\\\n        padding: 2%;\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n</style>\\\\r\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Mb2dpbi52dWU/ZDM3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsbUNBQW1DLHVCQUF1QixzQ0FBc0Msc0NBQXNDLHlCQUF5Qiw0QkFBNEIsMEJBQTBCLDJCQUEyQiwrQkFBK0IsK0JBQStCLCtCQUErQixvREFBb0QsR0FBRyxrREFBa0QscUJBQXFCLHNCQUFzQixzQkFBc0Isc0JBQXNCLEdBQUcsNENBQTRDLGdDQUFnQyx1QkFBdUIsMkJBQTJCLDRCQUE0QixHQUFHLGtEQUFrRCxxQkFBcUIsc0JBQXNCLEdBQUcsMEJBQTBCLHdCQUF3QixHQUFHLEdBQUcsWUFBWSxxSUFBcUksTUFBTSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxVQUFVLFVBQVUsS0FBSyxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLHNqQkFBc2pCLHNDQUFzQyxnQkFBZ0Isb0JBQW9CLDBFQUEwRSxTQUFTLEtBQUssdUJBQXVCLHlCQUF5QixvRkFBb0Ysa0pBQWtKLGdFQUFnRSwySEFBMkgsbUJBQW1CLEVBQUUseUJBQXlCLE9BQU8seUZBQXlGLHlCQUF5QixxQkFBcUIsT0FBTyxpRkFBaUYscUJBQXFCLGlCQUFpQixhQUFhLFNBQVMsNERBQTRELHVCQUF1QixzQ0FBc0Msc0NBQXNDLHlCQUF5Qiw0QkFBNEIsMEJBQTBCLDJCQUEyQiwrQkFBK0IsK0JBQStCLCtCQUErQixvREFBb0QsU0FBUyxzQkFBc0IscUJBQXFCLHNCQUFzQixzQkFBc0Isc0JBQXNCLGFBQWEsc0RBQXNELHFCQUFxQix1QkFBdUIsMkJBQTJCLDRCQUE0QixhQUFhLHNCQUFzQixxQkFBcUIsc0JBQXNCLFNBQVMsbUJBQW1CLHdCQUF3QixTQUFTLEtBQUssbUNBQW1DOztBQUVqbUgiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZm9ybXVsYXJpb1tkYXRhLXYtOWZjZmVkZWVdIHtcXHJcXG4gICAgICAgIHdpZHRoOiA5MCU7XFxyXFxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xcclxcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXHJcXG4gICAgICAgIG1hcmdpbjogYXV0bztcXHJcXG4gICAgICAgIG1hcmdpbi10b3A6IDEwJTtcXHJcXG4gICAgICAgIHBhZGRpbmc6IDIwcHg7XFxyXFxuICAgICAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA1JTtcXHJcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIC4zKTtcXG59XFxuaW5wdXRbZGF0YS12LTlmY2ZlZGVlXSwgYnV0dG9uW2RhdGEtdi05ZmNmZWRlZV17XFxyXFxuICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICBoZWlnaHQ6IDQwJTtcXHJcXG4gICAgICBtYXJnaW46IDVweDtcXHJcXG4gICAgICBwYWRkaW5nOiAxJTtcXG59XFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOjc2OHB4KSB7XFxuLmZvcm11bGFyaW9bZGF0YS12LTlmY2ZlZGVlXSB7XFxyXFxuICAgICAgICB3aWR0aDogMzAlO1xcclxcbiAgICAgICAgbWFyZ2luOiAwIGF1dG87XFxyXFxuICAgICAgICBtYXJnaW4tdG9wOiAxMCU7XFxufVxcbmlucHV0W2RhdGEtdi05ZmNmZWRlZV0sIGJ1dHRvbltkYXRhLXYtOWZjZmVkZWVde1xcclxcbiAgICAgIHdpZHRoOiA5MCU7XFxyXFxuICAgICAgaGVpZ2h0OiA0MCU7XFxufVxcbmJ1dHRvbltkYXRhLXYtOWZjZmVkZWVde1xcclxcbiAgICAgICAgcGFkZGluZzogMiU7XFxufVxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvS2VpbmVyL0Ryb3Bib3gvVU5JTk9SVEUvc2FsdWR0ZWNoL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL0xvZ2luLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBMkNBO1FBQ0EsV0FBQTtRQUNBLDBCQUFBO1FBQ0EsMEJBQUE7UUFDQSxhQUFBO1FBQ0EsZ0JBQUE7UUFDQSxjQUFBO1FBQ0EsZUFBQTtRQUNBLG1CQUFBO1FBQ0EsbUJBQUE7UUFDQSxtQkFBQTtRQUNBLHdDQUFBO0NBQ0E7QUFDQTtNQUNBLFdBQUE7TUFDQSxZQUFBO01BQ0EsWUFBQTtNQUNBLFlBQUE7Q0FFQTtBQUVBO0FBQ0E7UUFDQSxXQUFBO1FBQ0EsZUFBQTtRQUNBLGdCQUFBO0NBRUE7QUFDQTtNQUNBLFdBQUE7TUFDQSxZQUFBO0NBQ0E7QUFFQTtRQUNBLFlBQUE7Q0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJMb2dpbi52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdiBpZD1cXFwiTG9naW5cXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtdWxhcmlvXFxcIj5cXHJcXG4gICAgICA8aDE+SW5pY2lvIGRlIHNlc2nDs248L2gxPlxcclxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJ1c2VybmFtZVxcXCIgdi1tb2RlbD1cXFwiaW5wdXQudXNlcm5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJVc3VhcmlvXFxcIj5cXHJcXG4gICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIG5hbWU9XFxcInBhc3N3b3JkXFxcIiB2LW1vZGVsPVxcXCJpbnB1dC5wYXNzd29yZFxcXCIgcGxhY2Vob2xkZXI9XFxcIkNvbnRyYXNlw7FhXFxcIj5cXHJcXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgdi1vbjpjbGljaz1cXFwibG9naW4oKVxcXCI+TG9naW48L2J1dHRvbj5cXHJcXG4gICAgICA8cm91dGVyLWxpbmsgdG89XFxcInNpZ251cFxcXCI+Q3JlYXIgY3VlbnRhPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcblxcclxcbjxzY3JpcHQ+XFxyXFxuIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgICAgIG5hbWU6ICdMb2dpbicsXFxyXFxuZGF0YSgpIHtcXHJcXG4gICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIGlucHV0OiB7XFxyXFxuICAgICAgICAgICAgdXNlcm5hbWU6IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBcXFwiXFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufSxcXHJcXG4gICAgICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAgICAgICBsb2dpbigpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pbnB1dC51c2VybmFtZSAhPSBcXFwiXFxcIiAmJiB0aGlzLmlucHV0LnBhc3N3b3JkICE9IFxcXCJcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmlucHV0LnVzZXJuYW1lID09IHRoaXMuJHBhcmVudC5tb2NrQWNjb3VudC51c2VybmFtZSAmJiB0aGlzLmlucHV0LnBhc3N3b3JkID09IHRoaXMuJHBhcmVudC5tb2NrQWNjb3VudC5wYXNzd29yZCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoXFxcImF1dGhlbnRpY2F0ZWRcXFwiLCB0cnVlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyJyxpbnB1dC51c2VybmFtZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRyb3V0ZXIucmVwbGFjZSh7IG5hbWU6IFxcXCJzZWN1cmVcXFwiIH0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiVGhlIHVzZXJuYW1lIGFuZCAvIG9yIHBhc3N3b3JkIGlzIGluY29ycmVjdFxcXCIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkEgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG11c3QgYmUgcHJlc2VudFxcXCIpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuPC9zY3JpcHQ+XFxyXFxuXFxyXFxuPHN0eWxlIHNjb3BlZD5cXHJcXG5cXHJcXG4gICAgLmZvcm11bGFyaW8ge1xcclxcbiAgICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0NDQ0M7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcclxcbiAgICAgICAgbWFyZ2luOiBhdXRvO1xcclxcbiAgICAgICAgbWFyZ2luLXRvcDogMTAlO1xcclxcbiAgICAgICAgcGFkZGluZzogMjBweDtcXHJcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDUlO1xcclxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgLjMpO1xcclxcbiAgICB9XFxyXFxuICAgIGlucHV0LCBidXR0b257XFxyXFxuICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICBoZWlnaHQ6IDQwJTtcXHJcXG4gICAgICBtYXJnaW46IDVweDtcXHJcXG4gICAgICBwYWRkaW5nOiAxJTtcXHJcXG5cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NzY4cHgpIHtcXHJcXG4gICAgLmZvcm11bGFyaW8ge1xcclxcbiAgICAgICAgd2lkdGg6IDMwJTtcXHJcXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xcclxcbiAgICAgICAgbWFyZ2luLXRvcDogMTAlO1xcclxcblxcclxcbiAgICB9XFxyXFxuICAgIGlucHV0LCBidXR0b257XFxyXFxuICAgICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgICBoZWlnaHQ6IDQwJTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBidXR0b257XFxyXFxuICAgICAgICBwYWRkaW5nOiAyJTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///7\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n.bajar{\\\\n  margin-top: 80px;\\\\n}\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/src/components/About.vue\"],\"names\":[],\"mappings\":\";AASA;EACA,iBAAA;CACA\",\"file\":\"About.vue\",\"sourcesContent\":[\"<template>\\\\n<div>\\\\n  <div class=\\\\\"bajar\\\\\">\\\\n  <h1>Nosotros</h1>\\\\n  <p>acerca de saludtech</p>\\\\n  </div>\\\\n</div>\\\\n</template>\\\\n<style>\\\\n.bajar{\\\\n  margin-top: 80px;\\\\n}\\\\n</style>\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BYm91dC52dWU/ZDE3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsWUFBWSxxQkFBcUIsR0FBRyxVQUFVLHFJQUFxSSxLQUFLLFdBQVcsMExBQTBMLHFCQUFxQixHQUFHLCtCQUErQjs7QUFFM2MiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uYmFqYXJ7XFxuICBtYXJnaW4tdG9wOiA4MHB4O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvS2VpbmVyL0Ryb3Bib3gvVU5JTk9SVEUvc2FsdWR0ZWNoL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL0Fib3V0LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBU0E7RUFDQSxpQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJBYm91dC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbjxkaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJiYWphclxcXCI+XFxuICA8aDE+Tm9zb3Ryb3M8L2gxPlxcbiAgPHA+YWNlcmNhIGRlIHNhbHVkdGVjaDwvcD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuPHN0eWxlPlxcbi5iYWphcntcXG4gIG1hcmdpbi10b3A6IDgwcHg7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///8\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n#main{\\\\n  margin-top: 80px;\\\\n}\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/src/components/Search.vue\"],\"names\":[],\"mappings\":\";AAqDA;EACA,iBAAA;CACA\",\"file\":\"Search.vue\",\"sourcesContent\":[\"<template>\\\\n  <div id=\\\\\"main\\\\\">\\\\n    <h1 v-for=\\\\\"i in elem\\\\\">{{ i }}</h1>\\\\n  </div>\\\\n</template>\\\\n\\\\n<script>\\\\nexport default {\\\\n  name: \\\\\"app\\\\\",\\\\n  data() {\\\\n    return {\\\\n      prueba: \\\\\"HOLA\\\\\",\\\\n      elem: [\\\\n        1,\\\\n        2,\\\\n        3,\\\\n        4,\\\\n        4,\\\\n        3,\\\\n        1,\\\\n        2,\\\\n        2,\\\\n        1,\\\\n        3,\\\\n        3,\\\\n        3,\\\\n        2,\\\\n        2,\\\\n        2,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        1,\\\\n        2,\\\\n        3,\\\\n        9\\\\n      ]\\\\n    };\\\\n  },\\\\n  methods: {}\\\\n};\\\\n<\\/script>\\\\n\\\\n<style>\\\\n#main{\\\\n  margin-top: 80px;\\\\n}\\\\n</style>\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TZWFyY2gudnVlP2EyYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBK0M7QUFDbEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLFdBQVcscUJBQXFCLEdBQUcsVUFBVSxzSUFBc0ksTUFBTSxXQUFXLDRHQUE0RyxLQUFLLDBEQUEwRCw4QkFBOEIsY0FBYyx3YkFBd2IsS0FBSyxnQkFBZ0IsSUFBSSw4QkFBOEIscUJBQXFCLEdBQUcsK0JBQStCOztBQUV4OUIiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4jbWFpbntcXG4gIG1hcmdpbi10b3A6IDgwcHg7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9LZWluZXIvRHJvcGJveC9VTklOT1JURS9zYWx1ZHRlY2gvc3JjL2NvbXBvbmVudHMvc3JjL2NvbXBvbmVudHMvU2VhcmNoLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBcURBO0VBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiU2VhcmNoLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGlkPVxcXCJtYWluXFxcIj5cXG4gICAgPGgxIHYtZm9yPVxcXCJpIGluIGVsZW1cXFwiPnt7IGkgfX08L2gxPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIG5hbWU6IFxcXCJhcHBcXFwiLFxcbiAgZGF0YSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBwcnVlYmE6IFxcXCJIT0xBXFxcIixcXG4gICAgICBlbGVtOiBbXFxuICAgICAgICAxLFxcbiAgICAgICAgMixcXG4gICAgICAgIDMsXFxuICAgICAgICA0LFxcbiAgICAgICAgNCxcXG4gICAgICAgIDMsXFxuICAgICAgICAxLFxcbiAgICAgICAgMixcXG4gICAgICAgIDIsXFxuICAgICAgICAxLFxcbiAgICAgICAgMyxcXG4gICAgICAgIDMsXFxuICAgICAgICAzLFxcbiAgICAgICAgMixcXG4gICAgICAgIDIsXFxuICAgICAgICAyLFxcbiAgICAgICAgMSxcXG4gICAgICAgIDEsXFxuICAgICAgICAxLFxcbiAgICAgICAgMSxcXG4gICAgICAgIDEsXFxuICAgICAgICAxLFxcbiAgICAgICAgMSxcXG4gICAgICAgIDEsXFxuICAgICAgICAxLFxcbiAgICAgICAgMSxcXG4gICAgICAgIDEsXFxuICAgICAgICAxLFxcbiAgICAgICAgMSxcXG4gICAgICAgIDIsXFxuICAgICAgICAzLFxcbiAgICAgICAgOVxcbiAgICAgIF1cXG4gICAgfTtcXG4gIH0sXFxuICBtZXRob2RzOiB7fVxcbn07XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlPlxcbiNtYWlue1xcbiAgbWFyZ2luLXRvcDogODBweDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///9\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\nfooter {\\\\n    background-color: var(--azul);\\\\n    position: absolute;\\\\n    padding-top: 10px;\\\\n    margin-top: 10px;\\\\n    width: 100%;\\\\n    text-align: center;\\\\n}\\\\nfooter .contenedor>div {\\\\n    color: #ffffff;\\\\n    width: 100%;\\\\n    font-size: 14px;\\\\n}\\\\nfooter h3 {\\\\n    color: #ffffff;\\\\n    text-transform: uppercase;\\\\n    font-family: \\'Oswald\\', sans-serif;\\\\n    margin-bottom: 5px;\\\\n}\\\\np.copyright {\\\\n    background-color: var(--azul);\\\\n    color: #ffffff;\\\\n    padding: 10px 0;\\\\n    margin: 10px 0 0 0;\\\\n    text-align: center;\\\\n}\\\\n\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/layout/src/components/layout/Footer.vue\"],\"names\":[],\"mappings\":\";AAiBA;IACA,8BAAA;IACA,mBAAA;IACA,kBAAA;IACA,iBAAA;IACA,YAAA;IACA,mBAAA;CACA;AAEA;IACA,eAAA;IACA,YAAA;IACA,gBAAA;CACA;AAGA;IACA,eAAA;IACA,0BAAA;IACA,kCAAA;IACA,mBAAA;CACA;AAEA;IACA,8BAAA;IACA,eAAA;IACA,gBAAA;IACA,mBAAA;IACA,mBAAA;CACA\",\"file\":\"Footer.vue\",\"sourcesContent\":[\"<template>\\\\n  <footer class=\\\\\"site-footer\\\\\">\\\\n  <div class=\\\\\"contenedor clearfix\\\\\">\\\\n    <div class=\\\\\"footer-informacion\\\\\">\\\\n      <h3>SaludTech</h3>\\\\n      <p>contacto@saludtech.com</p>\\\\n    </div>\\\\n    <div class=\\\\\"menu\\\\\">\\\\n    </div>\\\\n  </div>\\\\n  <p class=\\\\\"copyright\\\\\">Todos los derechos reservados</p>\\\\n</footer>\\\\n\\\\n</template>\\\\n<style>\\\\n\\\\n\\\\nfooter {\\\\n    background-color: var(--azul);\\\\n    position: absolute;\\\\n    padding-top: 10px;\\\\n    margin-top: 10px;\\\\n    width: 100%;\\\\n    text-align: center;\\\\n}\\\\n\\\\nfooter .contenedor>div {\\\\n    color: #ffffff;\\\\n    width: 100%;\\\\n    font-size: 14px;\\\\n}\\\\n\\\\n\\\\nfooter h3 {\\\\n    color: #ffffff;\\\\n    text-transform: uppercase;\\\\n    font-family: \\'Oswald\\', sans-serif;\\\\n    margin-bottom: 5px;\\\\n}\\\\n\\\\np.copyright {\\\\n    background-color: var(--azul);\\\\n    color: #ffffff;\\\\n    padding: 10px 0;\\\\n    margin: 10px 0 0 0;\\\\n    text-align: center;\\\\n}\\\\n\\\\n</style>\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvRm9vdGVyLnZ1ZT82ZTUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQWtEO0FBQ3JGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxhQUFhLG9DQUFvQyx5QkFBeUIsd0JBQXdCLHVCQUF1QixrQkFBa0IseUJBQXlCLEdBQUcsMEJBQTBCLHFCQUFxQixrQkFBa0Isc0JBQXNCLEdBQUcsYUFBYSxxQkFBcUIsZ0NBQWdDLHdDQUF3Qyx5QkFBeUIsR0FBRyxlQUFlLG9DQUFvQyxxQkFBcUIsc0JBQXNCLHlCQUF5Qix5QkFBeUIsR0FBRyxZQUFZLG9KQUFvSixNQUFNLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLGdaQUFnWixvQ0FBb0MseUJBQXlCLHdCQUF3Qix1QkFBdUIsa0JBQWtCLHlCQUF5QixHQUFHLDRCQUE0QixxQkFBcUIsa0JBQWtCLHNCQUFzQixHQUFHLGlCQUFpQixxQkFBcUIsZ0NBQWdDLHdDQUF3Qyx5QkFBeUIsR0FBRyxpQkFBaUIsb0NBQW9DLHFCQUFxQixzQkFBc0IseUJBQXlCLHlCQUF5QixHQUFHLGlDQUFpQzs7QUFFNTNEIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbmZvb3RlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWF6dWwpO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHBhZGRpbmctdG9wOiAxMHB4O1xcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5mb290ZXIgLmNvbnRlbmVkb3I+ZGl2IHtcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxufVxcbmZvb3RlciBoMyB7XFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICBmb250LWZhbWlseTogJ09zd2FsZCcsIHNhbnMtc2VyaWY7XFxuICAgIG1hcmdpbi1ib3R0b206IDVweDtcXG59XFxucC5jb3B5cmlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1henVsKTtcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxuICAgIHBhZGRpbmc6IDEwcHggMDtcXG4gICAgbWFyZ2luOiAxMHB4IDAgMCAwO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9LZWluZXIvRHJvcGJveC9VTklOT1JURS9zYWx1ZHRlY2gvc3JjL2NvbXBvbmVudHMvbGF5b3V0L3NyYy9jb21wb25lbnRzL2xheW91dC9Gb290ZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFpQkE7SUFDQSw4QkFBQTtJQUNBLG1CQUFBO0lBQ0Esa0JBQUE7SUFDQSxpQkFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBO0FBRUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0NBQ0E7QUFHQTtJQUNBLGVBQUE7SUFDQSwwQkFBQTtJQUNBLGtDQUFBO0lBQ0EsbUJBQUE7Q0FDQTtBQUVBO0lBQ0EsOEJBQUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSxtQkFBQTtJQUNBLG1CQUFBO0NBQ0FcIixcImZpbGVcIjpcIkZvb3Rlci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGZvb3RlciBjbGFzcz1cXFwic2l0ZS1mb290ZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGVuZWRvciBjbGVhcmZpeFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rlci1pbmZvcm1hY2lvblxcXCI+XFxuICAgICAgPGgzPlNhbHVkVGVjaDwvaDM+XFxuICAgICAgPHA+Y29udGFjdG9Ac2FsdWR0ZWNoLmNvbTwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPHAgY2xhc3M9XFxcImNvcHlyaWdodFxcXCI+VG9kb3MgbG9zIGRlcmVjaG9zIHJlc2VydmFkb3M8L3A+XFxuPC9mb290ZXI+XFxuXFxuPC90ZW1wbGF0ZT5cXG48c3R5bGU+XFxuXFxuXFxuZm9vdGVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYXp1bCk7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcGFkZGluZy10b3A6IDEwcHg7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmZvb3RlciAuY29udGVuZWRvcj5kaXYge1xcbiAgICBjb2xvcjogI2ZmZmZmZjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuXFxuZm9vdGVyIGgzIHtcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgIGZvbnQtZmFtaWx5OiAnT3N3YWxkJywgc2Fucy1zZXJpZjtcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcbn1cXG5cXG5wLmNvcHlyaWdodCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWF6dWwpO1xcbiAgICBjb2xvcjogI2ZmZmZmZjtcXG4gICAgcGFkZGluZzogMTBweCAwO1xcbiAgICBtYXJnaW46IDEwcHggMCAwIDA7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///10\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\nexports.i(__webpack_require__(27), \"\");\\n\\n// module\\nexports.push([module.i, \"\\\\ndiv.barra {\\\\r\\\\n  padding: 10px;\\\\r\\\\n  background-color: var(--azul);\\\\n}\\\\n.brand{\\\\r\\\\n  margin: 0;\\\\n}\\\\n.fixed {\\\\r\\\\n  position: fixed;\\\\r\\\\n  width: 100%;\\\\r\\\\n  top: 0;\\\\r\\\\n  left: 0;\\\\r\\\\n  z-index: 2;\\\\n}\\\\ndiv.logo {\\\\r\\\\n  float: left;\\\\r\\\\n  padding-left: 10px;\\\\n}\\\\ndiv.logo a{\\\\r\\\\n  color: var(--claro);\\\\r\\\\n  font-size: 1.5em;\\\\r\\\\n  text-decoration: none;\\\\n}\\\\ndiv.logo img {\\\\r\\\\n  width: 30px;\\\\n}\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n/** Nav principal **/\\\\nnav.navegacion-principal {\\\\r\\\\n  display: none;\\\\r\\\\n  width: 100%;\\\\n}\\\\nnav.navegacion-principal a {\\\\r\\\\n  font-family: \\\\\"Oswald\\\\\", sans-serif;\\\\r\\\\n  color: #ffffff;\\\\r\\\\n  font-size: 0.8em;\\\\r\\\\n  text-decoration: none;\\\\r\\\\n  transition: all 0.6s ease;\\\\r\\\\n  width: 100%;\\\\r\\\\n  display: block;\\\\r\\\\n  text-align: center;\\\\r\\\\n  clear: both;\\\\n}\\\\nnav.navegacion-principal a:hover {\\\\r\\\\n  background-color: var(--piel);\\\\n}\\\\nnav.navegacion-principal a:last-child {\\\\r\\\\n  font-weight: bold;\\\\n}\\\\nnav.navegacion-principal a:last-child:hover {\\\\r\\\\n  color: #ffffff;\\\\n}\\\\n@media only screen and (min-width: 768px) {\\\\nnav.navegacion-principal {\\\\r\\\\n    width: 67%;\\\\r\\\\n    float: right;\\\\r\\\\n    text-align: right;\\\\r\\\\n    display: block;\\\\n}\\\\nnav.navegacion-principal a {\\\\r\\\\n    padding: 10px 10px;\\\\r\\\\n    display: inline-block;\\\\r\\\\n    width: auto;\\\\r\\\\n    display: inline-block;\\\\r\\\\n    text-align: center;\\\\r\\\\n    margin: 0 10px 0 0;\\\\n}\\\\n}\\\\ndiv.menu-movil {\\\\r\\\\n  width: 60px;\\\\r\\\\n  display: block;\\\\r\\\\n  float: right;\\\\r\\\\n  text-align: right;\\\\r\\\\n  margin-top: 12px;\\\\n}\\\\ndiv.menu-movil:hover {\\\\r\\\\n  cursor: pointer;\\\\n}\\\\n@media only screen and (min-width: 768px) {\\\\ndiv.menu-movil {\\\\r\\\\n    display: none;\\\\n}\\\\n}\\\\ndiv.menu-movil span {\\\\r\\\\n  height: 8px;\\\\r\\\\n  margin-bottom: 6px;\\\\r\\\\n  background-color: white;\\\\r\\\\n  display: block;\\\\n}\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/components/layout/src/components/layout/Header.vue\"],\"names\":[],\"mappings\":\";AAoDA;EACA,cAAA;EACA,8BAAA;CACA;AACA;EACA,UAAA;CACA;AACA;EACA,gBAAA;EACA,YAAA;EACA,OAAA;EACA,QAAA;EACA,WAAA;CACA;AAEA;EACA,YAAA;EACA,mBAAA;CACA;AAEA;EACA,oBAAA;EACA,iBAAA;EACA,sBAAA;CACA;AAEA;EACA,YAAA;CACA;;;AAGA,qBAAA;AAEA;EACA,cAAA;EACA,YAAA;CACA;AAEA;EACA,kCAAA;EACA,eAAA;EACA,iBAAA;EACA,sBAAA;EACA,0BAAA;EACA,YAAA;EACA,eAAA;EACA,mBAAA;EACA,YAAA;CACA;AAEA;EACA,8BAAA;CACA;AAEA;EACA,kBAAA;CACA;AAEA;EACA,eAAA;CACA;AAEA;AACA;IACA,WAAA;IACA,aAAA;IACA,kBAAA;IACA,eAAA;CACA;AACA;IACA,mBAAA;IACA,sBAAA;IACA,YAAA;IACA,sBAAA;IACA,mBAAA;IACA,mBAAA;CACA;CACA;AAEA;EACA,YAAA;EACA,eAAA;EACA,aAAA;EACA,kBAAA;EACA,iBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;AACA;IACA,cAAA;CACA;CACA;AAEA;EACA,YAAA;EACA,mBAAA;EACA,wBAAA;EACA,eAAA;CACA\",\"file\":\"Header.vue\",\"sourcesContent\":[\"<template>\\\\r\\\\n  <div>\\\\r\\\\n    <div class=\\\\\"barra fixed\\\\\">\\\\r\\\\n      <div class=\\\\\"logo\\\\\">\\\\r\\\\n        <router-link to=\\\\\"/\\\\\">SaludTech</router-link>\\\\r\\\\n      </div>\\\\r\\\\n      <nav class=\\\\\"navegacion-principal\\\\\">\\\\r\\\\n        <router-link to=\\\\\"about\\\\\">Quienes somos</router-link>\\\\r\\\\n        <router-link v-if=\\\\\"authenticated\\\\\" to=\\\\\"/\\\\\" v-on:click.native=\\\\\"logout()\\\\\" replace>Salir</router-link>\\\\r\\\\n        <router-link v-if=\\\\\"!authenticated\\\\\" to=\\\\\"login\\\\\">Iniciar sesion</router-link>\\\\r\\\\n        <button v-on:click=\\\\\"estado\\\\\">probar</button>\\\\r\\\\n      </nav>\\\\r\\\\n    </div>\\\\r\\\\n    <router-view @authenticated=\\\\\"setAuthenticated\\\\\" />\\\\r\\\\n  </div>\\\\r\\\\n</template>\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n<script>\\\\r\\\\n   export default {\\\\r\\\\n        data() {\\\\r\\\\n            return {\\\\r\\\\n                authenticated: false,\\\\r\\\\n                mockAccount: {\\\\r\\\\n                    username: \\\\\"marbel\\\\\",\\\\r\\\\n                    password: \\\\\"mm\\\\\"\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n        },\\\\r\\\\n\\\\r\\\\n        methods: {\\\\r\\\\n            setAuthenticated(status) {\\\\r\\\\n                this.authenticated = status;\\\\r\\\\n                this.$emit(\\\\\"authenticated\\\\\", status);\\\\r\\\\n                console.log(this.authenticated)\\\\r\\\\n            },\\\\r\\\\n            logout() {\\\\r\\\\n\\\\r\\\\n                  this.authenticated = false;\\\\r\\\\n                 this.$router.replace({ name: \\\\\"search\\\\\" });\\\\r\\\\n                 console.log(this.authenticated)\\\\r\\\\n\\\\r\\\\n            },\\\\r\\\\n            estado(){\\\\r\\\\n              console.log(\\\\\"el estado es\\\\\")\\\\r\\\\n              console.log(this.authenticated)\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n<\\/script>\\\\r\\\\n<style>\\\\r\\\\n@import \\'../../assets/styles.css\\';\\\\r\\\\ndiv.barra {\\\\r\\\\n  padding: 10px;\\\\r\\\\n  background-color: var(--azul);\\\\r\\\\n}\\\\r\\\\n.brand{\\\\r\\\\n  margin: 0;\\\\r\\\\n}\\\\r\\\\n.fixed {\\\\r\\\\n  position: fixed;\\\\r\\\\n  width: 100%;\\\\r\\\\n  top: 0;\\\\r\\\\n  left: 0;\\\\r\\\\n  z-index: 2;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.logo {\\\\r\\\\n  float: left;\\\\r\\\\n  padding-left: 10px;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.logo a{\\\\r\\\\n  color: var(--claro);\\\\r\\\\n  font-size: 1.5em;\\\\r\\\\n  text-decoration: none;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.logo img {\\\\r\\\\n  width: 30px;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n/** Nav principal **/\\\\r\\\\n\\\\r\\\\nnav.navegacion-principal {\\\\r\\\\n  display: none;\\\\r\\\\n  width: 100%;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nnav.navegacion-principal a {\\\\r\\\\n  font-family: \\\\\"Oswald\\\\\", sans-serif;\\\\r\\\\n  color: #ffffff;\\\\r\\\\n  font-size: 0.8em;\\\\r\\\\n  text-decoration: none;\\\\r\\\\n  transition: all 0.6s ease;\\\\r\\\\n  width: 100%;\\\\r\\\\n  display: block;\\\\r\\\\n  text-align: center;\\\\r\\\\n  clear: both;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nnav.navegacion-principal a:hover {\\\\r\\\\n  background-color: var(--piel);\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nnav.navegacion-principal a:last-child {\\\\r\\\\n  font-weight: bold;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nnav.navegacion-principal a:last-child:hover {\\\\r\\\\n  color: #ffffff;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n@media only screen and (min-width: 768px) {\\\\r\\\\n  nav.navegacion-principal {\\\\r\\\\n    width: 67%;\\\\r\\\\n    float: right;\\\\r\\\\n    text-align: right;\\\\r\\\\n    display: block;\\\\r\\\\n  }\\\\r\\\\n  nav.navegacion-principal a {\\\\r\\\\n    padding: 10px 10px;\\\\r\\\\n    display: inline-block;\\\\r\\\\n    width: auto;\\\\r\\\\n    display: inline-block;\\\\r\\\\n    text-align: center;\\\\r\\\\n    margin: 0 10px 0 0;\\\\r\\\\n  }\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.menu-movil {\\\\r\\\\n  width: 60px;\\\\r\\\\n  display: block;\\\\r\\\\n  float: right;\\\\r\\\\n  text-align: right;\\\\r\\\\n  margin-top: 12px;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.menu-movil:hover {\\\\r\\\\n  cursor: pointer;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n@media only screen and (min-width: 768px) {\\\\r\\\\n  div.menu-movil {\\\\r\\\\n    display: none;\\\\r\\\\n  }\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.menu-movil span {\\\\r\\\\n  height: 8px;\\\\r\\\\n  margin-bottom: 6px;\\\\r\\\\n  background-color: white;\\\\r\\\\n  display: block;\\\\r\\\\n}\\\\r\\\\n</style>\\\\r\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvSGVhZGVyLnZ1ZT9mMGFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQWtEO0FBQ3JGO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLEVBQStFOztBQUVqRztBQUNBLGNBQWMsUUFBUyxnQkFBZ0Isb0JBQW9CLG9DQUFvQyxHQUFHLFNBQVMsZ0JBQWdCLEdBQUcsVUFBVSxzQkFBc0Isa0JBQWtCLGFBQWEsY0FBYyxpQkFBaUIsR0FBRyxZQUFZLGtCQUFrQix5QkFBeUIsR0FBRyxhQUFhLDBCQUEwQix1QkFBdUIsNEJBQTRCLEdBQUcsZ0JBQWdCLGtCQUFrQixHQUFHLDZEQUE2RCxvQkFBb0Isa0JBQWtCLEdBQUcsOEJBQThCLDBDQUEwQyxxQkFBcUIsdUJBQXVCLDRCQUE0QixnQ0FBZ0Msa0JBQWtCLHFCQUFxQix5QkFBeUIsa0JBQWtCLEdBQUcsb0NBQW9DLG9DQUFvQyxHQUFHLHlDQUF5Qyx3QkFBd0IsR0FBRywrQ0FBK0MscUJBQXFCLEdBQUcsNkNBQTZDLDRCQUE0QixtQkFBbUIscUJBQXFCLDBCQUEwQix1QkFBdUIsR0FBRyw4QkFBOEIsMkJBQTJCLDhCQUE4QixvQkFBb0IsOEJBQThCLDJCQUEyQiwyQkFBMkIsR0FBRyxHQUFHLGtCQUFrQixrQkFBa0IscUJBQXFCLG1CQUFtQix3QkFBd0IsdUJBQXVCLEdBQUcsd0JBQXdCLHNCQUFzQixHQUFHLDZDQUE2QyxrQkFBa0Isc0JBQXNCLEdBQUcsR0FBRyx1QkFBdUIsa0JBQWtCLHlCQUF5Qiw4QkFBOEIscUJBQXFCLEdBQUcsWUFBWSxvSkFBb0osTUFBTSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSxPQUFPLFdBQVcsS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsV0FBVyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxLQUFLLFVBQVUsV0FBVyxXQUFXLFVBQVUsZ3VCQUFndUIsb0JBQW9CLHdCQUF3QiwyRUFBMkUsMEdBQTBHLGlCQUFpQixhQUFhLDJCQUEyQiwwQ0FBMEMsZ0RBQWdELDBEQUEwRCxvRUFBb0UsMkJBQTJCLHFEQUFxRCwyQ0FBMkMsbUJBQW1CLEVBQUUseUVBQXlFLDBCQUEwQixpSEFBaUgsYUFBYSxTQUFTLDhEQUE4RCxlQUFlLG9CQUFvQixvQ0FBb0MsS0FBSyxXQUFXLGdCQUFnQixLQUFLLFlBQVksc0JBQXNCLGtCQUFrQixhQUFhLGNBQWMsaUJBQWlCLEtBQUssa0JBQWtCLGtCQUFrQix5QkFBeUIsS0FBSyxtQkFBbUIsMEJBQTBCLHVCQUF1Qiw0QkFBNEIsS0FBSyxzQkFBc0Isa0JBQWtCLEtBQUssbUVBQW1FLG9CQUFvQixrQkFBa0IsS0FBSyxvQ0FBb0MsMENBQTBDLHFCQUFxQix1QkFBdUIsNEJBQTRCLGdDQUFnQyxrQkFBa0IscUJBQXFCLHlCQUF5QixrQkFBa0IsS0FBSywwQ0FBMEMsb0NBQW9DLEtBQUssK0NBQStDLHdCQUF3QixLQUFLLHFEQUFxRCxxQkFBcUIsS0FBSyxtREFBbUQsZ0NBQWdDLG1CQUFtQixxQkFBcUIsMEJBQTBCLHVCQUF1QixPQUFPLGtDQUFrQywyQkFBMkIsOEJBQThCLG9CQUFvQiw4QkFBOEIsMkJBQTJCLDJCQUEyQixPQUFPLEtBQUssd0JBQXdCLGtCQUFrQixxQkFBcUIsbUJBQW1CLHdCQUF3Qix1QkFBdUIsS0FBSyw4QkFBOEIsc0JBQXNCLEtBQUssbURBQW1ELHNCQUFzQixzQkFBc0IsT0FBTyxLQUFLLDZCQUE2QixrQkFBa0IseUJBQXlCLDhCQUE4QixxQkFBcUIsS0FBSyxtQ0FBbUM7O0FBRXhoTSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL2Fzc2V0cy9zdHlsZXMuY3NzXCIpLCBcIlwiKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5kaXYuYmFycmEge1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWF6dWwpO1xcbn1cXG4uYnJhbmR7XFxyXFxuICBtYXJnaW46IDA7XFxufVxcbi5maXhlZCB7XFxyXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHRvcDogMDtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICB6LWluZGV4OiAyO1xcbn1cXG5kaXYubG9nbyB7XFxyXFxuICBmbG9hdDogbGVmdDtcXHJcXG4gIHBhZGRpbmctbGVmdDogMTBweDtcXG59XFxuZGl2LmxvZ28gYXtcXHJcXG4gIGNvbG9yOiB2YXIoLS1jbGFybyk7XFxyXFxuICBmb250LXNpemU6IDEuNWVtO1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5kaXYubG9nbyBpbWcge1xcclxcbiAgd2lkdGg6IDMwcHg7XFxufVxcclxcblxcclxcblxcclxcbi8qKiBOYXYgcHJpbmNpcGFsICoqL1xcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxufVxcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCBhIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiBcXFwiT3N3YWxkXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG4gIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgZm9udC1zaXplOiAwLjhlbTtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAwLjZzIGVhc2U7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgY2xlYXI6IGJvdGg7XFxufVxcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCBhOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBpZWwpO1xcbn1cXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYTpsYXN0LWNoaWxkIHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYTpsYXN0LWNoaWxkOmhvdmVyIHtcXHJcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbn1cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxubmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIHtcXHJcXG4gICAgd2lkdGg6IDY3JTtcXHJcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcclxcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxufVxcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCBhIHtcXHJcXG4gICAgcGFkZGluZzogMTBweCAxMHB4O1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIHdpZHRoOiBhdXRvO1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgbWFyZ2luOiAwIDEwcHggMCAwO1xcbn1cXG59XFxuZGl2Lm1lbnUtbW92aWwge1xcclxcbiAgd2lkdGg6IDYwcHg7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZsb2F0OiByaWdodDtcXHJcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcclxcbiAgbWFyZ2luLXRvcDogMTJweDtcXG59XFxuZGl2Lm1lbnUtbW92aWw6aG92ZXIge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuZGl2Lm1lbnUtbW92aWwge1xcclxcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG59XFxuZGl2Lm1lbnUtbW92aWwgc3BhbiB7XFxyXFxuICBoZWlnaHQ6IDhweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDZweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9LZWluZXIvRHJvcGJveC9VTklOT1JURS9zYWx1ZHRlY2gvc3JjL2NvbXBvbmVudHMvbGF5b3V0L3NyYy9jb21wb25lbnRzL2xheW91dC9IZWFkZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFvREE7RUFDQSxjQUFBO0VBQ0EsOEJBQUE7Q0FDQTtBQUNBO0VBQ0EsVUFBQTtDQUNBO0FBQ0E7RUFDQSxnQkFBQTtFQUNBLFlBQUE7RUFDQSxPQUFBO0VBQ0EsUUFBQTtFQUNBLFdBQUE7Q0FDQTtBQUVBO0VBQ0EsWUFBQTtFQUNBLG1CQUFBO0NBQ0E7QUFFQTtFQUNBLG9CQUFBO0VBQ0EsaUJBQUE7RUFDQSxzQkFBQTtDQUNBO0FBRUE7RUFDQSxZQUFBO0NBQ0E7OztBQUdBLHFCQUFBO0FBRUE7RUFDQSxjQUFBO0VBQ0EsWUFBQTtDQUNBO0FBRUE7RUFDQSxrQ0FBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLHNCQUFBO0VBQ0EsMEJBQUE7RUFDQSxZQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0VBQ0EsWUFBQTtDQUNBO0FBRUE7RUFDQSw4QkFBQTtDQUNBO0FBRUE7RUFDQSxrQkFBQTtDQUNBO0FBRUE7RUFDQSxlQUFBO0NBQ0E7QUFFQTtBQUNBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSxrQkFBQTtJQUNBLGVBQUE7Q0FDQTtBQUNBO0lBQ0EsbUJBQUE7SUFDQSxzQkFBQTtJQUNBLFlBQUE7SUFDQSxzQkFBQTtJQUNBLG1CQUFBO0lBQ0EsbUJBQUE7Q0FDQTtDQUNBO0FBRUE7RUFDQSxZQUFBO0VBQ0EsZUFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFFQTtFQUNBLGdCQUFBO0NBQ0E7QUFFQTtBQUNBO0lBQ0EsY0FBQTtDQUNBO0NBQ0E7QUFFQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtFQUNBLHdCQUFBO0VBQ0EsZUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJIZWFkZXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gIDxkaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJhcnJhIGZpeGVkXFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dvXFxcIj5cXHJcXG4gICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL1xcXCI+U2FsdWRUZWNoPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgICA8bmF2IGNsYXNzPVxcXCJuYXZlZ2FjaW9uLXByaW5jaXBhbFxcXCI+XFxyXFxuICAgICAgICA8cm91dGVyLWxpbmsgdG89XFxcImFib3V0XFxcIj5RdWllbmVzIHNvbW9zPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgICAgIDxyb3V0ZXItbGluayB2LWlmPVxcXCJhdXRoZW50aWNhdGVkXFxcIiB0bz1cXFwiL1xcXCIgdi1vbjpjbGljay5uYXRpdmU9XFxcImxvZ291dCgpXFxcIiByZXBsYWNlPlNhbGlyPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgICAgIDxyb3V0ZXItbGluayB2LWlmPVxcXCIhYXV0aGVudGljYXRlZFxcXCIgdG89XFxcImxvZ2luXFxcIj5JbmljaWFyIHNlc2lvbjwvcm91dGVyLWxpbms+XFxyXFxuICAgICAgICA8YnV0dG9uIHYtb246Y2xpY2s9XFxcImVzdGFkb1xcXCI+cHJvYmFyPC9idXR0b24+XFxyXFxuICAgICAgPC9uYXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8cm91dGVyLXZpZXcgQGF1dGhlbnRpY2F0ZWQ9XFxcInNldEF1dGhlbnRpY2F0ZWRcXFwiIC8+XFxyXFxuICA8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcblxcclxcblxcclxcbjxzY3JpcHQ+XFxyXFxuICAgZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICAgICAgZGF0YSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcXHJcXG4gICAgICAgICAgICAgICAgbW9ja0FjY291bnQ6IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBcXFwibWFyYmVsXFxcIixcXHJcXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBcXFwibW1cXFwiXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcblxcclxcbiAgICAgICAgbWV0aG9kczoge1xcclxcbiAgICAgICAgICAgIHNldEF1dGhlbnRpY2F0ZWQoc3RhdHVzKSB7XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHN0YXR1cztcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdChcXFwiYXV0aGVudGljYXRlZFxcXCIsIHN0YXR1cyk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXV0aGVudGljYXRlZClcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGxvZ291dCgpIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5yZXBsYWNlKHsgbmFtZTogXFxcInNlYXJjaFxcXCIgfSk7XFxyXFxuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF1dGhlbnRpY2F0ZWQpXFxyXFxuXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBlc3RhZG8oKXtcXHJcXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJlbCBlc3RhZG8gZXNcXFwiKVxcclxcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdXRoZW50aWNhdGVkKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5AaW1wb3J0ICcuLi8uLi9hc3NldHMvc3R5bGVzLmNzcyc7XFxyXFxuZGl2LmJhcnJhIHtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1henVsKTtcXHJcXG59XFxyXFxuLmJyYW5ke1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4uZml4ZWQge1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgei1pbmRleDogMjtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmxvZ28ge1xcclxcbiAgZmxvYXQ6IGxlZnQ7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5sb2dvIGF7XFxyXFxuICBjb2xvcjogdmFyKC0tY2xhcm8pO1xcclxcbiAgZm9udC1zaXplOiAxLjVlbTtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmxvZ28gaW1nIHtcXHJcXG4gIHdpZHRoOiAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4vKiogTmF2IHByaW5jaXBhbCAqKi9cXHJcXG5cXHJcXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYSB7XFxyXFxuICBmb250LWZhbWlseTogXFxcIk9zd2FsZFxcXCIsIHNhbnMtc2VyaWY7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMC44ZW07XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICB0cmFuc2l0aW9uOiBhbGwgMC42cyBlYXNlO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGNsZWFyOiBib3RoO1xcclxcbn1cXHJcXG5cXHJcXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1waWVsKTtcXHJcXG59XFxyXFxuXFxyXFxubmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIGE6bGFzdC1jaGlsZCB7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuXFxyXFxubmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIGE6bGFzdC1jaGlsZDpob3ZlciB7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcclxcbiAgbmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIHtcXHJcXG4gICAgd2lkdGg6IDY3JTtcXHJcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcclxcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICB9XFxyXFxuICBuYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYSB7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHggMTBweDtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICB3aWR0aDogYXV0bztcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIG1hcmdpbjogMCAxMHB4IDAgMDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuZGl2Lm1lbnUtbW92aWwge1xcclxcbiAgd2lkdGg6IDYwcHg7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZsb2F0OiByaWdodDtcXHJcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcclxcbiAgbWFyZ2luLXRvcDogMTJweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2Lm1lbnUtbW92aWw6aG92ZXIge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuICBkaXYubWVudS1tb3ZpbCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbmRpdi5tZW51LW1vdmlsIHNwYW4ge1xcclxcbiAgaGVpZ2h0OiA4cHg7XFxyXFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///11\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\nexports.i(__webpack_require__(27), \"\");\\n\\n// module\\nexports.push([module.i, \"\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"App.vue\",\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8wNWNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQTRDO0FBQy9FO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLEVBQXFFOztBQUV2RjtBQUNBLGNBQWMsUUFBUyxlQUFlLG1GQUFtRjs7QUFFekgiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5pKHJlcXVpcmUoXCItIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2Fzc2V0cy9zdHlsZXMuY3NzXCIpLCBcIlwiKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W10sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIlwiLFwiZmlsZVwiOlwiQXBwLnZ1ZVwiLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///12\\n')},function(module,exports){eval('var logLevel = \"info\";\\r\\n\\r\\nfunction dummy() {}\\r\\n\\r\\nfunction shouldLog(level) {\\r\\n\\tvar shouldLog =\\r\\n\\t\\t(logLevel === \"info\" && level === \"info\") ||\\r\\n\\t\\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\\r\\n\\t\\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\\r\\n\\treturn shouldLog;\\r\\n}\\r\\n\\r\\nfunction logGroup(logFn) {\\r\\n\\treturn function(level, msg) {\\r\\n\\t\\tif (shouldLog(level)) {\\r\\n\\t\\t\\tlogFn(msg);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\\r\\nmodule.exports = function(level, msg) {\\r\\n\\tif (shouldLog(level)) {\\r\\n\\t\\tif (level === \"info\") {\\r\\n\\t\\t\\tconsole.log(msg);\\r\\n\\t\\t} else if (level === \"warning\") {\\r\\n\\t\\t\\tconsole.warn(msg);\\r\\n\\t\\t} else if (level === \"error\") {\\r\\n\\t\\t\\tconsole.error(msg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\nvar group = console.group || dummy;\\r\\nvar groupCollapsed = console.groupCollapsed || dummy;\\r\\nvar groupEnd = console.groupEnd || dummy;\\r\\n\\r\\nmodule.exports.group = logGroup(group);\\r\\n\\r\\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\\r\\n\\r\\nmodule.exports.groupEnd = logGroup(groupEnd);\\r\\n\\r\\nmodule.exports.setLogLevel = function(level) {\\r\\n\\tlogLevel = level;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanM/MWFmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XHJcblxyXG5mdW5jdGlvbiBkdW1teSgpIHt9XHJcblxyXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcclxuXHR2YXIgc2hvdWxkTG9nID1cclxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxyXG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxyXG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcclxuXHRyZXR1cm4gc2hvdWxkTG9nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xyXG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XHJcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xyXG5cdFx0XHRsb2dGbihtc2cpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xyXG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XHJcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XHJcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcclxuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcclxudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcclxudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcclxuXHRsb2dMZXZlbCA9IGxldmVsO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///13\\n')},function(module,exports,__webpack_require__){eval(\"var EventEmitter = __webpack_require__(32);\\r\\nmodule.exports = new EventEmitter();\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzP2E2YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLG1CQUFPLENBQUMsRUFBUTtBQUNuQyIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///14\\n\")},function(module,exports){eval(\"var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];\\r\\n\\r\\nvar alphaIndex = {};\\r\\nvar charIndex = {};\\r\\n\\r\\ncreateIndexes(alphaIndex, charIndex);\\r\\n\\r\\n/**\\r\\n * @constructor\\r\\n */\\r\\nfunction Html5Entities() {}\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml5Entities.prototype.decode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    return str.replace(/&(#?[\\\\w\\\\d]+);?/g, function(s, entity) {\\r\\n        var chr;\\r\\n        if (entity.charAt(0) === \\\"#\\\") {\\r\\n            var code = entity.charAt(1) === 'x' ?\\r\\n                parseInt(entity.substr(2).toLowerCase(), 16) :\\r\\n                parseInt(entity.substr(1));\\r\\n\\r\\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\\r\\n                chr = String.fromCharCode(code);\\r\\n            }\\r\\n        } else {\\r\\n            chr = alphaIndex[entity];\\r\\n        }\\r\\n        return chr || s;\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n Html5Entities.decode = function(str) {\\r\\n    return new Html5Entities().decode(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml5Entities.prototype.encode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var charInfo = charIndex[str.charCodeAt(i)];\\r\\n        if (charInfo) {\\r\\n            var alpha = charInfo[str.charCodeAt(i + 1)];\\r\\n            if (alpha) {\\r\\n                i++;\\r\\n            } else {\\r\\n                alpha = charInfo[''];\\r\\n            }\\r\\n            if (alpha) {\\r\\n                result += \\\"&\\\" + alpha + \\\";\\\";\\r\\n                i++;\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n        result += str.charAt(i);\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n Html5Entities.encode = function(str) {\\r\\n    return new Html5Entities().encode(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml5Entities.prototype.encodeNonUTF = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var c = str.charCodeAt(i);\\r\\n        var charInfo = charIndex[c];\\r\\n        if (charInfo) {\\r\\n            var alpha = charInfo[str.charCodeAt(i + 1)];\\r\\n            if (alpha) {\\r\\n                i++;\\r\\n            } else {\\r\\n                alpha = charInfo[''];\\r\\n            }\\r\\n            if (alpha) {\\r\\n                result += \\\"&\\\" + alpha + \\\";\\\";\\r\\n                i++;\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n        if (c < 32 || c > 126) {\\r\\n            result += '&#' + c + ';';\\r\\n        } else {\\r\\n            result += str.charAt(i);\\r\\n        }\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n Html5Entities.encodeNonUTF = function(str) {\\r\\n    return new Html5Entities().encodeNonUTF(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml5Entities.prototype.encodeNonASCII = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var c = str.charCodeAt(i);\\r\\n        if (c <= 255) {\\r\\n            result += str[i++];\\r\\n            continue;\\r\\n        }\\r\\n        result += '&#' + c + ';';\\r\\n        i++\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n Html5Entities.encodeNonASCII = function(str) {\\r\\n    return new Html5Entities().encodeNonASCII(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {Object} alphaIndex Passed by reference.\\r\\n * @param {Object} charIndex Passed by reference.\\r\\n */\\r\\nfunction createIndexes(alphaIndex, charIndex) {\\r\\n    var i = ENTITIES.length;\\r\\n    var _results = [];\\r\\n    while (i--) {\\r\\n        var e = ENTITIES[i];\\r\\n        var alpha = e[0];\\r\\n        var chars = e[1];\\r\\n        var chr = chars[0];\\r\\n        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;\\r\\n        var charInfo;\\r\\n        if (addChar) {\\r\\n            charInfo = charIndex[chr] = charIndex[chr] || {};\\r\\n        }\\r\\n        if (chars[1]) {\\r\\n            var chr2 = chars[1];\\r\\n            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);\\r\\n            _results.push(addChar && (charInfo[chr2] = alpha));\\r\\n        } else {\\r\\n            alphaIndex[alpha] = String.fromCharCode(chr);\\r\\n            _results.push(addChar && (charInfo[''] = alpha));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nmodule.exports = Html5Entities;\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanM/MTdmZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XHJcblxyXG52YXIgYWxwaGFJbmRleCA9IHt9O1xyXG52YXIgY2hhckluZGV4ID0ge307XHJcblxyXG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xyXG4gICAgICAgIHZhciBjaHI7XHJcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cclxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcclxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XHJcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG4gSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xyXG4gfTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XHJcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XHJcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xyXG4gfTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xyXG4gICAgICAgIGlmIChjaGFySW5mbykge1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xyXG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcclxuIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcclxuICAgICAgICBpKytcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XHJcbiB9O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XHJcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcclxuICAgIHZhciBfcmVzdWx0cyA9IFtdO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XHJcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcclxuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xyXG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcclxuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcclxuICAgICAgICB2YXIgY2hhckluZm87XHJcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcclxuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcclxuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcclxuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xyXG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcclxuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///15\\n\")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\r\\\\n\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"Portfolio.vue\",\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW8udnVlPzI4YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBK0M7QUFDbEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLGlFQUFpRSx5RkFBeUY7O0FBRWpMIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcclxcblxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJQb3J0Zm9saW8udnVlXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///16\\n')},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(5);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"73860bca\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(5, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(5);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TaWdudXAudnVlPzNlNDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsQ0FBOFI7QUFDcFQsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUE2RDtBQUMvRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLElBQVU7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLENBQThSLEVBQUU7QUFDclQsc0JBQXNCLG1CQUFPLENBQUMsQ0FBOFI7QUFDNVQsdURBQXVELFFBQVM7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWMxNzlmNWIwXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2lnbnVwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI3Mzg2MGJjYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWMxNzlmNWIwXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2lnbnVwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYzE3OWY1YjBcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TaWdudXAudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///17\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(6);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"66852d36\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(6, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(6);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TZWN1cmUudnVlP2VmNmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsQ0FBOFI7QUFDcFQsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUE2RDtBQUMvRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLElBQVU7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLENBQThSLEVBQUU7QUFDclQsc0JBQXNCLG1CQUFPLENBQUMsQ0FBOFI7QUFDNVQsdURBQXVELFFBQVM7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFiM2VhODA3XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2VjdXJlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI2Njg1MmQzNlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFiM2VhODA3XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2VjdXJlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWIzZWE4MDdcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TZWN1cmUudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///18\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(7);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"02cdaa81\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(7, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(7);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Mb2dpbi52dWU/YTRiZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxDQUE2UjtBQUNuVCw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQTZEO0FBQy9FLCtDQUErQztBQUMvQztBQUNBLEdBQUcsSUFBVTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsQ0FBNlIsRUFBRTtBQUNwVCxzQkFBc0IsbUJBQU8sQ0FBQyxDQUE2UjtBQUMzVCx1REFBdUQsUUFBUztBQUNoRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWZjZmVkZWVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Mb2dpbi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMDJjZGFhODFcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi05ZmNmZWRlZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0xvZ2luLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWZjZmVkZWVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Mb2dpbi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///19\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(8);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"bb46979c\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(8, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(8);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BYm91dC52dWU/OTQ1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxDQUFtUTtBQUN6Uiw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQTZEO0FBQy9FLCtDQUErQztBQUMvQztBQUNBLEdBQUcsSUFBVTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsQ0FBbVEsRUFBRTtBQUMxUixzQkFBc0IsbUJBQU8sQ0FBQyxDQUFtUTtBQUNqUyx1REFBdUQsUUFBUztBQUNoRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0Fib3V0LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJiYjQ2OTc5Y1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BYm91dC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BYm91dC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///20\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(9);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"a778c62c\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(9, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(9);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TZWFyY2gudnVlPzVmMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsQ0FBb1E7QUFDMVIsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUE2RDtBQUMvRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLElBQVU7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLENBQW9RLEVBQUU7QUFDM1Isc0JBQXNCLG1CQUFPLENBQUMsQ0FBb1E7QUFDbFMsdURBQXVELFFBQVM7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TZWFyY2gudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcImE3NzhjNjJjXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1NlYXJjaC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TZWFyY2gudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///21\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(10);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"0333dee6\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(10, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(10);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvRm9vdGVyLnZ1ZT8zMjcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQTZRO0FBQ25TLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBZ0U7QUFDbEYsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxJQUFVO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixFQUE2USxFQUFFO0FBQ3BTLHNCQUFzQixtQkFBTyxDQUFDLEVBQTZRO0FBQzNTLHVEQUF1RCxRQUFTO0FBQ2hFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vRm9vdGVyLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIwMzMzZGVlNlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Gb290ZXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vRm9vdGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///22\\n\")},function(module,exports){eval(\"// shim for using process in browser\\r\\nvar process = module.exports = {};\\r\\n\\r\\n// cached from whatever global is present so that test runners that stub it\\r\\n// don't break things.  But we need to wrap it in a try catch in case it is\\r\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\r\\n// function because try/catches deoptimize in certain engines.\\r\\n\\r\\nvar cachedSetTimeout;\\r\\nvar cachedClearTimeout;\\r\\n\\r\\nfunction defaultSetTimout() {\\r\\n    throw new Error('setTimeout has not been defined');\\r\\n}\\r\\nfunction defaultClearTimeout () {\\r\\n    throw new Error('clearTimeout has not been defined');\\r\\n}\\r\\n(function () {\\r\\n    try {\\r\\n        if (typeof setTimeout === 'function') {\\r\\n            cachedSetTimeout = setTimeout;\\r\\n        } else {\\r\\n            cachedSetTimeout = defaultSetTimout;\\r\\n        }\\r\\n    } catch (e) {\\r\\n        cachedSetTimeout = defaultSetTimout;\\r\\n    }\\r\\n    try {\\r\\n        if (typeof clearTimeout === 'function') {\\r\\n            cachedClearTimeout = clearTimeout;\\r\\n        } else {\\r\\n            cachedClearTimeout = defaultClearTimeout;\\r\\n        }\\r\\n    } catch (e) {\\r\\n        cachedClearTimeout = defaultClearTimeout;\\r\\n    }\\r\\n} ())\\r\\nfunction runTimeout(fun) {\\r\\n    if (cachedSetTimeout === setTimeout) {\\r\\n        //normal enviroments in sane situations\\r\\n        return setTimeout(fun, 0);\\r\\n    }\\r\\n    // if setTimeout wasn't available but was latter defined\\r\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\r\\n        cachedSetTimeout = setTimeout;\\r\\n        return setTimeout(fun, 0);\\r\\n    }\\r\\n    try {\\r\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\r\\n        return cachedSetTimeout(fun, 0);\\r\\n    } catch(e){\\r\\n        try {\\r\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\r\\n            return cachedSetTimeout.call(null, fun, 0);\\r\\n        } catch(e){\\r\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\r\\n            return cachedSetTimeout.call(this, fun, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\nfunction runClearTimeout(marker) {\\r\\n    if (cachedClearTimeout === clearTimeout) {\\r\\n        //normal enviroments in sane situations\\r\\n        return clearTimeout(marker);\\r\\n    }\\r\\n    // if clearTimeout wasn't available but was latter defined\\r\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\r\\n        cachedClearTimeout = clearTimeout;\\r\\n        return clearTimeout(marker);\\r\\n    }\\r\\n    try {\\r\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\r\\n        return cachedClearTimeout(marker);\\r\\n    } catch (e){\\r\\n        try {\\r\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\r\\n            return cachedClearTimeout.call(null, marker);\\r\\n        } catch (e){\\r\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\r\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\r\\n            return cachedClearTimeout.call(this, marker);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n}\\r\\nvar queue = [];\\r\\nvar draining = false;\\r\\nvar currentQueue;\\r\\nvar queueIndex = -1;\\r\\n\\r\\nfunction cleanUpNextTick() {\\r\\n    if (!draining || !currentQueue) {\\r\\n        return;\\r\\n    }\\r\\n    draining = false;\\r\\n    if (currentQueue.length) {\\r\\n        queue = currentQueue.concat(queue);\\r\\n    } else {\\r\\n        queueIndex = -1;\\r\\n    }\\r\\n    if (queue.length) {\\r\\n        drainQueue();\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction drainQueue() {\\r\\n    if (draining) {\\r\\n        return;\\r\\n    }\\r\\n    var timeout = runTimeout(cleanUpNextTick);\\r\\n    draining = true;\\r\\n\\r\\n    var len = queue.length;\\r\\n    while(len) {\\r\\n        currentQueue = queue;\\r\\n        queue = [];\\r\\n        while (++queueIndex < len) {\\r\\n            if (currentQueue) {\\r\\n                currentQueue[queueIndex].run();\\r\\n            }\\r\\n        }\\r\\n        queueIndex = -1;\\r\\n        len = queue.length;\\r\\n    }\\r\\n    currentQueue = null;\\r\\n    draining = false;\\r\\n    runClearTimeout(timeout);\\r\\n}\\r\\n\\r\\nprocess.nextTick = function (fun) {\\r\\n    var args = new Array(arguments.length - 1);\\r\\n    if (arguments.length > 1) {\\r\\n        for (var i = 1; i < arguments.length; i++) {\\r\\n            args[i - 1] = arguments[i];\\r\\n        }\\r\\n    }\\r\\n    queue.push(new Item(fun, args));\\r\\n    if (queue.length === 1 && !draining) {\\r\\n        runTimeout(drainQueue);\\r\\n    }\\r\\n};\\r\\n\\r\\n// v8 likes predictible objects\\r\\nfunction Item(fun, array) {\\r\\n    this.fun = fun;\\r\\n    this.array = array;\\r\\n}\\r\\nItem.prototype.run = function () {\\r\\n    this.fun.apply(null, this.array);\\r\\n};\\r\\nprocess.title = 'browser';\\r\\nprocess.browser = true;\\r\\nprocess.env = {};\\r\\nprocess.argv = [];\\r\\nprocess.version = ''; // empty string to avoid regexp issues\\r\\nprocess.versions = {};\\r\\n\\r\\nfunction noop() {}\\r\\n\\r\\nprocess.on = noop;\\r\\nprocess.addListener = noop;\\r\\nprocess.once = noop;\\r\\nprocess.off = noop;\\r\\nprocess.removeListener = noop;\\r\\nprocess.removeAllListeners = noop;\\r\\nprocess.emit = noop;\\r\\nprocess.prependListener = noop;\\r\\nprocess.prependOnceListener = noop;\\r\\n\\r\\nprocess.listeners = function (name) { return [] }\\r\\n\\r\\nprocess.binding = function (name) {\\r\\n    throw new Error('process.binding is not supported');\\r\\n};\\r\\n\\r\\nprocess.cwd = function () { return '/' };\\r\\nprocess.chdir = function (dir) {\\r\\n    throw new Error('process.chdir is not supported');\\r\\n};\\r\\nprocess.umask = function() { return 0; };\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcclxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXHJcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcclxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cclxuXHJcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xyXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcclxufVxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcclxuICAgIH1cclxufSAoKSlcclxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcclxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXHJcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcclxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xyXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxyXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxyXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxufVxyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGRyYWluaW5nID0gZmFsc2U7XHJcbnZhciBjdXJyZW50UXVldWU7XHJcbnZhciBxdWV1ZUluZGV4ID0gLTE7XHJcblxyXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XHJcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xyXG4gICAgaWYgKGRyYWluaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XHJcbiAgICBkcmFpbmluZyA9IHRydWU7XHJcblxyXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIHdoaWxlKGxlbikge1xyXG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHF1ZXVlID0gW107XHJcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xyXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG59XHJcblxyXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xyXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XHJcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcclxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XHJcbiAgICB0aGlzLmZ1biA9IGZ1bjtcclxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxufVxyXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcclxufTtcclxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcclxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcclxucHJvY2Vzcy5lbnYgPSB7fTtcclxucHJvY2Vzcy5hcmd2ID0gW107XHJcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xyXG5wcm9jZXNzLnZlcnNpb25zID0ge307XHJcblxyXG5mdW5jdGlvbiBub29wKCkge31cclxuXHJcbnByb2Nlc3Mub24gPSBub29wO1xyXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5vbmNlID0gbm9vcDtcclxucHJvY2Vzcy5vZmYgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xyXG5wcm9jZXNzLmVtaXQgPSBub29wO1xyXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XHJcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XHJcblxyXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XHJcblxyXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG59O1xyXG5cclxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbn07XHJcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///23\\n\")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\\r\\n    \"use strict\";\\r\\n\\r\\n    if (global.setImmediate) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    var nextHandle = 1; // Spec says greater than zero\\r\\n    var tasksByHandle = {};\\r\\n    var currentlyRunningATask = false;\\r\\n    var doc = global.document;\\r\\n    var registerImmediate;\\r\\n\\r\\n    function setImmediate(callback) {\\r\\n      // Callback can either be a function or a string\\r\\n      if (typeof callback !== \"function\") {\\r\\n        callback = new Function(\"\" + callback);\\r\\n      }\\r\\n      // Copy function arguments\\r\\n      var args = new Array(arguments.length - 1);\\r\\n      for (var i = 0; i < args.length; i++) {\\r\\n          args[i] = arguments[i + 1];\\r\\n      }\\r\\n      // Store and register the task\\r\\n      var task = { callback: callback, args: args };\\r\\n      tasksByHandle[nextHandle] = task;\\r\\n      registerImmediate(nextHandle);\\r\\n      return nextHandle++;\\r\\n    }\\r\\n\\r\\n    function clearImmediate(handle) {\\r\\n        delete tasksByHandle[handle];\\r\\n    }\\r\\n\\r\\n    function run(task) {\\r\\n        var callback = task.callback;\\r\\n        var args = task.args;\\r\\n        switch (args.length) {\\r\\n        case 0:\\r\\n            callback();\\r\\n            break;\\r\\n        case 1:\\r\\n            callback(args[0]);\\r\\n            break;\\r\\n        case 2:\\r\\n            callback(args[0], args[1]);\\r\\n            break;\\r\\n        case 3:\\r\\n            callback(args[0], args[1], args[2]);\\r\\n            break;\\r\\n        default:\\r\\n            callback.apply(undefined, args);\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function runIfPresent(handle) {\\r\\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\\r\\n        // So if we\\'re currently running a task, we\\'ll need to delay this invocation.\\r\\n        if (currentlyRunningATask) {\\r\\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\\r\\n            // \"too much recursion\" error.\\r\\n            setTimeout(runIfPresent, 0, handle);\\r\\n        } else {\\r\\n            var task = tasksByHandle[handle];\\r\\n            if (task) {\\r\\n                currentlyRunningATask = true;\\r\\n                try {\\r\\n                    run(task);\\r\\n                } finally {\\r\\n                    clearImmediate(handle);\\r\\n                    currentlyRunningATask = false;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function installNextTickImplementation() {\\r\\n        registerImmediate = function(handle) {\\r\\n            process.nextTick(function () { runIfPresent(handle); });\\r\\n        };\\r\\n    }\\r\\n\\r\\n    function canUsePostMessage() {\\r\\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\\r\\n        // where `global.postMessage` means something completely different and can\\'t be used for this purpose.\\r\\n        if (global.postMessage && !global.importScripts) {\\r\\n            var postMessageIsAsynchronous = true;\\r\\n            var oldOnMessage = global.onmessage;\\r\\n            global.onmessage = function() {\\r\\n                postMessageIsAsynchronous = false;\\r\\n            };\\r\\n            global.postMessage(\"\", \"*\");\\r\\n            global.onmessage = oldOnMessage;\\r\\n            return postMessageIsAsynchronous;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function installPostMessageImplementation() {\\r\\n        // Installs an event handler on `global` for the `message` event: see\\r\\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\\r\\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\\r\\n\\r\\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\\r\\n        var onGlobalMessage = function(event) {\\r\\n            if (event.source === global &&\\r\\n                typeof event.data === \"string\" &&\\r\\n                event.data.indexOf(messagePrefix) === 0) {\\r\\n                runIfPresent(+event.data.slice(messagePrefix.length));\\r\\n            }\\r\\n        };\\r\\n\\r\\n        if (global.addEventListener) {\\r\\n            global.addEventListener(\"message\", onGlobalMessage, false);\\r\\n        } else {\\r\\n            global.attachEvent(\"onmessage\", onGlobalMessage);\\r\\n        }\\r\\n\\r\\n        registerImmediate = function(handle) {\\r\\n            global.postMessage(messagePrefix + handle, \"*\");\\r\\n        };\\r\\n    }\\r\\n\\r\\n    function installMessageChannelImplementation() {\\r\\n        var channel = new MessageChannel();\\r\\n        channel.port1.onmessage = function(event) {\\r\\n            var handle = event.data;\\r\\n            runIfPresent(handle);\\r\\n        };\\r\\n\\r\\n        registerImmediate = function(handle) {\\r\\n            channel.port2.postMessage(handle);\\r\\n        };\\r\\n    }\\r\\n\\r\\n    function installReadyStateChangeImplementation() {\\r\\n        var html = doc.documentElement;\\r\\n        registerImmediate = function(handle) {\\r\\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\\r\\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\\'s been called.\\r\\n            var script = doc.createElement(\"script\");\\r\\n            script.onreadystatechange = function () {\\r\\n                runIfPresent(handle);\\r\\n                script.onreadystatechange = null;\\r\\n                html.removeChild(script);\\r\\n                script = null;\\r\\n            };\\r\\n            html.appendChild(script);\\r\\n        };\\r\\n    }\\r\\n\\r\\n    function installSetTimeoutImplementation() {\\r\\n        registerImmediate = function(handle) {\\r\\n            setTimeout(runIfPresent, 0, handle);\\r\\n        };\\r\\n    }\\r\\n\\r\\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\\r\\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\\r\\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\\r\\n\\r\\n    // Don\\'t get fooled by e.g. browserify environments.\\r\\n    if ({}.toString.call(global.process) === \"[object process]\") {\\r\\n        // For Node.js before 0.9\\r\\n        installNextTickImplementation();\\r\\n\\r\\n    } else if (canUsePostMessage()) {\\r\\n        // For non-IE10 modern browsers\\r\\n        installPostMessageImplementation();\\r\\n\\r\\n    } else if (global.MessageChannel) {\\r\\n        // For web workers, where supported\\r\\n        installMessageChannelImplementation();\\r\\n\\r\\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\\r\\n        // For IE 68\\r\\n        installReadyStateChangeImplementation();\\r\\n\\r\\n    } else {\\r\\n        // For older browsers\\r\\n        installSetTimeoutImplementation();\\r\\n    }\\r\\n\\r\\n    attachTo.setImmediate = setImmediate;\\r\\n    attachTo.clearImmediate = clearImmediate;\\r\\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(23)))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXHJcbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xyXG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xyXG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcclxuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcclxuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXHJcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcclxuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xyXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XHJcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xyXG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcclxuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcclxuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcclxuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcclxuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xyXG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcclxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxyXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcclxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cclxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XHJcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XHJcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xyXG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcclxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cclxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xyXG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xyXG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XHJcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcclxuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcclxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcclxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXHJcblxyXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XHJcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcclxuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XHJcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcclxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcclxuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXHJcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXHJcbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXHJcbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XHJcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcclxuXHJcbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXHJcbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XHJcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxyXG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XHJcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xyXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcclxuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxyXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xyXG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxyXG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xyXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XHJcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xyXG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///24\\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\\r\\n            (typeof self !== \"undefined\" && self) ||\\r\\n            window;\\r\\nvar apply = Function.prototype.apply;\\r\\n\\r\\n// DOM APIs, for completeness\\r\\n\\r\\nexports.setTimeout = function() {\\r\\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\\r\\n};\\r\\nexports.setInterval = function() {\\r\\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\\r\\n};\\r\\nexports.clearTimeout =\\r\\nexports.clearInterval = function(timeout) {\\r\\n  if (timeout) {\\r\\n    timeout.close();\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction Timeout(id, clearFn) {\\r\\n  this._id = id;\\r\\n  this._clearFn = clearFn;\\r\\n}\\r\\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\\r\\nTimeout.prototype.close = function() {\\r\\n  this._clearFn.call(scope, this._id);\\r\\n};\\r\\n\\r\\n// Does not start the time, just sets up the members needed.\\r\\nexports.enroll = function(item, msecs) {\\r\\n  clearTimeout(item._idleTimeoutId);\\r\\n  item._idleTimeout = msecs;\\r\\n};\\r\\n\\r\\nexports.unenroll = function(item) {\\r\\n  clearTimeout(item._idleTimeoutId);\\r\\n  item._idleTimeout = -1;\\r\\n};\\r\\n\\r\\nexports._unrefActive = exports.active = function(item) {\\r\\n  clearTimeout(item._idleTimeoutId);\\r\\n\\r\\n  var msecs = item._idleTimeout;\\r\\n  if (msecs >= 0) {\\r\\n    item._idleTimeoutId = setTimeout(function onTimeout() {\\r\\n      if (item._onTimeout)\\r\\n        item._onTimeout();\\r\\n    }, msecs);\\r\\n  }\\r\\n};\\r\\n\\r\\n// setimmediate attaches itself to the global object\\r\\n__webpack_require__(24);\\r\\n// On some exotic environments, it\\'s not clear which object `setimmediate` was\\r\\n// able to install onto.  Search each possibility in the same order as the\\r\\n// `setimmediate` library.\\r\\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\\r\\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\\r\\n                       (this && this.setImmediate);\\r\\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\\r\\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\\r\\n                         (this && this.clearImmediate);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcclxuICAgICAgICAgICAgd2luZG93O1xyXG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XHJcblxyXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xyXG5cclxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XHJcbn07XHJcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xyXG59O1xyXG5leHBvcnRzLmNsZWFyVGltZW91dCA9XHJcbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcclxuICBpZiAodGltZW91dCkge1xyXG4gICAgdGltZW91dC5jbG9zZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcclxuICB0aGlzLl9pZCA9IGlkO1xyXG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xyXG59XHJcblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcclxuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcclxufTtcclxuXHJcbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxyXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XHJcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xyXG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XHJcbn07XHJcblxyXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcclxuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xyXG59O1xyXG5cclxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcclxuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XHJcblxyXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xyXG4gIGlmIChtc2VjcyA+PSAwKSB7XHJcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XHJcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXHJcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XHJcbiAgICB9LCBtc2Vjcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxyXG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xyXG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcclxuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcclxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cclxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XHJcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///25\\n')},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(11);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"452f9ab4\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(11, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(11);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvSGVhZGVyLnZ1ZT83MTNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQTZRO0FBQ25TLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBZ0U7QUFDbEYsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxJQUFVO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixFQUE2USxFQUFFO0FBQ3BTLHNCQUFzQixtQkFBTyxDQUFDLEVBQTZRO0FBQzNTLHVEQUF1RCxRQUFTO0FBQ2hFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI0NTJmOWFiNFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9IZWFkZXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///26\\n\")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(2)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \":root {\\\\r\\\\n    --azul: #0176bf;\\\\r\\\\n    --piel: #c96d44;\\\\r\\\\n    --claro: #E8F3F5;\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  .clearfix:before,\\\\r\\\\n  .clearfix:after {\\\\r\\\\n    content: \\\\\" \\\\\";\\\\r\\\\n    /* 1 */\\\\r\\\\n    display: table;\\\\r\\\\n    /* 2 */\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  .clearfix:after {\\\\r\\\\n    clear: both;\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  html {\\\\r\\\\n    box-sizing: border-box;\\\\r\\\\n    margin: 0;\\\\r\\\\n    font-family: \\'Source Sans Pro\\', sans-serif;\\\\r\\\\n    height: 100vh;\\\\r\\\\n\\\\r\\\\n  }\\\\r\\\\n  body{\\\\r\\\\n    margin: 0;\\\\r\\\\n  }\\\\r\\\\n  *,\\\\r\\\\n  *:before,\\\\r\\\\n  *:after {\\\\r\\\\n    box-sizing: inherit;\\\\r\\\\n  }\\\\r\\\\n\\\\r\\\\n  div.logo {\\\\r\\\\n    float: left;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.barra {\\\\r\\\\n  padding: 10px;\\\\r\\\\n  background-color: var(--azul);\\\\r\\\\n}\\\\r\\\\n.brand{\\\\r\\\\n  margin: 0;\\\\r\\\\n}\\\\r\\\\n.fixed {\\\\r\\\\n  position: fixed;\\\\r\\\\n  width: 100%;\\\\r\\\\n  top: 0;\\\\r\\\\n  left: 0;\\\\r\\\\n  z-index: 2;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nh1{\\\\r\\\\n    color: var(--piel);\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nbutton{\\\\r\\\\n  border-width: 0;\\\\r\\\\n  outline: none;\\\\r\\\\n  border-radius: 2px;\\\\r\\\\n  box-shadow: 0 1px 4px rgba(0, 0, 0, .6);\\\\r\\\\n  \\\\r\\\\n  background-color: var(--piel);\\\\r\\\\n  color: #ecf0f1;\\\\r\\\\n  \\\\r\\\\n  transition: background-color .3s;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nbutton:hover{\\\\r\\\\n  background-color: #9C5435;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\", \"\", {\"version\":3,\"sources\":[\"C:/Users/Keiner/Dropbox/UNINORTE/saludtech/src/assets/styles.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;GAClB;;EAED;;IAEE,aAAa;IACb,OAAO;IACP,eAAe;IACf,OAAO;GACR;;EAED;IACE,YAAY;GACb;;EAED;IACE,uBAAuB;IACvB,UAAU;IACV,2CAA2C;IAC3C,cAAc;;GAEf;EACD;IACE,UAAU;GACX;EACD;;;IAGE,oBAAoB;GACrB;;EAED;IACE,YAAY;CACf;;AAED;EACE,cAAc;EACd,8BAA8B;CAC/B;AACD;EACE,UAAU;CACX;AACD;EACE,gBAAgB;EAChB,YAAY;EACZ,OAAO;EACP,QAAQ;EACR,WAAW;CACZ;;AAED;IACI,mBAAmB;CACtB;;AAED;EACE,gBAAgB;EAChB,cAAc;EACd,mBAAmB;EACnB,wCAAwC;;EAExC,8BAA8B;EAC9B,eAAe;;EAEf,iCAAiC;CAClC;;AAED;EACE,0BAA0B;CAC3B\",\"file\":\"styles.css\",\"sourcesContent\":[\":root {\\\\r\\\\n    --azul: #0176bf;\\\\r\\\\n    --piel: #c96d44;\\\\r\\\\n    --claro: #E8F3F5;\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  .clearfix:before,\\\\r\\\\n  .clearfix:after {\\\\r\\\\n    content: \\\\\" \\\\\";\\\\r\\\\n    /* 1 */\\\\r\\\\n    display: table;\\\\r\\\\n    /* 2 */\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  .clearfix:after {\\\\r\\\\n    clear: both;\\\\r\\\\n  }\\\\r\\\\n  \\\\r\\\\n  html {\\\\r\\\\n    box-sizing: border-box;\\\\r\\\\n    margin: 0;\\\\r\\\\n    font-family: \\'Source Sans Pro\\', sans-serif;\\\\r\\\\n    height: 100vh;\\\\r\\\\n\\\\r\\\\n  }\\\\r\\\\n  body{\\\\r\\\\n    margin: 0;\\\\r\\\\n  }\\\\r\\\\n  *,\\\\r\\\\n  *:before,\\\\r\\\\n  *:after {\\\\r\\\\n    box-sizing: inherit;\\\\r\\\\n  }\\\\r\\\\n\\\\r\\\\n  div.logo {\\\\r\\\\n    float: left;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\ndiv.barra {\\\\r\\\\n  padding: 10px;\\\\r\\\\n  background-color: var(--azul);\\\\r\\\\n}\\\\r\\\\n.brand{\\\\r\\\\n  margin: 0;\\\\r\\\\n}\\\\r\\\\n.fixed {\\\\r\\\\n  position: fixed;\\\\r\\\\n  width: 100%;\\\\r\\\\n  top: 0;\\\\r\\\\n  left: 0;\\\\r\\\\n  z-index: 2;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nh1{\\\\r\\\\n    color: var(--piel);\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nbutton{\\\\r\\\\n  border-width: 0;\\\\r\\\\n  outline: none;\\\\r\\\\n  border-radius: 2px;\\\\r\\\\n  box-shadow: 0 1px 4px rgba(0, 0, 0, .6);\\\\r\\\\n  \\\\r\\\\n  background-color: var(--piel);\\\\r\\\\n  color: #ecf0f1;\\\\r\\\\n  \\\\r\\\\n  transition: background-color .3s;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nbutton:hover{\\\\r\\\\n  background-color: #9C5435;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3N0eWxlcy5jc3M/MDFiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsVUFBVSx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLG9EQUFvRCx1QkFBdUIsc0NBQXNDLHNCQUFzQiw2QkFBNkIsb0JBQW9CLE9BQU8sa0JBQWtCLCtCQUErQixrQkFBa0IsbURBQW1ELHNCQUFzQixXQUFXLFdBQVcsa0JBQWtCLE9BQU8sc0NBQXNDLDRCQUE0QixPQUFPLG9CQUFvQixvQkFBb0IsS0FBSyxtQkFBbUIsb0JBQW9CLG9DQUFvQyxLQUFLLFdBQVcsZ0JBQWdCLEtBQUssWUFBWSxzQkFBc0Isa0JBQWtCLGFBQWEsY0FBYyxpQkFBaUIsS0FBSyxXQUFXLDJCQUEyQixLQUFLLGVBQWUsc0JBQXNCLG9CQUFvQix5QkFBeUIsOENBQThDLDBDQUEwQyxxQkFBcUIsNkNBQTZDLEtBQUsscUJBQXFCLGdDQUFnQyxLQUFLLGdCQUFnQix1SEFBdUgsWUFBWSxhQUFhLGFBQWEsT0FBTyxNQUFNLFVBQVUsVUFBVSxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLFlBQVksS0FBSyxLQUFLLFVBQVUsS0FBSyxPQUFPLFlBQVksT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxjQUFjLGFBQWEsWUFBWSxZQUFZLE9BQU8sS0FBSyxZQUFZLHFEQUFxRCx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLG9EQUFvRCx1QkFBdUIsc0NBQXNDLHNCQUFzQiw2QkFBNkIsb0JBQW9CLE9BQU8sa0JBQWtCLCtCQUErQixrQkFBa0IsbURBQW1ELHNCQUFzQixXQUFXLFdBQVcsa0JBQWtCLE9BQU8sc0NBQXNDLDRCQUE0QixPQUFPLG9CQUFvQixvQkFBb0IsS0FBSyxtQkFBbUIsb0JBQW9CLG9DQUFvQyxLQUFLLFdBQVcsZ0JBQWdCLEtBQUssWUFBWSxzQkFBc0Isa0JBQWtCLGFBQWEsY0FBYyxpQkFBaUIsS0FBSyxXQUFXLDJCQUEyQixLQUFLLGVBQWUsc0JBQXNCLG9CQUFvQix5QkFBeUIsOENBQThDLDBDQUEwQyxxQkFBcUIsNkNBQTZDLEtBQUsscUJBQXFCLGdDQUFnQyxLQUFLLDJCQUEyQjs7QUFFaDhGIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXHJcXG4gICAgLS1henVsOiAjMDE3NmJmO1xcclxcbiAgICAtLXBpZWw6ICNjOTZkNDQ7XFxyXFxuICAgIC0tY2xhcm86ICNFOEYzRjU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5jbGVhcmZpeDpiZWZvcmUsXFxyXFxuICAuY2xlYXJmaXg6YWZ0ZXIge1xcclxcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxyXFxuICAgIC8qIDEgKi9cXHJcXG4gICAgZGlzcGxheTogdGFibGU7XFxyXFxuICAgIC8qIDIgKi9cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmNsZWFyZml4OmFmdGVyIHtcXHJcXG4gICAgY2xlYXI6IGJvdGg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGh0bWwge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiAnU291cmNlIFNhbnMgUHJvJywgc2Fucy1zZXJpZjtcXHJcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXHJcXG5cXHJcXG4gIH1cXHJcXG4gIGJvZHl7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gIH1cXHJcXG4gICosXFxyXFxuICAqOmJlZm9yZSxcXHJcXG4gICo6YWZ0ZXIge1xcclxcbiAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcclxcbiAgfVxcclxcblxcclxcbiAgZGl2LmxvZ28ge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcnJhIHtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1henVsKTtcXHJcXG59XFxyXFxuLmJyYW5ke1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4uZml4ZWQge1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgei1pbmRleDogMjtcXHJcXG59XFxyXFxuXFxyXFxuaDF7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1waWVsKTtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9ue1xcclxcbiAgYm9yZGVyLXdpZHRoOiAwO1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXHJcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIC42KTtcXHJcXG4gIFxcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGllbCk7XFxyXFxuICBjb2xvcjogI2VjZjBmMTtcXHJcXG4gIFxcclxcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3M7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbjpob3ZlcntcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5QzU0MzU7XFxyXFxufVxcclxcblxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9LZWluZXIvRHJvcGJveC9VTklOT1JURS9zYWx1ZHRlY2gvc3JjL2Fzc2V0cy9zdHlsZXMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksZ0JBQWdCO0lBQ2hCLGdCQUFnQjtJQUNoQixpQkFBaUI7R0FDbEI7O0VBRUQ7O0lBRUUsYUFBYTtJQUNiLE9BQU87SUFDUCxlQUFlO0lBQ2YsT0FBTztHQUNSOztFQUVEO0lBQ0UsWUFBWTtHQUNiOztFQUVEO0lBQ0UsdUJBQXVCO0lBQ3ZCLFVBQVU7SUFDViwyQ0FBMkM7SUFDM0MsY0FBYzs7R0FFZjtFQUNEO0lBQ0UsVUFBVTtHQUNYO0VBQ0Q7OztJQUdFLG9CQUFvQjtHQUNyQjs7RUFFRDtJQUNFLFlBQVk7Q0FDZjs7QUFFRDtFQUNFLGNBQWM7RUFDZCw4QkFBOEI7Q0FDL0I7QUFDRDtFQUNFLFVBQVU7Q0FDWDtBQUNEO0VBQ0UsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixPQUFPO0VBQ1AsUUFBUTtFQUNSLFdBQVc7Q0FDWjs7QUFFRDtJQUNJLG1CQUFtQjtDQUN0Qjs7QUFFRDtFQUNFLGdCQUFnQjtFQUNoQixjQUFjO0VBQ2QsbUJBQW1CO0VBQ25CLHdDQUF3Qzs7RUFFeEMsOEJBQThCO0VBQzlCLGVBQWU7O0VBRWYsaUNBQWlDO0NBQ2xDOztBQUVEO0VBQ0UsMEJBQTBCO0NBQzNCXCIsXCJmaWxlXCI6XCJzdHlsZXMuY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjpyb290IHtcXHJcXG4gICAgLS1henVsOiAjMDE3NmJmO1xcclxcbiAgICAtLXBpZWw6ICNjOTZkNDQ7XFxyXFxuICAgIC0tY2xhcm86ICNFOEYzRjU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5jbGVhcmZpeDpiZWZvcmUsXFxyXFxuICAuY2xlYXJmaXg6YWZ0ZXIge1xcclxcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxyXFxuICAgIC8qIDEgKi9cXHJcXG4gICAgZGlzcGxheTogdGFibGU7XFxyXFxuICAgIC8qIDIgKi9cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmNsZWFyZml4OmFmdGVyIHtcXHJcXG4gICAgY2xlYXI6IGJvdGg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGh0bWwge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiAnU291cmNlIFNhbnMgUHJvJywgc2Fucy1zZXJpZjtcXHJcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXHJcXG5cXHJcXG4gIH1cXHJcXG4gIGJvZHl7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gIH1cXHJcXG4gICosXFxyXFxuICAqOmJlZm9yZSxcXHJcXG4gICo6YWZ0ZXIge1xcclxcbiAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcclxcbiAgfVxcclxcblxcclxcbiAgZGl2LmxvZ28ge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcnJhIHtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1henVsKTtcXHJcXG59XFxyXFxuLmJyYW5ke1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4uZml4ZWQge1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgei1pbmRleDogMjtcXHJcXG59XFxyXFxuXFxyXFxuaDF7XFxyXFxuICAgIGNvbG9yOiB2YXIoLS1waWVsKTtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9ue1xcclxcbiAgYm9yZGVyLXdpZHRoOiAwO1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXHJcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIC42KTtcXHJcXG4gIFxcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGllbCk7XFxyXFxuICBjb2xvcjogI2VjZjBmMTtcXHJcXG4gIFxcclxcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3M7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbjpob3ZlcntcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5QzU0MzU7XFxyXFxufVxcclxcblxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///27\\n')},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(12);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"72baf6dc\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(12, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(12);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT83NDIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXdQO0FBQzlRLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBMEQ7QUFDNUUsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxJQUFVO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixFQUF3UCxFQUFFO0FBQy9RLHNCQUFzQixtQkFBTyxDQUFDLEVBQXdQO0FBQ3RSLHVEQUF1RCxRQUFTO0FBQ2hFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI3MmJhZjZkY1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///28\\n\")},function(module,exports){eval(\"/* (ignored) */\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ290IChpZ25vcmVkKT8yOWU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///29\\n\")},function(module,exports,__webpack_require__){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\r\\nmodule.exports = function(updatedModules, renewedModules) {\\r\\n\\tvar unacceptedModules = updatedModules.filter(function(moduleId) {\\r\\n\\t\\treturn renewedModules && renewedModules.indexOf(moduleId) < 0;\\r\\n\\t});\\r\\n\\tvar log = __webpack_require__(13);\\r\\n\\r\\n\\tif (unacceptedModules.length > 0) {\\r\\n\\t\\tlog(\\r\\n\\t\\t\\t\"warning\",\\r\\n\\t\\t\\t\"[HMR] The following modules couldn\\'t be hot updated: (They would need a full reload!)\"\\r\\n\\t\\t);\\r\\n\\t\\tunacceptedModules.forEach(function(moduleId) {\\r\\n\\t\\t\\tlog(\"warning\", \"[HMR]  - \" + moduleId);\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\tif (!renewedModules || renewedModules.length === 0) {\\r\\n\\t\\tlog(\"info\", \"[HMR] Nothing hot updated.\");\\r\\n\\t} else {\\r\\n\\t\\tlog(\"info\", \"[HMR] Updated modules:\");\\r\\n\\t\\trenewedModules.forEach(function(moduleId) {\\r\\n\\t\\t\\tif (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\\r\\n\\t\\t\\t\\tvar parts = moduleId.split(\"!\");\\r\\n\\t\\t\\t\\tlog.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\\r\\n\\t\\t\\t\\tlog(\"info\", \"[HMR]  - \" + moduleId);\\r\\n\\t\\t\\t\\tlog.groupEnd(\"info\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tlog(\"info\", \"[HMR]  - \" + moduleId);\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tvar numberIds = renewedModules.every(function(moduleId) {\\r\\n\\t\\t\\treturn typeof moduleId === \"number\";\\r\\n\\t\\t});\\r\\n\\t\\tif (numberIds)\\r\\n\\t\\t\\tlog(\\r\\n\\t\\t\\t\\t\"info\",\\r\\n\\t\\t\\t\\t\"[HMR] Consider using the NamedModulesPlugin for module names.\"\\r\\n\\t\\t\\t);\\r\\n\\t}\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzP2U1MmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsV0FBVyxtQkFBTyxDQUFDLEVBQU87O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpIHtcclxuXHR2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XHJcblx0fSk7XHJcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcclxuXHJcblx0aWYgKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdGxvZyhcclxuXHRcdFx0XCJ3YXJuaW5nXCIsXHJcblx0XHRcdFwiW0hNUl0gVGhlIGZvbGxvd2luZyBtb2R1bGVzIGNvdWxkbid0IGJlIGhvdCB1cGRhdGVkOiAoVGhleSB3b3VsZCBuZWVkIGEgZnVsbCByZWxvYWQhKVwiXHJcblx0XHQpO1xyXG5cdFx0dW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xyXG5cdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlmICghcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBVcGRhdGVkIG1vZHVsZXM6XCIpO1xyXG5cdFx0cmVuZXdlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1vZHVsZUlkID09PSBcInN0cmluZ1wiICYmIG1vZHVsZUlkLmluZGV4T2YoXCIhXCIpICE9PSAtMSkge1xyXG5cdFx0XHRcdHZhciBwYXJ0cyA9IG1vZHVsZUlkLnNwbGl0KFwiIVwiKTtcclxuXHRcdFx0XHRsb2cuZ3JvdXBDb2xsYXBzZWQoXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBwYXJ0cy5wb3AoKSk7XHJcblx0XHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xyXG5cdFx0XHRcdGxvZy5ncm91cEVuZChcImluZm9cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHZhciBudW1iZXJJZHMgPSByZW5ld2VkTW9kdWxlcy5ldmVyeShmdW5jdGlvbihtb2R1bGVJZCkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xyXG5cdFx0fSk7XHJcblx0XHRpZiAobnVtYmVySWRzKVxyXG5cdFx0XHRsb2coXHJcblx0XHRcdFx0XCJpbmZvXCIsXHJcblx0XHRcdFx0XCJbSE1SXSBDb25zaWRlciB1c2luZyB0aGUgTmFtZWRNb2R1bGVzUGx1Z2luIGZvciBtb2R1bGUgbmFtZXMuXCJcclxuXHRcdFx0KTtcclxuXHR9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///30\\n')},function(module,exports,__webpack_require__){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\r\\n/*globals window __webpack_hash__ */\\r\\nif (true) {\\r\\n\\tvar lastHash;\\r\\n\\tvar upToDate = function upToDate() {\\r\\n\\t\\treturn lastHash.indexOf(__webpack_require__.h()) >= 0;\\r\\n\\t};\\r\\n\\tvar log = __webpack_require__(13);\\r\\n\\tvar check = function check() {\\r\\n\\t\\tmodule.hot\\r\\n\\t\\t\\t.check(true)\\r\\n\\t\\t\\t.then(function(updatedModules) {\\r\\n\\t\\t\\t\\tif (!updatedModules) {\\r\\n\\t\\t\\t\\t\\tlog(\"warning\", \"[HMR] Cannot find update. Need to do a full reload!\");\\r\\n\\t\\t\\t\\t\\tlog(\\r\\n\\t\\t\\t\\t\\t\\t\"warning\",\\r\\n\\t\\t\\t\\t\\t\\t\"[HMR] (Probably because of restarting the webpack-dev-server)\"\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\twindow.location.reload();\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (!upToDate()) {\\r\\n\\t\\t\\t\\t\\tcheck();\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t__webpack_require__(30)(updatedModules, updatedModules);\\r\\n\\r\\n\\t\\t\\t\\tif (upToDate()) {\\r\\n\\t\\t\\t\\t\\tlog(\"info\", \"[HMR] App is up to date.\");\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t})\\r\\n\\t\\t\\t.catch(function(err) {\\r\\n\\t\\t\\t\\tvar status = module.hot.status();\\r\\n\\t\\t\\t\\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\\r\\n\\t\\t\\t\\t\\tlog(\\r\\n\\t\\t\\t\\t\\t\\t\"warning\",\\r\\n\\t\\t\\t\\t\\t\\t\"[HMR] Cannot apply update. Need to do a full reload!\"\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\tlog(\"warning\", \"[HMR] \" + err.stack || err.message);\\r\\n\\t\\t\\t\\t\\twindow.location.reload();\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tlog(\"warning\", \"[HMR] Update failed: \" + err.stack || err.message);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t};\\r\\n\\tvar hotEmitter = __webpack_require__(14);\\r\\n\\thotEmitter.on(\"webpackHotUpdate\", function(currentHash) {\\r\\n\\t\\tlastHash = currentHash;\\r\\n\\t\\tif (!upToDate() && module.hot.status() === \"idle\") {\\r\\n\\t\\t\\tlog(\"info\", \"[HMR] Checking for updates on the server...\");\\r\\n\\t\\t\\tcheck();\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\tlog(\"info\", \"[HMR] Waiting for update signal from WDS...\");\\r\\n} else {}\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9kZXYtc2VydmVyLmpzPzY4OTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBVTtBQUNkO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQWdCO0FBQzFDO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLEVBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksbUJBQU8sQ0FBQyxFQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLE1BQU0sRUFFTiIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8qZ2xvYmFscyB3aW5kb3cgX193ZWJwYWNrX2hhc2hfXyAqL1xyXG5pZiAobW9kdWxlLmhvdCkge1xyXG5cdHZhciBsYXN0SGFzaDtcclxuXHR2YXIgdXBUb0RhdGUgPSBmdW5jdGlvbiB1cFRvRGF0ZSgpIHtcclxuXHRcdHJldHVybiBsYXN0SGFzaC5pbmRleE9mKF9fd2VicGFja19oYXNoX18pID49IDA7XHJcblx0fTtcclxuXHR2YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xyXG5cdHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKCkge1xyXG5cdFx0bW9kdWxlLmhvdFxyXG5cdFx0XHQuY2hlY2sodHJ1ZSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24odXBkYXRlZE1vZHVsZXMpIHtcclxuXHRcdFx0XHRpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XHJcblx0XHRcdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIpO1xyXG5cdFx0XHRcdFx0bG9nKFxyXG5cdFx0XHRcdFx0XHRcIndhcm5pbmdcIixcclxuXHRcdFx0XHRcdFx0XCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCJcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIXVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRcdGNoZWNrKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCB1cGRhdGVkTW9kdWxlcyk7XHJcblxyXG5cdFx0XHRcdGlmICh1cFRvRGF0ZSgpKSB7XHJcblx0XHRcdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdHZhciBzdGF0dXMgPSBtb2R1bGUuaG90LnN0YXR1cygpO1xyXG5cdFx0XHRcdGlmIChbXCJhYm9ydFwiLCBcImZhaWxcIl0uaW5kZXhPZihzdGF0dXMpID49IDApIHtcclxuXHRcdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFx0XCJ3YXJuaW5nXCIsXHJcblx0XHRcdFx0XHRcdFwiW0hNUl0gQ2Fubm90IGFwcGx5IHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIFVwZGF0ZSBmYWlsZWQ6IFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblx0dmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9lbWl0dGVyXCIpO1xyXG5cdGhvdEVtaXR0ZXIub24oXCJ3ZWJwYWNrSG90VXBkYXRlXCIsIGZ1bmN0aW9uKGN1cnJlbnRIYXNoKSB7XHJcblx0XHRsYXN0SGFzaCA9IGN1cnJlbnRIYXNoO1xyXG5cdFx0aWYgKCF1cFRvRGF0ZSgpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XHJcblx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBDaGVja2luZyBmb3IgdXBkYXRlcyBvbiB0aGUgc2VydmVyLi4uXCIpO1xyXG5cdFx0XHRjaGVjaygpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGxvZyhcImluZm9cIiwgXCJbSE1SXSBXYWl0aW5nIGZvciB1cGRhdGUgc2lnbmFsIGZyb20gV0RTLi4uXCIpO1xyXG59IGVsc2Uge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIltITVJdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgZGlzYWJsZWQuXCIpO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///31\\n')},function(module,exports){eval(\"// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\nfunction EventEmitter() {\\r\\n  this._events = this._events || {};\\r\\n  this._maxListeners = this._maxListeners || undefined;\\r\\n}\\r\\nmodule.exports = EventEmitter;\\r\\n\\r\\n// Backwards-compat with node 0.10.x\\r\\nEventEmitter.EventEmitter = EventEmitter;\\r\\n\\r\\nEventEmitter.prototype._events = undefined;\\r\\nEventEmitter.prototype._maxListeners = undefined;\\r\\n\\r\\n// By default EventEmitters will print a warning if more than 10 listeners are\\r\\n// added to it. This is a useful default which helps finding memory leaks.\\r\\nEventEmitter.defaultMaxListeners = 10;\\r\\n\\r\\n// Obviously not all Emitters should be limited to 10. This function allows\\r\\n// that to be increased. Set to zero for unlimited.\\r\\nEventEmitter.prototype.setMaxListeners = function(n) {\\r\\n  if (!isNumber(n) || n < 0 || isNaN(n))\\r\\n    throw TypeError('n must be a positive number');\\r\\n  this._maxListeners = n;\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.emit = function(type) {\\r\\n  var er, handler, len, args, i, listeners;\\r\\n\\r\\n  if (!this._events)\\r\\n    this._events = {};\\r\\n\\r\\n  // If there is no 'error' event listener then throw.\\r\\n  if (type === 'error') {\\r\\n    if (!this._events.error ||\\r\\n        (isObject(this._events.error) && !this._events.error.length)) {\\r\\n      er = arguments[1];\\r\\n      if (er instanceof Error) {\\r\\n        throw er; // Unhandled 'error' event\\r\\n      } else {\\r\\n        // At least give some kind of context to the user\\r\\n        var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\r\\n        err.context = er;\\r\\n        throw err;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  handler = this._events[type];\\r\\n\\r\\n  if (isUndefined(handler))\\r\\n    return false;\\r\\n\\r\\n  if (isFunction(handler)) {\\r\\n    switch (arguments.length) {\\r\\n      // fast cases\\r\\n      case 1:\\r\\n        handler.call(this);\\r\\n        break;\\r\\n      case 2:\\r\\n        handler.call(this, arguments[1]);\\r\\n        break;\\r\\n      case 3:\\r\\n        handler.call(this, arguments[1], arguments[2]);\\r\\n        break;\\r\\n      // slower\\r\\n      default:\\r\\n        args = Array.prototype.slice.call(arguments, 1);\\r\\n        handler.apply(this, args);\\r\\n    }\\r\\n  } else if (isObject(handler)) {\\r\\n    args = Array.prototype.slice.call(arguments, 1);\\r\\n    listeners = handler.slice();\\r\\n    len = listeners.length;\\r\\n    for (i = 0; i < len; i++)\\r\\n      listeners[i].apply(this, args);\\r\\n  }\\r\\n\\r\\n  return true;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.addListener = function(type, listener) {\\r\\n  var m;\\r\\n\\r\\n  if (!isFunction(listener))\\r\\n    throw TypeError('listener must be a function');\\r\\n\\r\\n  if (!this._events)\\r\\n    this._events = {};\\r\\n\\r\\n  // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\r\\n  // adding it to the listeners, first emit \\\"newListener\\\".\\r\\n  if (this._events.newListener)\\r\\n    this.emit('newListener', type,\\r\\n              isFunction(listener.listener) ?\\r\\n              listener.listener : listener);\\r\\n\\r\\n  if (!this._events[type])\\r\\n    // Optimize the case of one listener. Don't need the extra array object.\\r\\n    this._events[type] = listener;\\r\\n  else if (isObject(this._events[type]))\\r\\n    // If we've already got an array, just append.\\r\\n    this._events[type].push(listener);\\r\\n  else\\r\\n    // Adding the second element, need to change to array.\\r\\n    this._events[type] = [this._events[type], listener];\\r\\n\\r\\n  // Check for listener leak\\r\\n  if (isObject(this._events[type]) && !this._events[type].warned) {\\r\\n    if (!isUndefined(this._maxListeners)) {\\r\\n      m = this._maxListeners;\\r\\n    } else {\\r\\n      m = EventEmitter.defaultMaxListeners;\\r\\n    }\\r\\n\\r\\n    if (m && m > 0 && this._events[type].length > m) {\\r\\n      this._events[type].warned = true;\\r\\n      console.error('(node) warning: possible EventEmitter memory ' +\\r\\n                    'leak detected. %d listeners added. ' +\\r\\n                    'Use emitter.setMaxListeners() to increase limit.',\\r\\n                    this._events[type].length);\\r\\n      if (typeof console.trace === 'function') {\\r\\n        // not supported in IE 10\\r\\n        console.trace();\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\r\\n\\r\\nEventEmitter.prototype.once = function(type, listener) {\\r\\n  if (!isFunction(listener))\\r\\n    throw TypeError('listener must be a function');\\r\\n\\r\\n  var fired = false;\\r\\n\\r\\n  function g() {\\r\\n    this.removeListener(type, g);\\r\\n\\r\\n    if (!fired) {\\r\\n      fired = true;\\r\\n      listener.apply(this, arguments);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  g.listener = listener;\\r\\n  this.on(type, g);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// emits a 'removeListener' event iff the listener was removed\\r\\nEventEmitter.prototype.removeListener = function(type, listener) {\\r\\n  var list, position, length, i;\\r\\n\\r\\n  if (!isFunction(listener))\\r\\n    throw TypeError('listener must be a function');\\r\\n\\r\\n  if (!this._events || !this._events[type])\\r\\n    return this;\\r\\n\\r\\n  list = this._events[type];\\r\\n  length = list.length;\\r\\n  position = -1;\\r\\n\\r\\n  if (list === listener ||\\r\\n      (isFunction(list.listener) && list.listener === listener)) {\\r\\n    delete this._events[type];\\r\\n    if (this._events.removeListener)\\r\\n      this.emit('removeListener', type, listener);\\r\\n\\r\\n  } else if (isObject(list)) {\\r\\n    for (i = length; i-- > 0;) {\\r\\n      if (list[i] === listener ||\\r\\n          (list[i].listener && list[i].listener === listener)) {\\r\\n        position = i;\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (position < 0)\\r\\n      return this;\\r\\n\\r\\n    if (list.length === 1) {\\r\\n      list.length = 0;\\r\\n      delete this._events[type];\\r\\n    } else {\\r\\n      list.splice(position, 1);\\r\\n    }\\r\\n\\r\\n    if (this._events.removeListener)\\r\\n      this.emit('removeListener', type, listener);\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.removeAllListeners = function(type) {\\r\\n  var key, listeners;\\r\\n\\r\\n  if (!this._events)\\r\\n    return this;\\r\\n\\r\\n  // not listening for removeListener, no need to emit\\r\\n  if (!this._events.removeListener) {\\r\\n    if (arguments.length === 0)\\r\\n      this._events = {};\\r\\n    else if (this._events[type])\\r\\n      delete this._events[type];\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // emit removeListener for all listeners on all events\\r\\n  if (arguments.length === 0) {\\r\\n    for (key in this._events) {\\r\\n      if (key === 'removeListener') continue;\\r\\n      this.removeAllListeners(key);\\r\\n    }\\r\\n    this.removeAllListeners('removeListener');\\r\\n    this._events = {};\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  listeners = this._events[type];\\r\\n\\r\\n  if (isFunction(listeners)) {\\r\\n    this.removeListener(type, listeners);\\r\\n  } else if (listeners) {\\r\\n    // LIFO order\\r\\n    while (listeners.length)\\r\\n      this.removeListener(type, listeners[listeners.length - 1]);\\r\\n  }\\r\\n  delete this._events[type];\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.listeners = function(type) {\\r\\n  var ret;\\r\\n  if (!this._events || !this._events[type])\\r\\n    ret = [];\\r\\n  else if (isFunction(this._events[type]))\\r\\n    ret = [this._events[type]];\\r\\n  else\\r\\n    ret = this._events[type].slice();\\r\\n  return ret;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.listenerCount = function(type) {\\r\\n  if (this._events) {\\r\\n    var evlistener = this._events[type];\\r\\n\\r\\n    if (isFunction(evlistener))\\r\\n      return 1;\\r\\n    else if (evlistener)\\r\\n      return evlistener.length;\\r\\n  }\\r\\n  return 0;\\r\\n};\\r\\n\\r\\nEventEmitter.listenerCount = function(emitter, type) {\\r\\n  return emitter.listenerCount(type);\\r\\n};\\r\\n\\r\\nfunction isFunction(arg) {\\r\\n  return typeof arg === 'function';\\r\\n}\\r\\n\\r\\nfunction isNumber(arg) {\\r\\n  return typeof arg === 'number';\\r\\n}\\r\\n\\r\\nfunction isObject(arg) {\\r\\n  return typeof arg === 'object' && arg !== null;\\r\\n}\\r\\n\\r\\nfunction isUndefined(arg) {\\r\\n  return arg === void 0;\\r\\n}\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XHJcblxyXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcclxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cclxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcclxuXHJcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xyXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XHJcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcclxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XHJcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cylcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG5cclxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXHJcbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XHJcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XHJcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcclxuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGZhc3QgY2FzZXNcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gc2xvd2VyXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XHJcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcclxuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgdmFyIG07XHJcblxyXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cylcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG5cclxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxyXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cclxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxyXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXHJcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xyXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcclxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxyXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XHJcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcclxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cclxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxuICBlbHNlXHJcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cclxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcclxuXHJcbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcclxuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XHJcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xyXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXHJcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcclxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxyXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuXHJcbiAgdmFyIGZpcmVkID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGcoKSB7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xyXG5cclxuICAgIGlmICghZmlyZWQpIHtcclxuICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gIHRoaXMub24odHlwZSwgZyk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XHJcblxyXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgcG9zaXRpb24gPSAtMTtcclxuXHJcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXHJcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcclxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcclxuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcclxuICAgICAgICBwb3NpdGlvbiA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24gPCAwKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXHJcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIHZhciBrZXksIGxpc3RlbmVycztcclxuXHJcbiAgaWYgKCF0aGlzLl9ldmVudHMpXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxyXG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcclxuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XHJcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcclxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcclxuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xyXG4gICAgLy8gTElGTyBvcmRlclxyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXHJcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XHJcbiAgfVxyXG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgdmFyIHJldDtcclxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgcmV0ID0gW107XHJcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxyXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XHJcbiAgZWxzZVxyXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XHJcbiAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICBpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxyXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XHJcbiAgfVxyXG4gIHJldHVybiAwO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XHJcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XHJcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///32\\n\")},function(module,exports,__webpack_require__){eval(\"var map = {\\n\\t\\\"./log\\\": 13\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tvar module = __webpack_require__(id);\\n\\treturn module;\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error('Cannot find module \\\"' + req + '\\\".');\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = 33;\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJD8xYzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL2xvZ1wiOiAxM1xufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblx0cmV0dXJuIG1vZHVsZTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgeyAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHZhciBlID0gbmV3IEVycm9yKCdDYW5ub3QgZmluZCBtb2R1bGUgXCInICsgcmVxICsgJ1wiLicpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBpZDtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzMzsiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///33\\n\")},function(module,exports){eval(\"var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];\\r\\nvar HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];\\r\\n\\r\\nvar alphaIndex = {};\\r\\nvar numIndex = {};\\r\\n\\r\\nvar i = 0;\\r\\nvar length = HTML_ALPHA.length;\\r\\nwhile (i < length) {\\r\\n    var a = HTML_ALPHA[i];\\r\\n    var c = HTML_CODES[i];\\r\\n    alphaIndex[a] = String.fromCharCode(c);\\r\\n    numIndex[c] = a;\\r\\n    i++;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @constructor\\r\\n */\\r\\nfunction Html4Entities() {}\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.prototype.decode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    return str.replace(/&(#?[\\\\w\\\\d]+);?/g, function(s, entity) {\\r\\n        var chr;\\r\\n        if (entity.charAt(0) === \\\"#\\\") {\\r\\n            var code = entity.charAt(1).toLowerCase() === 'x' ?\\r\\n                parseInt(entity.substr(2), 16) :\\r\\n                parseInt(entity.substr(1));\\r\\n\\r\\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\\r\\n                chr = String.fromCharCode(code);\\r\\n            }\\r\\n        } else {\\r\\n            chr = alphaIndex[entity];\\r\\n        }\\r\\n        return chr || s;\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.decode = function(str) {\\r\\n    return new Html4Entities().decode(str);\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.prototype.encode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var alpha = numIndex[str.charCodeAt(i)];\\r\\n        result += alpha ? \\\"&\\\" + alpha + \\\";\\\" : str.charAt(i);\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.encode = function(str) {\\r\\n    return new Html4Entities().encode(str);\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.prototype.encodeNonUTF = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var cc = str.charCodeAt(i);\\r\\n        var alpha = numIndex[cc];\\r\\n        if (alpha) {\\r\\n            result += \\\"&\\\" + alpha + \\\";\\\";\\r\\n        } else if (cc < 32 || cc > 126) {\\r\\n            result += \\\"&#\\\" + cc + \\\";\\\";\\r\\n        } else {\\r\\n            result += str.charAt(i);\\r\\n        }\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.encodeNonUTF = function(str) {\\r\\n    return new Html4Entities().encodeNonUTF(str);\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.prototype.encodeNonASCII = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var c = str.charCodeAt(i);\\r\\n        if (c <= 255) {\\r\\n            result += str[i++];\\r\\n            continue;\\r\\n        }\\r\\n        result += '&#' + c + ';';\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nHtml4Entities.encodeNonASCII = function(str) {\\r\\n    return new Html4Entities().encodeNonASCII(str);\\r\\n};\\r\\n\\r\\nmodule.exports = Html4Entities;\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanM/MWYwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcclxudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcclxuXHJcbnZhciBhbHBoYUluZGV4ID0ge307XHJcbnZhciBudW1JbmRleCA9IHt9O1xyXG5cclxudmFyIGkgPSAwO1xyXG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XHJcbndoaWxlIChpIDwgbGVuZ3RoKSB7XHJcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XHJcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XHJcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgIG51bUluZGV4W2NdID0gYTtcclxuICAgIGkrKztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcclxuICAgICAgICB2YXIgY2hyO1xyXG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cclxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xyXG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xyXG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcclxuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XHJcbiAgICAgICAgaWYgKGFscGhhKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///34\\n\")},function(module,exports){eval(\"var ALPHA_INDEX = {\\r\\n    '&lt': '<',\\r\\n    '&gt': '>',\\r\\n    '&quot': '\\\"',\\r\\n    '&apos': '\\\\'',\\r\\n    '&amp': '&',\\r\\n    '&lt;': '<',\\r\\n    '&gt;': '>',\\r\\n    '&quot;': '\\\"',\\r\\n    '&apos;': '\\\\'',\\r\\n    '&amp;': '&'\\r\\n};\\r\\n\\r\\nvar CHAR_INDEX = {\\r\\n    60: 'lt',\\r\\n    62: 'gt',\\r\\n    34: 'quot',\\r\\n    39: 'apos',\\r\\n    38: 'amp'\\r\\n};\\r\\n\\r\\nvar CHAR_S_INDEX = {\\r\\n    '<': '&lt;',\\r\\n    '>': '&gt;',\\r\\n    '\\\"': '&quot;',\\r\\n    '\\\\'': '&apos;',\\r\\n    '&': '&amp;'\\r\\n};\\r\\n\\r\\n/**\\r\\n * @constructor\\r\\n */\\r\\nfunction XmlEntities() {}\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nXmlEntities.prototype.encode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    return str.replace(/<|>|\\\"|'|&/g, function(s) {\\r\\n        return CHAR_S_INDEX[s];\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n XmlEntities.encode = function(str) {\\r\\n    return new XmlEntities().encode(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nXmlEntities.prototype.decode = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {\\r\\n        if (s.charAt(1) === '#') {\\r\\n            var code = s.charAt(2).toLowerCase() === 'x' ?\\r\\n                parseInt(s.substr(3), 16) :\\r\\n                parseInt(s.substr(2));\\r\\n\\r\\n            if (isNaN(code) || code < -32768 || code > 65535) {\\r\\n                return '';\\r\\n            }\\r\\n            return String.fromCharCode(code);\\r\\n        }\\r\\n        return ALPHA_INDEX[s] || s;\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n XmlEntities.decode = function(str) {\\r\\n    return new XmlEntities().decode(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nXmlEntities.prototype.encodeNonUTF = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLength = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLength) {\\r\\n        var c = str.charCodeAt(i);\\r\\n        var alpha = CHAR_INDEX[c];\\r\\n        if (alpha) {\\r\\n            result += \\\"&\\\" + alpha + \\\";\\\";\\r\\n            i++;\\r\\n            continue;\\r\\n        }\\r\\n        if (c < 32 || c > 126) {\\r\\n            result += '&#' + c + ';';\\r\\n        } else {\\r\\n            result += str.charAt(i);\\r\\n        }\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n XmlEntities.encodeNonUTF = function(str) {\\r\\n    return new XmlEntities().encodeNonUTF(str);\\r\\n };\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\nXmlEntities.prototype.encodeNonASCII = function(str) {\\r\\n    if (!str || !str.length) {\\r\\n        return '';\\r\\n    }\\r\\n    var strLenght = str.length;\\r\\n    var result = '';\\r\\n    var i = 0;\\r\\n    while (i < strLenght) {\\r\\n        var c = str.charCodeAt(i);\\r\\n        if (c <= 255) {\\r\\n            result += str[i++];\\r\\n            continue;\\r\\n        }\\r\\n        result += '&#' + c + ';';\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * @param {String} str\\r\\n * @returns {String}\\r\\n */\\r\\n XmlEntities.encodeNonASCII = function(str) {\\r\\n    return new XmlEntities().encodeNonASCII(str);\\r\\n };\\r\\n\\r\\nmodule.exports = XmlEntities;\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzPzUwMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXO0FBQ1gsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEFMUEhBX0lOREVYID0ge1xyXG4gICAgJyZsdCc6ICc8JyxcclxuICAgICcmZ3QnOiAnPicsXHJcbiAgICAnJnF1b3QnOiAnXCInLFxyXG4gICAgJyZhcG9zJzogJ1xcJycsXHJcbiAgICAnJmFtcCc6ICcmJyxcclxuICAgICcmbHQ7JzogJzwnLFxyXG4gICAgJyZndDsnOiAnPicsXHJcbiAgICAnJnF1b3Q7JzogJ1wiJyxcclxuICAgICcmYXBvczsnOiAnXFwnJyxcclxuICAgICcmYW1wOyc6ICcmJ1xyXG59O1xyXG5cclxudmFyIENIQVJfSU5ERVggPSB7XHJcbiAgICA2MDogJ2x0JyxcclxuICAgIDYyOiAnZ3QnLFxyXG4gICAgMzQ6ICdxdW90JyxcclxuICAgIDM5OiAnYXBvcycsXHJcbiAgICAzODogJ2FtcCdcclxufTtcclxuXHJcbnZhciBDSEFSX1NfSU5ERVggPSB7XHJcbiAgICAnPCc6ICcmbHQ7JyxcclxuICAgICc+JzogJyZndDsnLFxyXG4gICAgJ1wiJzogJyZxdW90OycsXHJcbiAgICAnXFwnJzogJyZhcG9zOycsXHJcbiAgICAnJic6ICcmYW1wOydcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvPHw+fFwifCd8Ji9nLCBmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbiBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcclxuIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcclxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcclxuIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xyXG4gICAgICAgIGlmIChhbHBoYSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcclxuIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcclxuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xyXG4gfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///35\\n\")},function(module,exports,__webpack_require__){eval(\"module.exports = {\\r\\n  XmlEntities: __webpack_require__(35),\\r\\n  Html4Entities: __webpack_require__(34),\\r\\n  Html5Entities: __webpack_require__(15),\\r\\n  AllHtmlEntities: __webpack_require__(15)\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9pbmRleC5qcz84MmM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLEVBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLEVBQXlCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLEVBQXlCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLEVBQXlCO0FBQ3BEIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxyXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXHJcbiAgSHRtbDVFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKSxcclxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///36\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\n\\r\\nmodule.exports = ansiHTML\\r\\n\\r\\n// Reference to https://github.com/sindresorhus/ansi-regex\\r\\nvar _regANSI = /(?:(?:\\\\u001b\\\\[)|\\\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\\\u001b[A-M]/\\r\\n\\r\\nvar _defColors = {\\r\\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\\r\\n  black: '000',\\r\\n  red: 'ff0000',\\r\\n  green: '209805',\\r\\n  yellow: 'e8bf03',\\r\\n  blue: '0000ff',\\r\\n  magenta: 'ff00ff',\\r\\n  cyan: '00ffee',\\r\\n  lightgrey: 'f0f0f0',\\r\\n  darkgrey: '888'\\r\\n}\\r\\nvar _styles = {\\r\\n  30: 'black',\\r\\n  31: 'red',\\r\\n  32: 'green',\\r\\n  33: 'yellow',\\r\\n  34: 'blue',\\r\\n  35: 'magenta',\\r\\n  36: 'cyan',\\r\\n  37: 'lightgrey'\\r\\n}\\r\\nvar _openTags = {\\r\\n  '1': 'font-weight:bold', // bold\\r\\n  '2': 'opacity:0.5', // dim\\r\\n  '3': '<i>', // italic\\r\\n  '4': '<u>', // underscore\\r\\n  '8': 'display:none', // hidden\\r\\n  '9': '<del>' // delete\\r\\n}\\r\\nvar _closeTags = {\\r\\n  '23': '</i>', // reset italic\\r\\n  '24': '</u>', // reset underscore\\r\\n  '29': '</del>' // reset delete\\r\\n}\\r\\n\\r\\n;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\\r\\n  _closeTags[n] = '</span>'\\r\\n})\\r\\n\\r\\n/**\\r\\n * Converts text with ANSI color codes to HTML markup.\\r\\n * @param {String} text\\r\\n * @returns {*}\\r\\n */\\r\\nfunction ansiHTML (text) {\\r\\n  // Returns the text if the string has no ANSI escape code.\\r\\n  if (!_regANSI.test(text)) {\\r\\n    return text\\r\\n  }\\r\\n\\r\\n  // Cache opened sequence.\\r\\n  var ansiCodes = []\\r\\n  // Replace with markup.\\r\\n  var ret = text.replace(/\\\\033\\\\[(\\\\d+)*m/g, function (match, seq) {\\r\\n    var ot = _openTags[seq]\\r\\n    if (ot) {\\r\\n      // If current sequence has been opened, close it.\\r\\n      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast\\r\\n        ansiCodes.pop()\\r\\n        return '</span>'\\r\\n      }\\r\\n      // Open tag.\\r\\n      ansiCodes.push(seq)\\r\\n      return ot[0] === '<' ? ot : '<span style=\\\"' + ot + ';\\\">'\\r\\n    }\\r\\n\\r\\n    var ct = _closeTags[seq]\\r\\n    if (ct) {\\r\\n      // Pop sequence\\r\\n      ansiCodes.pop()\\r\\n      return ct\\r\\n    }\\r\\n    return ''\\r\\n  })\\r\\n\\r\\n  // Make sure tags are closed.\\r\\n  var l = ansiCodes.length\\r\\n  ;(l > 0) && (ret += Array(l + 1).join('</span>'))\\r\\n\\r\\n  return ret\\r\\n}\\r\\n\\r\\n/**\\r\\n * Customize colors.\\r\\n * @param {Object} colors reference to _defColors\\r\\n */\\r\\nansiHTML.setColors = function (colors) {\\r\\n  if (typeof colors !== 'object') {\\r\\n    throw new Error('`colors` parameter must be an Object.')\\r\\n  }\\r\\n\\r\\n  var _finalColors = {}\\r\\n  for (var key in _defColors) {\\r\\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null\\r\\n    if (!hex) {\\r\\n      _finalColors[key] = _defColors[key]\\r\\n      continue\\r\\n    }\\r\\n    if ('reset' === key) {\\r\\n      if (typeof hex === 'string') {\\r\\n        hex = [hex]\\r\\n      }\\r\\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\\r\\n        return typeof h !== 'string'\\r\\n      })) {\\r\\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')\\r\\n      }\\r\\n      var defHexColor = _defColors[key]\\r\\n      if (!hex[0]) {\\r\\n        hex[0] = defHexColor[0]\\r\\n      }\\r\\n      if (hex.length === 1 || !hex[1]) {\\r\\n        hex = [hex[0]]\\r\\n        hex.push(defHexColor[1])\\r\\n      }\\r\\n\\r\\n      hex = hex.slice(0, 2)\\r\\n    } else if (typeof hex !== 'string') {\\r\\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')\\r\\n    }\\r\\n    _finalColors[key] = hex\\r\\n  }\\r\\n  _setTags(_finalColors)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Reset colors.\\r\\n */\\r\\nansiHTML.reset = function () {\\r\\n  _setTags(_defColors)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Expose tags, including open and close.\\r\\n * @type {Object}\\r\\n */\\r\\nansiHTML.tags = {}\\r\\n\\r\\nif (Object.defineProperty) {\\r\\n  Object.defineProperty(ansiHTML.tags, 'open', {\\r\\n    get: function () { return _openTags }\\r\\n  })\\r\\n  Object.defineProperty(ansiHTML.tags, 'close', {\\r\\n    get: function () { return _closeTags }\\r\\n  })\\r\\n} else {\\r\\n  ansiHTML.tags.open = _openTags\\r\\n  ansiHTML.tags.close = _closeTags\\r\\n}\\r\\n\\r\\nfunction _setTags (colors) {\\r\\n  // reset all\\r\\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]\\r\\n  // inverse\\r\\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]\\r\\n  // dark grey\\r\\n  _openTags['90'] = 'color:#' + colors.darkgrey\\r\\n\\r\\n  for (var code in _styles) {\\r\\n    var color = _styles[code]\\r\\n    var oriColor = colors[color] || '000'\\r\\n    _openTags[code] = 'color:#' + oriColor\\r\\n    code = parseInt(code)\\r\\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor\\r\\n  }\\r\\n}\\r\\n\\r\\nansiHTML.reset()\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzPzRlMWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQSxtREFBbUQsSUFBSSxTQUFTLE1BQU0sSUFBSTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsK0JBQStCO0FBQ2hGO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxyXG5cclxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxyXG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cclxuXHJcbnZhciBfZGVmQ29sb3JzID0ge1xyXG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cclxuICBibGFjazogJzAwMCcsXHJcbiAgcmVkOiAnZmYwMDAwJyxcclxuICBncmVlbjogJzIwOTgwNScsXHJcbiAgeWVsbG93OiAnZThiZjAzJyxcclxuICBibHVlOiAnMDAwMGZmJyxcclxuICBtYWdlbnRhOiAnZmYwMGZmJyxcclxuICBjeWFuOiAnMDBmZmVlJyxcclxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxyXG4gIGRhcmtncmV5OiAnODg4J1xyXG59XHJcbnZhciBfc3R5bGVzID0ge1xyXG4gIDMwOiAnYmxhY2snLFxyXG4gIDMxOiAncmVkJyxcclxuICAzMjogJ2dyZWVuJyxcclxuICAzMzogJ3llbGxvdycsXHJcbiAgMzQ6ICdibHVlJyxcclxuICAzNTogJ21hZ2VudGEnLFxyXG4gIDM2OiAnY3lhbicsXHJcbiAgMzc6ICdsaWdodGdyZXknXHJcbn1cclxudmFyIF9vcGVuVGFncyA9IHtcclxuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxyXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXHJcbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXHJcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxyXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxyXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcclxufVxyXG52YXIgX2Nsb3NlVGFncyA9IHtcclxuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xyXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxyXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxyXG59XHJcblxyXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcclxuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXHJcbn0pXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcclxuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXHJcbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XHJcbiAgICByZXR1cm4gdGV4dFxyXG4gIH1cclxuXHJcbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxyXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxyXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXHJcbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xyXG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cclxuICAgIGlmIChvdCkge1xyXG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXHJcbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XHJcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXHJcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xyXG4gICAgICB9XHJcbiAgICAgIC8vIE9wZW4gdGFnLlxyXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXHJcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cclxuICAgIGlmIChjdCkge1xyXG4gICAgICAvLyBQb3Agc2VxdWVuY2VcclxuICAgICAgYW5zaUNvZGVzLnBvcCgpXHJcbiAgICAgIHJldHVybiBjdFxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnXHJcbiAgfSlcclxuXHJcbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cclxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcclxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXHJcblxyXG4gIHJldHVybiByZXRcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcclxuICovXHJcbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcclxuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXHJcbiAgfVxyXG5cclxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cclxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xyXG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXHJcbiAgICBpZiAoIWhleCkge1xyXG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xyXG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBoZXggPSBbaGV4XVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXHJcbiAgICAgIH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXHJcbiAgICAgIGlmICghaGV4WzBdKSB7XHJcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XHJcbiAgICAgICAgaGV4ID0gW2hleFswXV1cclxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcclxuICAgICAgfVxyXG5cclxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXHJcbiAgICB9XHJcbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxyXG4gIH1cclxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldCBjb2xvcnMuXHJcbiAqL1xyXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxyXG59XHJcblxyXG4vKipcclxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmFuc2lIVE1MLnRhZ3MgPSB7fVxyXG5cclxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cclxuICB9KVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxyXG4gIH0pXHJcbn0gZWxzZSB7XHJcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXHJcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3NcclxufVxyXG5cclxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xyXG4gIC8vIHJlc2V0IGFsbFxyXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cclxuICAvLyBpbnZlcnNlXHJcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cclxuICAvLyBkYXJrIGdyZXlcclxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcclxuXHJcbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXHJcbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXHJcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxyXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXHJcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXHJcbiAgfVxyXG59XHJcblxyXG5hbnNpSFRNTC5yZXNldCgpXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///37\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\n\\r\\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\\r\\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\\r\\n\\r\\nvar ansiHTML = __webpack_require__(37);\\r\\nvar Entities = __webpack_require__(36).AllHtmlEntities;\\r\\n\\r\\nvar entities = new Entities();\\r\\n\\r\\nvar colors = {\\r\\n  reset: ['transparent', 'transparent'],\\r\\n  black: '181818',\\r\\n  red: 'E36049',\\r\\n  green: 'B3CB74',\\r\\n  yellow: 'FFD080',\\r\\n  blue: '7CAFC2',\\r\\n  magenta: '7FACCA',\\r\\n  cyan: 'C3C2EF',\\r\\n  lightgrey: 'EBE7E3',\\r\\n  darkgrey: '6D7891'\\r\\n};\\r\\nansiHTML.setColors(colors);\\r\\n\\r\\nfunction createOverlayIframe(onIframeLoad) {\\r\\n  var iframe = document.createElement('iframe');\\r\\n  iframe.id = 'webpack-dev-server-client-overlay';\\r\\n  iframe.src = 'about:blank';\\r\\n  iframe.style.position = 'fixed';\\r\\n  iframe.style.left = 0;\\r\\n  iframe.style.top = 0;\\r\\n  iframe.style.right = 0;\\r\\n  iframe.style.bottom = 0;\\r\\n  iframe.style.width = '100vw';\\r\\n  iframe.style.height = '100vh';\\r\\n  iframe.style.border = 'none';\\r\\n  iframe.style.zIndex = 9999999999;\\r\\n  iframe.onload = onIframeLoad;\\r\\n  return iframe;\\r\\n}\\r\\n\\r\\nfunction addOverlayDivTo(iframe) {\\r\\n  var div = iframe.contentDocument.createElement('div');\\r\\n  div.id = 'webpack-dev-server-client-overlay-div';\\r\\n  div.style.position = 'fixed';\\r\\n  div.style.boxSizing = 'border-box';\\r\\n  div.style.left = 0;\\r\\n  div.style.top = 0;\\r\\n  div.style.right = 0;\\r\\n  div.style.bottom = 0;\\r\\n  div.style.width = '100vw';\\r\\n  div.style.height = '100vh';\\r\\n  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\\r\\n  div.style.color = '#E8E8E8';\\r\\n  div.style.fontFamily = 'Menlo, Consolas, monospace';\\r\\n  div.style.fontSize = 'large';\\r\\n  div.style.padding = '2rem';\\r\\n  div.style.lineHeight = '1.2';\\r\\n  div.style.whiteSpace = 'pre-wrap';\\r\\n  div.style.overflow = 'auto';\\r\\n  iframe.contentDocument.body.appendChild(div);\\r\\n  return div;\\r\\n}\\r\\n\\r\\nvar overlayIframe = null;\\r\\nvar overlayDiv = null;\\r\\nvar lastOnOverlayDivReady = null;\\r\\n\\r\\nfunction ensureOverlayDivExists(onOverlayDivReady) {\\r\\n  if (overlayDiv) {\\r\\n    // Everything is ready, call the callback right away.\\r\\n    onOverlayDivReady(overlayDiv);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Creating an iframe may be asynchronous so we'll schedule the callback.\\r\\n  // In case of multiple calls, last callback wins.\\r\\n  lastOnOverlayDivReady = onOverlayDivReady;\\r\\n\\r\\n  if (overlayIframe) {\\r\\n    // We're already creating it.\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Create iframe and, when it is ready, a div inside it.\\r\\n  overlayIframe = createOverlayIframe(function () {\\r\\n    overlayDiv = addOverlayDivTo(overlayIframe);\\r\\n    // Now we can talk!\\r\\n    lastOnOverlayDivReady(overlayDiv);\\r\\n  });\\r\\n\\r\\n  // Zalgo alert: onIframeLoad() will be called either synchronously\\r\\n  // or asynchronously depending on the browser.\\r\\n  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.\\r\\n  document.body.appendChild(overlayIframe);\\r\\n}\\r\\n\\r\\nfunction showMessageOverlay(message) {\\r\\n  ensureOverlayDivExists(function (div) {\\r\\n    // Make it look similar to our terminal.\\r\\n    div.innerHTML = '<span style=\\\"color: #' + colors.red + '\\\">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));\\r\\n  });\\r\\n}\\r\\n\\r\\nfunction destroyErrorOverlay() {\\r\\n  if (!overlayDiv) {\\r\\n    // It is not there in the first place.\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Clean up and reset internal state.\\r\\n  document.body.removeChild(overlayIframe);\\r\\n  overlayDiv = null;\\r\\n  overlayIframe = null;\\r\\n  lastOnOverlayDivReady = null;\\r\\n}\\r\\n\\r\\n// Successful compilation.\\r\\nexports.clear = function handleSuccess() {\\r\\n  destroyErrorOverlay();\\r\\n};\\r\\n\\r\\n// Compilation with errors (e.g. syntax error or missing modules).\\r\\nexports.showMessage = function handleMessage(messages) {\\r\\n  showMessageOverlay(messages[0]);\\r\\n};\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanM/MmFjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxFQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxFQUFlOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxyXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cclxuXHJcbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xyXG52YXIgRW50aXRpZXMgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJykuQWxsSHRtbEVudGl0aWVzO1xyXG5cclxudmFyIGVudGl0aWVzID0gbmV3IEVudGl0aWVzKCk7XHJcblxyXG52YXIgY29sb3JzID0ge1xyXG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXHJcbiAgYmxhY2s6ICcxODE4MTgnLFxyXG4gIHJlZDogJ0UzNjA0OScsXHJcbiAgZ3JlZW46ICdCM0NCNzQnLFxyXG4gIHllbGxvdzogJ0ZGRDA4MCcsXHJcbiAgYmx1ZTogJzdDQUZDMicsXHJcbiAgbWFnZW50YTogJzdGQUNDQScsXHJcbiAgY3lhbjogJ0MzQzJFRicsXHJcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcclxuICBkYXJrZ3JleTogJzZENzg5MSdcclxufTtcclxuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xyXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcclxuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcclxuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcclxuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcclxuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xyXG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xyXG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XHJcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XHJcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcclxuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcclxuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xyXG4gIHJldHVybiBpZnJhbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcclxuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XHJcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xyXG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcclxuICBkaXYuc3R5bGUudG9wID0gMDtcclxuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xyXG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XHJcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XHJcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcclxuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XHJcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xyXG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XHJcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XHJcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcclxuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XHJcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xyXG4gIHJldHVybiBkaXY7XHJcbn1cclxuXHJcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcclxudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xyXG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcclxuICBpZiAob3ZlcmxheURpdikge1xyXG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cclxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxyXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cclxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcclxuXHJcbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcclxuICAgIC8vIFdlJ3JlIGFscmVhZHkgY3JlYXRpbmcgaXQuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxyXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7XHJcbiAgICAvLyBOb3cgd2UgY2FuIHRhbGshXHJcbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxyXG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cclxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dNZXNzYWdlT3ZlcmxheShtZXNzYWdlKSB7XHJcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XHJcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXHJcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiY29sb3I6ICMnICsgY29sb3JzLnJlZCArICdcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj4nICsgYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2UpKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzdHJveUVycm9yT3ZlcmxheSgpIHtcclxuICBpZiAoIW92ZXJsYXlEaXYpIHtcclxuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXHJcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcclxuICBvdmVybGF5RGl2ID0gbnVsbDtcclxuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcclxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xyXG59XHJcblxyXG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxyXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcclxuICBkZXN0cm95RXJyb3JPdmVybGF5KCk7XHJcbn07XHJcblxyXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cclxuZXhwb3J0cy5zaG93TWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZXMpIHtcclxuICBzaG93TWVzc2FnZU92ZXJsYXkobWVzc2FnZXNbMF0pO1xyXG59OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///38\\n\")},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */\\r\\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\\\"function\\\"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\\\"function\\\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar transportList = require('./transport-list');\\r\\n\\r\\nmodule.exports = require('./main')(transportList);\\r\\n\\r\\n// TODO can't get rid of this until all servers do\\r\\nif ('_sockjs_onload' in global) {\\r\\n  setTimeout(global._sockjs_onload, 1);\\r\\n}\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./main\\\":14,\\\"./transport-list\\\":16}],2:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , Event = require('./event')\\r\\n  ;\\r\\n\\r\\nfunction CloseEvent() {\\r\\n  Event.call(this);\\r\\n  this.initEvent('close', false, false);\\r\\n  this.wasClean = false;\\r\\n  this.code = 0;\\r\\n  this.reason = '';\\r\\n}\\r\\n\\r\\ninherits(CloseEvent, Event);\\r\\n\\r\\nmodule.exports = CloseEvent;\\r\\n\\r\\n},{\\\"./event\\\":4,\\\"inherits\\\":57}],3:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventTarget = require('./eventtarget')\\r\\n  ;\\r\\n\\r\\nfunction EventEmitter() {\\r\\n  EventTarget.call(this);\\r\\n}\\r\\n\\r\\ninherits(EventEmitter, EventTarget);\\r\\n\\r\\nEventEmitter.prototype.removeAllListeners = function(type) {\\r\\n  if (type) {\\r\\n    delete this._listeners[type];\\r\\n  } else {\\r\\n    this._listeners = {};\\r\\n  }\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.once = function(type, listener) {\\r\\n  var self = this\\r\\n    , fired = false;\\r\\n\\r\\n  function g() {\\r\\n    self.removeListener(type, g);\\r\\n\\r\\n    if (!fired) {\\r\\n      fired = true;\\r\\n      listener.apply(this, arguments);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.on(type, g);\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.emit = function() {\\r\\n  var type = arguments[0];\\r\\n  var listeners = this._listeners[type];\\r\\n  if (!listeners) {\\r\\n    return;\\r\\n  }\\r\\n  // equivalent of Array.prototype.slice.call(arguments, 1);\\r\\n  var l = arguments.length;\\r\\n  var args = new Array(l - 1);\\r\\n  for (var ai = 1; ai < l; ai++) {\\r\\n    args[ai - 1] = arguments[ai];\\r\\n  }\\r\\n  for (var i = 0; i < listeners.length; i++) {\\r\\n    listeners[i].apply(this, args);\\r\\n  }\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\\r\\nEventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\\r\\n\\r\\nmodule.exports.EventEmitter = EventEmitter;\\r\\n\\r\\n},{\\\"./eventtarget\\\":5,\\\"inherits\\\":57}],4:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nfunction Event(eventType) {\\r\\n  this.type = eventType;\\r\\n}\\r\\n\\r\\nEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\\r\\n  this.type = eventType;\\r\\n  this.bubbles = canBubble;\\r\\n  this.cancelable = cancelable;\\r\\n  this.timeStamp = +new Date();\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEvent.prototype.stopPropagation = function() {};\\r\\nEvent.prototype.preventDefault = function() {};\\r\\n\\r\\nEvent.CAPTURING_PHASE = 1;\\r\\nEvent.AT_TARGET = 2;\\r\\nEvent.BUBBLING_PHASE = 3;\\r\\n\\r\\nmodule.exports = Event;\\r\\n\\r\\n},{}],5:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\n/* Simplified implementation of DOM2 EventTarget.\\r\\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\\r\\n */\\r\\n\\r\\nfunction EventTarget() {\\r\\n  this._listeners = {};\\r\\n}\\r\\n\\r\\nEventTarget.prototype.addEventListener = function(eventType, listener) {\\r\\n  if (!(eventType in this._listeners)) {\\r\\n    this._listeners[eventType] = [];\\r\\n  }\\r\\n  var arr = this._listeners[eventType];\\r\\n  // #4\\r\\n  if (arr.indexOf(listener) === -1) {\\r\\n    // Make a copy so as not to interfere with a current dispatchEvent.\\r\\n    arr = arr.concat([listener]);\\r\\n  }\\r\\n  this._listeners[eventType] = arr;\\r\\n};\\r\\n\\r\\nEventTarget.prototype.removeEventListener = function(eventType, listener) {\\r\\n  var arr = this._listeners[eventType];\\r\\n  if (!arr) {\\r\\n    return;\\r\\n  }\\r\\n  var idx = arr.indexOf(listener);\\r\\n  if (idx !== -1) {\\r\\n    if (arr.length > 1) {\\r\\n      // Make a copy so as not to interfere with a current dispatchEvent.\\r\\n      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\\r\\n    } else {\\r\\n      delete this._listeners[eventType];\\r\\n    }\\r\\n    return;\\r\\n  }\\r\\n};\\r\\n\\r\\nEventTarget.prototype.dispatchEvent = function() {\\r\\n  var event = arguments[0];\\r\\n  var t = event.type;\\r\\n  // equivalent of Array.prototype.slice.call(arguments, 0);\\r\\n  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\\r\\n  // TODO: This doesn't match the real behavior; per spec, onfoo get\\r\\n  // their place in line from the /first/ time they're set from\\r\\n  // non-null. Although WebKit bumps it to the end every time it's\\r\\n  // set.\\r\\n  if (this['on' + t]) {\\r\\n    this['on' + t].apply(this, args);\\r\\n  }\\r\\n  if (t in this._listeners) {\\r\\n    // Grab a reference to the listeners list. removeEventListener may alter the list.\\r\\n    var listeners = this._listeners[t];\\r\\n    for (var i = 0; i < listeners.length; i++) {\\r\\n      listeners[i].apply(this, args);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = EventTarget;\\r\\n\\r\\n},{}],6:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , Event = require('./event')\\r\\n  ;\\r\\n\\r\\nfunction TransportMessageEvent(data) {\\r\\n  Event.call(this);\\r\\n  this.initEvent('message', false, false);\\r\\n  this.data = data;\\r\\n}\\r\\n\\r\\ninherits(TransportMessageEvent, Event);\\r\\n\\r\\nmodule.exports = TransportMessageEvent;\\r\\n\\r\\n},{\\\"./event\\\":4,\\\"inherits\\\":57}],7:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar JSON3 = require('json3')\\r\\n  , iframeUtils = require('./utils/iframe')\\r\\n  ;\\r\\n\\r\\nfunction FacadeJS(transport) {\\r\\n  this._transport = transport;\\r\\n  transport.on('message', this._transportMessage.bind(this));\\r\\n  transport.on('close', this._transportClose.bind(this));\\r\\n}\\r\\n\\r\\nFacadeJS.prototype._transportClose = function(code, reason) {\\r\\n  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\\r\\n};\\r\\nFacadeJS.prototype._transportMessage = function(frame) {\\r\\n  iframeUtils.postMessage('t', frame);\\r\\n};\\r\\nFacadeJS.prototype._send = function(data) {\\r\\n  this._transport.send(data);\\r\\n};\\r\\nFacadeJS.prototype._close = function() {\\r\\n  this._transport.close();\\r\\n  this._transport.removeAllListeners();\\r\\n};\\r\\n\\r\\nmodule.exports = FacadeJS;\\r\\n\\r\\n},{\\\"./utils/iframe\\\":47,\\\"json3\\\":58}],8:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar urlUtils = require('./utils/url')\\r\\n  , eventUtils = require('./utils/event')\\r\\n  , JSON3 = require('json3')\\r\\n  , FacadeJS = require('./facade')\\r\\n  , InfoIframeReceiver = require('./info-iframe-receiver')\\r\\n  , iframeUtils = require('./utils/iframe')\\r\\n  , loc = require('./location')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:iframe-bootstrap');\\r\\n}\\r\\n\\r\\nmodule.exports = function(SockJS, availableTransports) {\\r\\n  var transportMap = {};\\r\\n  availableTransports.forEach(function(at) {\\r\\n    if (at.facadeTransport) {\\r\\n      transportMap[at.facadeTransport.transportName] = at.facadeTransport;\\r\\n    }\\r\\n  });\\r\\n\\r\\n  // hard-coded for the info iframe\\r\\n  // TODO see if we can make this more dynamic\\r\\n  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\\r\\n  var parentOrigin;\\r\\n\\r\\n  /* eslint-disable camelcase */\\r\\n  SockJS.bootstrap_iframe = function() {\\r\\n    /* eslint-enable camelcase */\\r\\n    var facade;\\r\\n    iframeUtils.currentWindowId = loc.hash.slice(1);\\r\\n    var onMessage = function(e) {\\r\\n      if (e.source !== parent) {\\r\\n        return;\\r\\n      }\\r\\n      if (typeof parentOrigin === 'undefined') {\\r\\n        parentOrigin = e.origin;\\r\\n      }\\r\\n      if (e.origin !== parentOrigin) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      var iframeMessage;\\r\\n      try {\\r\\n        iframeMessage = JSON3.parse(e.data);\\r\\n      } catch (ignored) {\\r\\n        debug('bad json', e.data);\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\\r\\n        return;\\r\\n      }\\r\\n      switch (iframeMessage.type) {\\r\\n      case 's':\\r\\n        var p;\\r\\n        try {\\r\\n          p = JSON3.parse(iframeMessage.data);\\r\\n        } catch (ignored) {\\r\\n          debug('bad json', iframeMessage.data);\\r\\n          break;\\r\\n        }\\r\\n        var version = p[0];\\r\\n        var transport = p[1];\\r\\n        var transUrl = p[2];\\r\\n        var baseUrl = p[3];\\r\\n        debug(version, transport, transUrl, baseUrl);\\r\\n        // change this to semver logic\\r\\n        if (version !== SockJS.version) {\\r\\n          throw new Error('Incompatible SockJS! Main site uses:' +\\r\\n                    ' \\\"' + version + '\\\", the iframe:' +\\r\\n                    ' \\\"' + SockJS.version + '\\\".');\\r\\n        }\\r\\n\\r\\n        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||\\r\\n            !urlUtils.isOriginEqual(baseUrl, loc.href)) {\\r\\n          throw new Error('Can\\\\'t connect to different domain from within an ' +\\r\\n                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\\r\\n        }\\r\\n        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\\r\\n        break;\\r\\n      case 'm':\\r\\n        facade._send(iframeMessage.data);\\r\\n        break;\\r\\n      case 'c':\\r\\n        if (facade) {\\r\\n          facade._close();\\r\\n        }\\r\\n        facade = null;\\r\\n        break;\\r\\n      }\\r\\n    };\\r\\n\\r\\n    eventUtils.attachEvent('message', onMessage);\\r\\n\\r\\n    // Start\\r\\n    iframeUtils.postMessage('s');\\r\\n  };\\r\\n};\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"./facade\\\":7,\\\"./info-iframe-receiver\\\":10,\\\"./location\\\":13,\\\"./utils/event\\\":46,\\\"./utils/iframe\\\":47,\\\"./utils/url\\\":52,\\\"debug\\\":55,\\\"json3\\\":58}],9:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  , JSON3 = require('json3')\\r\\n  , objectUtils = require('./utils/object')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:info-ajax');\\r\\n}\\r\\n\\r\\nfunction InfoAjax(url, AjaxObject) {\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n  var t0 = +new Date();\\r\\n  this.xo = new AjaxObject('GET', url);\\r\\n\\r\\n  this.xo.once('finish', function(status, text) {\\r\\n    var info, rtt;\\r\\n    if (status === 200) {\\r\\n      rtt = (+new Date()) - t0;\\r\\n      if (text) {\\r\\n        try {\\r\\n          info = JSON3.parse(text);\\r\\n        } catch (e) {\\r\\n          debug('bad json', text);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (!objectUtils.isObject(info)) {\\r\\n        info = {};\\r\\n      }\\r\\n    }\\r\\n    self.emit('finish', info, rtt);\\r\\n    self.removeAllListeners();\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(InfoAjax, EventEmitter);\\r\\n\\r\\nInfoAjax.prototype.close = function() {\\r\\n  this.removeAllListeners();\\r\\n  this.xo.close();\\r\\n};\\r\\n\\r\\nmodule.exports = InfoAjax;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"./utils/object\\\":49,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],10:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  , JSON3 = require('json3')\\r\\n  , XHRLocalObject = require('./transport/sender/xhr-local')\\r\\n  , InfoAjax = require('./info-ajax')\\r\\n  ;\\r\\n\\r\\nfunction InfoReceiverIframe(transUrl) {\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  this.ir = new InfoAjax(transUrl, XHRLocalObject);\\r\\n  this.ir.once('finish', function(info, rtt) {\\r\\n    self.ir = null;\\r\\n    self.emit('message', JSON3.stringify([info, rtt]));\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(InfoReceiverIframe, EventEmitter);\\r\\n\\r\\nInfoReceiverIframe.transportName = 'iframe-info-receiver';\\r\\n\\r\\nInfoReceiverIframe.prototype.close = function() {\\r\\n  if (this.ir) {\\r\\n    this.ir.close();\\r\\n    this.ir = null;\\r\\n  }\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nmodule.exports = InfoReceiverIframe;\\r\\n\\r\\n},{\\\"./info-ajax\\\":9,\\\"./transport/sender/xhr-local\\\":37,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],11:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  , JSON3 = require('json3')\\r\\n  , utils = require('./utils/event')\\r\\n  , IframeTransport = require('./transport/iframe')\\r\\n  , InfoReceiverIframe = require('./info-iframe-receiver')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:info-iframe');\\r\\n}\\r\\n\\r\\nfunction InfoIframe(baseUrl, url) {\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var go = function() {\\r\\n    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\\r\\n\\r\\n    ifr.once('message', function(msg) {\\r\\n      if (msg) {\\r\\n        var d;\\r\\n        try {\\r\\n          d = JSON3.parse(msg);\\r\\n        } catch (e) {\\r\\n          debug('bad json', msg);\\r\\n          self.emit('finish');\\r\\n          self.close();\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        var info = d[0], rtt = d[1];\\r\\n        self.emit('finish', info, rtt);\\r\\n      }\\r\\n      self.close();\\r\\n    });\\r\\n\\r\\n    ifr.once('close', function() {\\r\\n      self.emit('finish');\\r\\n      self.close();\\r\\n    });\\r\\n  };\\r\\n\\r\\n  // TODO this seems the same as the 'needBody' from transports\\r\\n  if (!global.document.body) {\\r\\n    utils.attachEvent('load', go);\\r\\n  } else {\\r\\n    go();\\r\\n  }\\r\\n}\\r\\n\\r\\ninherits(InfoIframe, EventEmitter);\\r\\n\\r\\nInfoIframe.enabled = function() {\\r\\n  return IframeTransport.enabled();\\r\\n};\\r\\n\\r\\nInfoIframe.prototype.close = function() {\\r\\n  if (this.ifr) {\\r\\n    this.ifr.close();\\r\\n  }\\r\\n  this.removeAllListeners();\\r\\n  this.ifr = null;\\r\\n};\\r\\n\\r\\nmodule.exports = InfoIframe;\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./info-iframe-receiver\\\":10,\\\"./transport/iframe\\\":22,\\\"./utils/event\\\":46,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],12:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  , urlUtils = require('./utils/url')\\r\\n  , XDR = require('./transport/sender/xdr')\\r\\n  , XHRCors = require('./transport/sender/xhr-cors')\\r\\n  , XHRLocal = require('./transport/sender/xhr-local')\\r\\n  , XHRFake = require('./transport/sender/xhr-fake')\\r\\n  , InfoIframe = require('./info-iframe')\\r\\n  , InfoAjax = require('./info-ajax')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:info-receiver');\\r\\n}\\r\\n\\r\\nfunction InfoReceiver(baseUrl, urlInfo) {\\r\\n  debug(baseUrl);\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  setTimeout(function() {\\r\\n    self.doXhr(baseUrl, urlInfo);\\r\\n  }, 0);\\r\\n}\\r\\n\\r\\ninherits(InfoReceiver, EventEmitter);\\r\\n\\r\\n// TODO this is currently ignoring the list of available transports and the whitelist\\r\\n\\r\\nInfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {\\r\\n  // determine method of CORS support (if needed)\\r\\n  if (urlInfo.sameOrigin) {\\r\\n    return new InfoAjax(url, XHRLocal);\\r\\n  }\\r\\n  if (XHRCors.enabled) {\\r\\n    return new InfoAjax(url, XHRCors);\\r\\n  }\\r\\n  if (XDR.enabled && urlInfo.sameScheme) {\\r\\n    return new InfoAjax(url, XDR);\\r\\n  }\\r\\n  if (InfoIframe.enabled()) {\\r\\n    return new InfoIframe(baseUrl, url);\\r\\n  }\\r\\n  return new InfoAjax(url, XHRFake);\\r\\n};\\r\\n\\r\\nInfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {\\r\\n  var self = this\\r\\n    , url = urlUtils.addPath(baseUrl, '/info')\\r\\n    ;\\r\\n  debug('doXhr', url);\\r\\n\\r\\n  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\\r\\n\\r\\n  this.timeoutRef = setTimeout(function() {\\r\\n    debug('timeout');\\r\\n    self._cleanup(false);\\r\\n    self.emit('finish');\\r\\n  }, InfoReceiver.timeout);\\r\\n\\r\\n  this.xo.once('finish', function(info, rtt) {\\r\\n    debug('finish', info, rtt);\\r\\n    self._cleanup(true);\\r\\n    self.emit('finish', info, rtt);\\r\\n  });\\r\\n};\\r\\n\\r\\nInfoReceiver.prototype._cleanup = function(wasClean) {\\r\\n  debug('_cleanup');\\r\\n  clearTimeout(this.timeoutRef);\\r\\n  this.timeoutRef = null;\\r\\n  if (!wasClean && this.xo) {\\r\\n    this.xo.close();\\r\\n  }\\r\\n  this.xo = null;\\r\\n};\\r\\n\\r\\nInfoReceiver.prototype.close = function() {\\r\\n  debug('close');\\r\\n  this.removeAllListeners();\\r\\n  this._cleanup(false);\\r\\n};\\r\\n\\r\\nInfoReceiver.timeout = 8000;\\r\\n\\r\\nmodule.exports = InfoReceiver;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"./info-ajax\\\":9,\\\"./info-iframe\\\":11,\\\"./transport/sender/xdr\\\":34,\\\"./transport/sender/xhr-cors\\\":35,\\\"./transport/sender/xhr-fake\\\":36,\\\"./transport/sender/xhr-local\\\":37,\\\"./utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],13:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nmodule.exports = global.location || {\\r\\n  origin: 'http://localhost:80'\\r\\n, protocol: 'http:'\\r\\n, host: 'localhost'\\r\\n, port: 80\\r\\n, href: 'http://localhost/'\\r\\n, hash: ''\\r\\n};\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],14:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nrequire('./shims');\\r\\n\\r\\nvar URL = require('url-parse')\\r\\n  , inherits = require('inherits')\\r\\n  , JSON3 = require('json3')\\r\\n  , random = require('./utils/random')\\r\\n  , escape = require('./utils/escape')\\r\\n  , urlUtils = require('./utils/url')\\r\\n  , eventUtils = require('./utils/event')\\r\\n  , transport = require('./utils/transport')\\r\\n  , objectUtils = require('./utils/object')\\r\\n  , browser = require('./utils/browser')\\r\\n  , log = require('./utils/log')\\r\\n  , Event = require('./event/event')\\r\\n  , EventTarget = require('./event/eventtarget')\\r\\n  , loc = require('./location')\\r\\n  , CloseEvent = require('./event/close')\\r\\n  , TransportMessageEvent = require('./event/trans-message')\\r\\n  , InfoReceiver = require('./info-receiver')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:main');\\r\\n}\\r\\n\\r\\nvar transports;\\r\\n\\r\\n// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\\r\\nfunction SockJS(url, protocols, options) {\\r\\n  if (!(this instanceof SockJS)) {\\r\\n    return new SockJS(url, protocols, options);\\r\\n  }\\r\\n  if (arguments.length < 1) {\\r\\n    throw new TypeError(\\\"Failed to construct 'SockJS: 1 argument required, but only 0 present\\\");\\r\\n  }\\r\\n  EventTarget.call(this);\\r\\n\\r\\n  this.readyState = SockJS.CONNECTING;\\r\\n  this.extensions = '';\\r\\n  this.protocol = '';\\r\\n\\r\\n  // non-standard extension\\r\\n  options = options || {};\\r\\n  if (options.protocols_whitelist) {\\r\\n    log.warn(\\\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\\\");\\r\\n  }\\r\\n  this._transportsWhitelist = options.transports;\\r\\n  this._transportOptions = options.transportOptions || {};\\r\\n\\r\\n  var sessionId = options.sessionId || 8;\\r\\n  if (typeof sessionId === 'function') {\\r\\n    this._generateSessionId = sessionId;\\r\\n  } else if (typeof sessionId === 'number') {\\r\\n    this._generateSessionId = function() {\\r\\n      return random.string(sessionId);\\r\\n    };\\r\\n  } else {\\r\\n    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\\r\\n  }\\r\\n\\r\\n  this._server = options.server || random.numberString(1000);\\r\\n\\r\\n  // Step 1 of WS spec - parse and validate the url. Issue #8\\r\\n  var parsedUrl = new URL(url);\\r\\n  if (!parsedUrl.host || !parsedUrl.protocol) {\\r\\n    throw new SyntaxError(\\\"The URL '\\\" + url + \\\"' is invalid\\\");\\r\\n  } else if (parsedUrl.hash) {\\r\\n    throw new SyntaxError('The URL must not contain a fragment');\\r\\n  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\\r\\n    throw new SyntaxError(\\\"The URL's scheme must be either 'http:' or 'https:'. '\\\" + parsedUrl.protocol + \\\"' is not allowed.\\\");\\r\\n  }\\r\\n\\r\\n  var secure = parsedUrl.protocol === 'https:';\\r\\n  // Step 2 - don't allow secure origin with an insecure protocol\\r\\n  if (loc.protocol === 'https:' && !secure) {\\r\\n    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\\r\\n  }\\r\\n\\r\\n  // Step 3 - check port access - no need here\\r\\n  // Step 4 - parse protocols argument\\r\\n  if (!protocols) {\\r\\n    protocols = [];\\r\\n  } else if (!Array.isArray(protocols)) {\\r\\n    protocols = [protocols];\\r\\n  }\\r\\n\\r\\n  // Step 5 - check protocols argument\\r\\n  var sortedProtocols = protocols.sort();\\r\\n  sortedProtocols.forEach(function(proto, i) {\\r\\n    if (!proto) {\\r\\n      throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is invalid.\\\");\\r\\n    }\\r\\n    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {\\r\\n      throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is duplicated.\\\");\\r\\n    }\\r\\n  });\\r\\n\\r\\n  // Step 6 - convert origin\\r\\n  var o = urlUtils.getOrigin(loc.href);\\r\\n  this._origin = o ? o.toLowerCase() : null;\\r\\n\\r\\n  // remove the trailing slash\\r\\n  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\\\/+$/, ''));\\r\\n\\r\\n  // store the sanitized url\\r\\n  this.url = parsedUrl.href;\\r\\n  debug('using url', this.url);\\r\\n\\r\\n  // Step 7 - start connection in background\\r\\n  // obtain server info\\r\\n  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\\r\\n  this._urlInfo = {\\r\\n    nullOrigin: !browser.hasDomain()\\r\\n  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)\\r\\n  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\\r\\n  };\\r\\n\\r\\n  this._ir = new InfoReceiver(this.url, this._urlInfo);\\r\\n  this._ir.once('finish', this._receiveInfo.bind(this));\\r\\n}\\r\\n\\r\\ninherits(SockJS, EventTarget);\\r\\n\\r\\nfunction userSetCode(code) {\\r\\n  return code === 1000 || (code >= 3000 && code <= 4999);\\r\\n}\\r\\n\\r\\nSockJS.prototype.close = function(code, reason) {\\r\\n  // Step 1\\r\\n  if (code && !userSetCode(code)) {\\r\\n    throw new Error('InvalidAccessError: Invalid code');\\r\\n  }\\r\\n  // Step 2.4 states the max is 123 bytes, but we are just checking length\\r\\n  if (reason && reason.length > 123) {\\r\\n    throw new SyntaxError('reason argument has an invalid length');\\r\\n  }\\r\\n\\r\\n  // Step 3.1\\r\\n  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // TODO look at docs to determine how to set this\\r\\n  var wasClean = true;\\r\\n  this._close(code || 1000, reason || 'Normal closure', wasClean);\\r\\n};\\r\\n\\r\\nSockJS.prototype.send = function(data) {\\r\\n  // #13 - convert anything non-string to string\\r\\n  // TODO this currently turns objects into [object Object]\\r\\n  if (typeof data !== 'string') {\\r\\n    data = '' + data;\\r\\n  }\\r\\n  if (this.readyState === SockJS.CONNECTING) {\\r\\n    throw new Error('InvalidStateError: The connection has not been established yet');\\r\\n  }\\r\\n  if (this.readyState !== SockJS.OPEN) {\\r\\n    return;\\r\\n  }\\r\\n  this._transport.send(escape.quote(data));\\r\\n};\\r\\n\\r\\nSockJS.version = require('./version');\\r\\n\\r\\nSockJS.CONNECTING = 0;\\r\\nSockJS.OPEN = 1;\\r\\nSockJS.CLOSING = 2;\\r\\nSockJS.CLOSED = 3;\\r\\n\\r\\nSockJS.prototype._receiveInfo = function(info, rtt) {\\r\\n  debug('_receiveInfo', rtt);\\r\\n  this._ir = null;\\r\\n  if (!info) {\\r\\n    this._close(1002, 'Cannot connect to server');\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // establish a round-trip timeout (RTO) based on the\\r\\n  // round-trip time (RTT)\\r\\n  this._rto = this.countRTO(rtt);\\r\\n  // allow server to override url used for the actual transport\\r\\n  this._transUrl = info.base_url ? info.base_url : this.url;\\r\\n  info = objectUtils.extend(info, this._urlInfo);\\r\\n  debug('info', info);\\r\\n  // determine list of desired and supported transports\\r\\n  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\\r\\n  this._transports = enabledTransports.main;\\r\\n  debug(this._transports.length + ' enabled transports');\\r\\n\\r\\n  this._connect();\\r\\n};\\r\\n\\r\\nSockJS.prototype._connect = function() {\\r\\n  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\\r\\n    debug('attempt', Transport.transportName);\\r\\n    if (Transport.needBody) {\\r\\n      if (!global.document.body ||\\r\\n          (typeof global.document.readyState !== 'undefined' &&\\r\\n            global.document.readyState !== 'complete' &&\\r\\n            global.document.readyState !== 'interactive')) {\\r\\n        debug('waiting for body');\\r\\n        this._transports.unshift(Transport);\\r\\n        eventUtils.attachEvent('load', this._connect.bind(this));\\r\\n        return;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // calculate timeout based on RTO and round trips. Default to 5s\\r\\n    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;\\r\\n    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\\r\\n    debug('using timeout', timeoutMs);\\r\\n\\r\\n    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\\r\\n    var options = this._transportOptions[Transport.transportName];\\r\\n    debug('transport url', transportUrl);\\r\\n    var transportObj = new Transport(transportUrl, this._transUrl, options);\\r\\n    transportObj.on('message', this._transportMessage.bind(this));\\r\\n    transportObj.once('close', this._transportClose.bind(this));\\r\\n    transportObj.transportName = Transport.transportName;\\r\\n    this._transport = transportObj;\\r\\n\\r\\n    return;\\r\\n  }\\r\\n  this._close(2000, 'All transports failed', false);\\r\\n};\\r\\n\\r\\nSockJS.prototype._transportTimeout = function() {\\r\\n  debug('_transportTimeout');\\r\\n  if (this.readyState === SockJS.CONNECTING) {\\r\\n    if (this._transport) {\\r\\n      this._transport.close();\\r\\n    }\\r\\n\\r\\n    this._transportClose(2007, 'Transport timed out');\\r\\n  }\\r\\n};\\r\\n\\r\\nSockJS.prototype._transportMessage = function(msg) {\\r\\n  debug('_transportMessage', msg);\\r\\n  var self = this\\r\\n    , type = msg.slice(0, 1)\\r\\n    , content = msg.slice(1)\\r\\n    , payload\\r\\n    ;\\r\\n\\r\\n  // first check for messages that don't need a payload\\r\\n  switch (type) {\\r\\n    case 'o':\\r\\n      this._open();\\r\\n      return;\\r\\n    case 'h':\\r\\n      this.dispatchEvent(new Event('heartbeat'));\\r\\n      debug('heartbeat', this.transport);\\r\\n      return;\\r\\n  }\\r\\n\\r\\n  if (content) {\\r\\n    try {\\r\\n      payload = JSON3.parse(content);\\r\\n    } catch (e) {\\r\\n      debug('bad json', content);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof payload === 'undefined') {\\r\\n    debug('empty payload', content);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  switch (type) {\\r\\n    case 'a':\\r\\n      if (Array.isArray(payload)) {\\r\\n        payload.forEach(function(p) {\\r\\n          debug('message', self.transport, p);\\r\\n          self.dispatchEvent(new TransportMessageEvent(p));\\r\\n        });\\r\\n      }\\r\\n      break;\\r\\n    case 'm':\\r\\n      debug('message', this.transport, payload);\\r\\n      this.dispatchEvent(new TransportMessageEvent(payload));\\r\\n      break;\\r\\n    case 'c':\\r\\n      if (Array.isArray(payload) && payload.length === 2) {\\r\\n        this._close(payload[0], payload[1], true);\\r\\n      }\\r\\n      break;\\r\\n  }\\r\\n};\\r\\n\\r\\nSockJS.prototype._transportClose = function(code, reason) {\\r\\n  debug('_transportClose', this.transport, code, reason);\\r\\n  if (this._transport) {\\r\\n    this._transport.removeAllListeners();\\r\\n    this._transport = null;\\r\\n    this.transport = null;\\r\\n  }\\r\\n\\r\\n  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\\r\\n    this._connect();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  this._close(code, reason);\\r\\n};\\r\\n\\r\\nSockJS.prototype._open = function() {\\r\\n  debug('_open', this._transport.transportName, this.readyState);\\r\\n  if (this.readyState === SockJS.CONNECTING) {\\r\\n    if (this._transportTimeoutId) {\\r\\n      clearTimeout(this._transportTimeoutId);\\r\\n      this._transportTimeoutId = null;\\r\\n    }\\r\\n    this.readyState = SockJS.OPEN;\\r\\n    this.transport = this._transport.transportName;\\r\\n    this.dispatchEvent(new Event('open'));\\r\\n    debug('connected', this.transport);\\r\\n  } else {\\r\\n    // The server might have been restarted, and lost track of our\\r\\n    // connection.\\r\\n    this._close(1006, 'Server lost session');\\r\\n  }\\r\\n};\\r\\n\\r\\nSockJS.prototype._close = function(code, reason, wasClean) {\\r\\n  debug('_close', this.transport, code, reason, wasClean, this.readyState);\\r\\n  var forceFail = false;\\r\\n\\r\\n  if (this._ir) {\\r\\n    forceFail = true;\\r\\n    this._ir.close();\\r\\n    this._ir = null;\\r\\n  }\\r\\n  if (this._transport) {\\r\\n    this._transport.close();\\r\\n    this._transport = null;\\r\\n    this.transport = null;\\r\\n  }\\r\\n\\r\\n  if (this.readyState === SockJS.CLOSED) {\\r\\n    throw new Error('InvalidStateError: SockJS has already been closed');\\r\\n  }\\r\\n\\r\\n  this.readyState = SockJS.CLOSING;\\r\\n  setTimeout(function() {\\r\\n    this.readyState = SockJS.CLOSED;\\r\\n\\r\\n    if (forceFail) {\\r\\n      this.dispatchEvent(new Event('error'));\\r\\n    }\\r\\n\\r\\n    var e = new CloseEvent('close');\\r\\n    e.wasClean = wasClean || false;\\r\\n    e.code = code || 1000;\\r\\n    e.reason = reason;\\r\\n\\r\\n    this.dispatchEvent(e);\\r\\n    this.onmessage = this.onclose = this.onerror = null;\\r\\n    debug('disconnected');\\r\\n  }.bind(this), 0);\\r\\n};\\r\\n\\r\\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\\r\\n// and RFC 2988.\\r\\nSockJS.prototype.countRTO = function(rtt) {\\r\\n  // In a local environment, when using IE8/9 and the `jsonp-polling`\\r\\n  // transport the time needed to establish a connection (the time that pass\\r\\n  // from the opening of the transport to the call of `_dispatchOpen`) is\\r\\n  // around 200msec (the lower bound used in the article above) and this\\r\\n  // causes spurious timeouts. For this reason we calculate a value slightly\\r\\n  // larger than that used in the article.\\r\\n  if (rtt > 100) {\\r\\n    return 4 * rtt; // rto > 400msec\\r\\n  }\\r\\n  return 300 + rtt; // 300msec < rto <= 400msec\\r\\n};\\r\\n\\r\\nmodule.exports = function(availableTransports) {\\r\\n  transports = transport(availableTransports);\\r\\n  require('./iframe-bootstrap')(SockJS, availableTransports);\\r\\n  return SockJS;\\r\\n};\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./event/close\\\":2,\\\"./event/event\\\":4,\\\"./event/eventtarget\\\":5,\\\"./event/trans-message\\\":6,\\\"./iframe-bootstrap\\\":8,\\\"./info-receiver\\\":12,\\\"./location\\\":13,\\\"./shims\\\":15,\\\"./utils/browser\\\":44,\\\"./utils/escape\\\":45,\\\"./utils/event\\\":46,\\\"./utils/log\\\":48,\\\"./utils/object\\\":49,\\\"./utils/random\\\":50,\\\"./utils/transport\\\":51,\\\"./utils/url\\\":52,\\\"./version\\\":53,\\\"debug\\\":55,\\\"inherits\\\":57,\\\"json3\\\":58,\\\"url-parse\\\":61}],15:[function(require,module,exports){\\r\\n/* eslint-disable */\\r\\n/* jscs: disable */\\r\\n'use strict';\\r\\n\\r\\n// pulled specific shims from https://github.com/es-shims/es5-shim\\r\\n\\r\\nvar ArrayPrototype = Array.prototype;\\r\\nvar ObjectPrototype = Object.prototype;\\r\\nvar FunctionPrototype = Function.prototype;\\r\\nvar StringPrototype = String.prototype;\\r\\nvar array_slice = ArrayPrototype.slice;\\r\\n\\r\\nvar _toString = ObjectPrototype.toString;\\r\\nvar isFunction = function (val) {\\r\\n    return ObjectPrototype.toString.call(val) === '[object Function]';\\r\\n};\\r\\nvar isArray = function isArray(obj) {\\r\\n    return _toString.call(obj) === '[object Array]';\\r\\n};\\r\\nvar isString = function isString(obj) {\\r\\n    return _toString.call(obj) === '[object String]';\\r\\n};\\r\\n\\r\\nvar supportsDescriptors = Object.defineProperty && (function () {\\r\\n    try {\\r\\n        Object.defineProperty({}, 'x', {});\\r\\n        return true;\\r\\n    } catch (e) { /* this is ES3 */\\r\\n        return false;\\r\\n    }\\r\\n}());\\r\\n\\r\\n// Define configurable, writable and non-enumerable props\\r\\n// if they don't exist.\\r\\nvar defineProperty;\\r\\nif (supportsDescriptors) {\\r\\n    defineProperty = function (object, name, method, forceAssign) {\\r\\n        if (!forceAssign && (name in object)) { return; }\\r\\n        Object.defineProperty(object, name, {\\r\\n            configurable: true,\\r\\n            enumerable: false,\\r\\n            writable: true,\\r\\n            value: method\\r\\n        });\\r\\n    };\\r\\n} else {\\r\\n    defineProperty = function (object, name, method, forceAssign) {\\r\\n        if (!forceAssign && (name in object)) { return; }\\r\\n        object[name] = method;\\r\\n    };\\r\\n}\\r\\nvar defineProperties = function (object, map, forceAssign) {\\r\\n    for (var name in map) {\\r\\n        if (ObjectPrototype.hasOwnProperty.call(map, name)) {\\r\\n          defineProperty(object, name, map[name], forceAssign);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nvar toObject = function (o) {\\r\\n    if (o == null) { // this matches both null and undefined\\r\\n        throw new TypeError(\\\"can't convert \\\" + o + ' to object');\\r\\n    }\\r\\n    return Object(o);\\r\\n};\\r\\n\\r\\n//\\r\\n// Util\\r\\n// ======\\r\\n//\\r\\n\\r\\n// ES5 9.4\\r\\n// http://es5.github.com/#x9.4\\r\\n// http://jsperf.com/to-integer\\r\\n\\r\\nfunction toInteger(num) {\\r\\n    var n = +num;\\r\\n    if (n !== n) { // isNaN\\r\\n        n = 0;\\r\\n    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\\r\\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\\r\\n    }\\r\\n    return n;\\r\\n}\\r\\n\\r\\nfunction ToUint32(x) {\\r\\n    return x >>> 0;\\r\\n}\\r\\n\\r\\n//\\r\\n// Function\\r\\n// ========\\r\\n//\\r\\n\\r\\n// ES-5 15.3.4.5\\r\\n// http://es5.github.com/#x15.3.4.5\\r\\n\\r\\nfunction Empty() {}\\r\\n\\r\\ndefineProperties(FunctionPrototype, {\\r\\n    bind: function bind(that) { // .length is 1\\r\\n        // 1. Let Target be the this value.\\r\\n        var target = this;\\r\\n        // 2. If IsCallable(Target) is false, throw a TypeError exception.\\r\\n        if (!isFunction(target)) {\\r\\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\\r\\n        }\\r\\n        // 3. Let A be a new (possibly empty) internal list of all of the\\r\\n        //   argument values provided after thisArg (arg1, arg2 etc), in order.\\r\\n        // XXX slicedArgs will stand in for \\\"A\\\" if used\\r\\n        var args = array_slice.call(arguments, 1); // for normal call\\r\\n        // 4. Let F be a new native ECMAScript object.\\r\\n        // 11. Set the [[Prototype]] internal property of F to the standard\\r\\n        //   built-in Function prototype object as specified in 15.3.3.1.\\r\\n        // 12. Set the [[Call]] internal property of F as described in\\r\\n        //   15.3.4.5.1.\\r\\n        // 13. Set the [[Construct]] internal property of F as described in\\r\\n        //   15.3.4.5.2.\\r\\n        // 14. Set the [[HasInstance]] internal property of F as described in\\r\\n        //   15.3.4.5.3.\\r\\n        var binder = function () {\\r\\n\\r\\n            if (this instanceof bound) {\\r\\n                // 15.3.4.5.2 [[Construct]]\\r\\n                // When the [[Construct]] internal method of a function object,\\r\\n                // F that was created using the bind function is called with a\\r\\n                // list of arguments ExtraArgs, the following steps are taken:\\r\\n                // 1. Let target be the value of F's [[TargetFunction]]\\r\\n                //   internal property.\\r\\n                // 2. If target has no [[Construct]] internal method, a\\r\\n                //   TypeError exception is thrown.\\r\\n                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\\r\\n                //   property.\\r\\n                // 4. Let args be a new list containing the same values as the\\r\\n                //   list boundArgs in the same order followed by the same\\r\\n                //   values as the list ExtraArgs in the same order.\\r\\n                // 5. Return the result of calling the [[Construct]] internal\\r\\n                //   method of target providing args as the arguments.\\r\\n\\r\\n                var result = target.apply(\\r\\n                    this,\\r\\n                    args.concat(array_slice.call(arguments))\\r\\n                );\\r\\n                if (Object(result) === result) {\\r\\n                    return result;\\r\\n                }\\r\\n                return this;\\r\\n\\r\\n            } else {\\r\\n                // 15.3.4.5.1 [[Call]]\\r\\n                // When the [[Call]] internal method of a function object, F,\\r\\n                // which was created using the bind function is called with a\\r\\n                // this value and a list of arguments ExtraArgs, the following\\r\\n                // steps are taken:\\r\\n                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\\r\\n                //   property.\\r\\n                // 2. Let boundThis be the value of F's [[BoundThis]] internal\\r\\n                //   property.\\r\\n                // 3. Let target be the value of F's [[TargetFunction]] internal\\r\\n                //   property.\\r\\n                // 4. Let args be a new list containing the same values as the\\r\\n                //   list boundArgs in the same order followed by the same\\r\\n                //   values as the list ExtraArgs in the same order.\\r\\n                // 5. Return the result of calling the [[Call]] internal method\\r\\n                //   of target providing boundThis as the this value and\\r\\n                //   providing args as the arguments.\\r\\n\\r\\n                // equiv: target.call(this, ...boundArgs, ...args)\\r\\n                return target.apply(\\r\\n                    that,\\r\\n                    args.concat(array_slice.call(arguments))\\r\\n                );\\r\\n\\r\\n            }\\r\\n\\r\\n        };\\r\\n\\r\\n        // 15. If the [[Class]] internal property of Target is \\\"Function\\\", then\\r\\n        //     a. Let L be the length property of Target minus the length of A.\\r\\n        //     b. Set the length own property of F to either 0 or L, whichever is\\r\\n        //       larger.\\r\\n        // 16. Else set the length own property of F to 0.\\r\\n\\r\\n        var boundLength = Math.max(0, target.length - args.length);\\r\\n\\r\\n        // 17. Set the attributes of the length own property of F to the values\\r\\n        //   specified in 15.3.5.1.\\r\\n        var boundArgs = [];\\r\\n        for (var i = 0; i < boundLength; i++) {\\r\\n            boundArgs.push('$' + i);\\r\\n        }\\r\\n\\r\\n        // XXX Build a dynamic function with desired amount of arguments is the only\\r\\n        // way to set the length property of a function.\\r\\n        // In environments where Content Security Policies enabled (Chrome extensions,\\r\\n        // for ex.) all use of eval or Function costructor throws an exception.\\r\\n        // However in all of these environments Function.prototype.bind exists\\r\\n        // and so this code will never be executed.\\r\\n        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\\r\\n\\r\\n        if (target.prototype) {\\r\\n            Empty.prototype = target.prototype;\\r\\n            bound.prototype = new Empty();\\r\\n            // Clean up dangling references.\\r\\n            Empty.prototype = null;\\r\\n        }\\r\\n\\r\\n        // TODO\\r\\n        // 18. Set the [[Extensible]] internal property of F to true.\\r\\n\\r\\n        // TODO\\r\\n        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\\r\\n        // 20. Call the [[DefineOwnProperty]] internal method of F with\\r\\n        //   arguments \\\"caller\\\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\\r\\n        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\\r\\n        //   false.\\r\\n        // 21. Call the [[DefineOwnProperty]] internal method of F with\\r\\n        //   arguments \\\"arguments\\\", PropertyDescriptor {[[Get]]: thrower,\\r\\n        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\\r\\n        //   and false.\\r\\n\\r\\n        // TODO\\r\\n        // NOTE Function objects created using Function.prototype.bind do not\\r\\n        // have a prototype property or the [[Code]], [[FormalParameters]], and\\r\\n        // [[Scope]] internal properties.\\r\\n        // XXX can't delete prototype in pure-js.\\r\\n\\r\\n        // 22. Return F.\\r\\n        return bound;\\r\\n    }\\r\\n});\\r\\n\\r\\n//\\r\\n// Array\\r\\n// =====\\r\\n//\\r\\n\\r\\n// ES5 15.4.3.2\\r\\n// http://es5.github.com/#x15.4.3.2\\r\\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\\r\\ndefineProperties(Array, { isArray: isArray });\\r\\n\\r\\n\\r\\nvar boxedString = Object('a');\\r\\nvar splitString = boxedString[0] !== 'a' || !(0 in boxedString);\\r\\n\\r\\nvar properlyBoxesContext = function properlyBoxed(method) {\\r\\n    // Check node 0.6.21 bug where third parameter is not boxed\\r\\n    var properlyBoxesNonStrict = true;\\r\\n    var properlyBoxesStrict = true;\\r\\n    if (method) {\\r\\n        method.call('foo', function (_, __, context) {\\r\\n            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\\r\\n        });\\r\\n\\r\\n        method.call([1], function () {\\r\\n            'use strict';\\r\\n            properlyBoxesStrict = typeof this === 'string';\\r\\n        }, 'x');\\r\\n    }\\r\\n    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\\r\\n};\\r\\n\\r\\ndefineProperties(ArrayPrototype, {\\r\\n    forEach: function forEach(fun /*, thisp*/) {\\r\\n        var object = toObject(this),\\r\\n            self = splitString && isString(this) ? this.split('') : object,\\r\\n            thisp = arguments[1],\\r\\n            i = -1,\\r\\n            length = self.length >>> 0;\\r\\n\\r\\n        // If no callback function or if callback is not a callable function\\r\\n        if (!isFunction(fun)) {\\r\\n            throw new TypeError(); // TODO message\\r\\n        }\\r\\n\\r\\n        while (++i < length) {\\r\\n            if (i in self) {\\r\\n                // Invoke the callback function with call, passing arguments:\\r\\n                // context, property value, property key, thisArg object\\r\\n                // context\\r\\n                fun.call(thisp, self[i], i, object);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}, !properlyBoxesContext(ArrayPrototype.forEach));\\r\\n\\r\\n// ES5 15.4.4.14\\r\\n// http://es5.github.com/#x15.4.4.14\\r\\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\\r\\nvar hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\\r\\ndefineProperties(ArrayPrototype, {\\r\\n    indexOf: function indexOf(sought /*, fromIndex */ ) {\\r\\n        var self = splitString && isString(this) ? this.split('') : toObject(this),\\r\\n            length = self.length >>> 0;\\r\\n\\r\\n        if (!length) {\\r\\n            return -1;\\r\\n        }\\r\\n\\r\\n        var i = 0;\\r\\n        if (arguments.length > 1) {\\r\\n            i = toInteger(arguments[1]);\\r\\n        }\\r\\n\\r\\n        // handle negative indices\\r\\n        i = i >= 0 ? i : Math.max(0, length + i);\\r\\n        for (; i < length; i++) {\\r\\n            if (i in self && self[i] === sought) {\\r\\n                return i;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n}, hasFirefox2IndexOfBug);\\r\\n\\r\\n//\\r\\n// String\\r\\n// ======\\r\\n//\\r\\n\\r\\n// ES5 15.5.4.14\\r\\n// http://es5.github.com/#x15.5.4.14\\r\\n\\r\\n// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\\r\\n// Many browsers do not split properly with regular expressions or they\\r\\n// do not perform the split correctly under obscure conditions.\\r\\n// See http://blog.stevenlevithan.com/archives/cross-browser-split\\r\\n// I've tested in many browsers and this seems to cover the deviant ones:\\r\\n//    'ab'.split(/(?:ab)*/) should be [\\\"\\\", \\\"\\\"], not [\\\"\\\"]\\r\\n//    '.'.split(/(.?)(.?)/) should be [\\\"\\\", \\\".\\\", \\\"\\\", \\\"\\\"], not [\\\"\\\", \\\"\\\"]\\r\\n//    'tesst'.split(/(s)*/) should be [\\\"t\\\", undefined, \\\"e\\\", \\\"s\\\", \\\"t\\\"], not\\r\\n//       [undefined, \\\"t\\\", undefined, \\\"e\\\", ...]\\r\\n//    ''.split(/.?/) should be [], not [\\\"\\\"]\\r\\n//    '.'.split(/()()/) should be [\\\".\\\"], not [\\\"\\\", \\\"\\\", \\\".\\\"]\\r\\n\\r\\nvar string_split = StringPrototype.split;\\r\\nif (\\r\\n    'ab'.split(/(?:ab)*/).length !== 2 ||\\r\\n    '.'.split(/(.?)(.?)/).length !== 4 ||\\r\\n    'tesst'.split(/(s)*/)[1] === 't' ||\\r\\n    'test'.split(/(?:)/, -1).length !== 4 ||\\r\\n    ''.split(/.?/).length ||\\r\\n    '.'.split(/()()/).length > 1\\r\\n) {\\r\\n    (function () {\\r\\n        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\\r\\n\\r\\n        StringPrototype.split = function (separator, limit) {\\r\\n            var string = this;\\r\\n            if (separator === void 0 && limit === 0) {\\r\\n                return [];\\r\\n            }\\r\\n\\r\\n            // If `separator` is not a regex, use native split\\r\\n            if (_toString.call(separator) !== '[object RegExp]') {\\r\\n                return string_split.call(this, separator, limit);\\r\\n            }\\r\\n\\r\\n            var output = [],\\r\\n                flags = (separator.ignoreCase ? 'i' : '') +\\r\\n                        (separator.multiline  ? 'm' : '') +\\r\\n                        (separator.extended   ? 'x' : '') + // Proposed for ES6\\r\\n                        (separator.sticky     ? 'y' : ''), // Firefox 3+\\r\\n                lastLastIndex = 0,\\r\\n                // Make `global` and avoid `lastIndex` issues by working with a copy\\r\\n                separator2, match, lastIndex, lastLength;\\r\\n            separator = new RegExp(separator.source, flags + 'g');\\r\\n            string += ''; // Type-convert\\r\\n            if (!compliantExecNpcg) {\\r\\n                // Doesn't need flags gy, but they don't hurt\\r\\n                separator2 = new RegExp('^' + separator.source + '$(?!\\\\\\\\s)', flags);\\r\\n            }\\r\\n            /* Values for `limit`, per the spec:\\r\\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\\r\\n             * If 0, Infinity, or NaN: 0\\r\\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\\r\\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\\r\\n             * If other: Type-convert, then use the above rules\\r\\n             */\\r\\n            limit = limit === void 0 ?\\r\\n                -1 >>> 0 : // Math.pow(2, 32) - 1\\r\\n                ToUint32(limit);\\r\\n            while (match = separator.exec(string)) {\\r\\n                // `separator.lastIndex` is not reliable cross-browser\\r\\n                lastIndex = match.index + match[0].length;\\r\\n                if (lastIndex > lastLastIndex) {\\r\\n                    output.push(string.slice(lastLastIndex, match.index));\\r\\n                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\\r\\n                    // nonparticipating capturing groups\\r\\n                    if (!compliantExecNpcg && match.length > 1) {\\r\\n                        match[0].replace(separator2, function () {\\r\\n                            for (var i = 1; i < arguments.length - 2; i++) {\\r\\n                                if (arguments[i] === void 0) {\\r\\n                                    match[i] = void 0;\\r\\n                                }\\r\\n                            }\\r\\n                        });\\r\\n                    }\\r\\n                    if (match.length > 1 && match.index < string.length) {\\r\\n                        ArrayPrototype.push.apply(output, match.slice(1));\\r\\n                    }\\r\\n                    lastLength = match[0].length;\\r\\n                    lastLastIndex = lastIndex;\\r\\n                    if (output.length >= limit) {\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                if (separator.lastIndex === match.index) {\\r\\n                    separator.lastIndex++; // Avoid an infinite loop\\r\\n                }\\r\\n            }\\r\\n            if (lastLastIndex === string.length) {\\r\\n                if (lastLength || !separator.test('')) {\\r\\n                    output.push('');\\r\\n                }\\r\\n            } else {\\r\\n                output.push(string.slice(lastLastIndex));\\r\\n            }\\r\\n            return output.length > limit ? output.slice(0, limit) : output;\\r\\n        };\\r\\n    }());\\r\\n\\r\\n// [bugfix, chrome]\\r\\n// If separator is undefined, then the result array contains just one String,\\r\\n// which is the this value (converted to a String). If limit is not undefined,\\r\\n// then the output array is truncated so that it contains no more than limit\\r\\n// elements.\\r\\n// \\\"0\\\".split(undefined, 0) -> []\\r\\n} else if ('0'.split(void 0, 0).length) {\\r\\n    StringPrototype.split = function split(separator, limit) {\\r\\n        if (separator === void 0 && limit === 0) { return []; }\\r\\n        return string_split.call(this, separator, limit);\\r\\n    };\\r\\n}\\r\\n\\r\\n// ECMA-262, 3rd B.2.3\\r\\n// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\\r\\n// non-normative section suggesting uniform semantics and it should be\\r\\n// normalized across all browsers\\r\\n// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\\r\\nvar string_substr = StringPrototype.substr;\\r\\nvar hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\\r\\ndefineProperties(StringPrototype, {\\r\\n    substr: function substr(start, length) {\\r\\n        return string_substr.call(\\r\\n            this,\\r\\n            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\\r\\n            length\\r\\n        );\\r\\n    }\\r\\n}, hasNegativeSubstrBug);\\r\\n\\r\\n},{}],16:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nmodule.exports = [\\r\\n  // streaming transports\\r\\n  require('./transport/websocket')\\r\\n, require('./transport/xhr-streaming')\\r\\n, require('./transport/xdr-streaming')\\r\\n, require('./transport/eventsource')\\r\\n, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\\r\\n\\r\\n  // polling transports\\r\\n, require('./transport/htmlfile')\\r\\n, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))\\r\\n, require('./transport/xhr-polling')\\r\\n, require('./transport/xdr-polling')\\r\\n, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))\\r\\n, require('./transport/jsonp-polling')\\r\\n];\\r\\n\\r\\n},{\\\"./transport/eventsource\\\":20,\\\"./transport/htmlfile\\\":21,\\\"./transport/jsonp-polling\\\":23,\\\"./transport/lib/iframe-wrap\\\":26,\\\"./transport/websocket\\\":38,\\\"./transport/xdr-polling\\\":39,\\\"./transport/xdr-streaming\\\":40,\\\"./transport/xhr-polling\\\":41,\\\"./transport/xhr-streaming\\\":42}],17:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  , utils = require('../../utils/event')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  , XHR = global.XMLHttpRequest\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:browser:xhr');\\r\\n}\\r\\n\\r\\nfunction AbstractXHRObject(method, url, payload, opts) {\\r\\n  debug(method, url);\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  setTimeout(function () {\\r\\n    self._start(method, url, payload, opts);\\r\\n  }, 0);\\r\\n}\\r\\n\\r\\ninherits(AbstractXHRObject, EventEmitter);\\r\\n\\r\\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\\r\\n  var self = this;\\r\\n\\r\\n  try {\\r\\n    this.xhr = new XHR();\\r\\n  } catch (x) {\\r\\n    // intentionally empty\\r\\n  }\\r\\n\\r\\n  if (!this.xhr) {\\r\\n    debug('no xhr');\\r\\n    this.emit('finish', 0, 'no xhr support');\\r\\n    this._cleanup();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // several browsers cache POSTs\\r\\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\\r\\n\\r\\n  // Explorer tends to keep connection open, even after the\\r\\n  // tab gets closed: http://bugs.jquery.com/ticket/5280\\r\\n  this.unloadRef = utils.unloadAdd(function() {\\r\\n    debug('unload cleanup');\\r\\n    self._cleanup(true);\\r\\n  });\\r\\n  try {\\r\\n    this.xhr.open(method, url, true);\\r\\n    if (this.timeout && 'timeout' in this.xhr) {\\r\\n      this.xhr.timeout = this.timeout;\\r\\n      this.xhr.ontimeout = function() {\\r\\n        debug('xhr timeout');\\r\\n        self.emit('finish', 0, '');\\r\\n        self._cleanup(false);\\r\\n      };\\r\\n    }\\r\\n  } catch (e) {\\r\\n    debug('exception', e);\\r\\n    // IE raises an exception on wrong port.\\r\\n    this.emit('finish', 0, '');\\r\\n    this._cleanup(false);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\\r\\n    debug('withCredentials');\\r\\n    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\\r\\n    // \\\"This never affects same-site requests.\\\"\\r\\n\\r\\n    this.xhr.withCredentials = true;\\r\\n  }\\r\\n  if (opts && opts.headers) {\\r\\n    for (var key in opts.headers) {\\r\\n      this.xhr.setRequestHeader(key, opts.headers[key]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.xhr.onreadystatechange = function() {\\r\\n    if (self.xhr) {\\r\\n      var x = self.xhr;\\r\\n      var text, status;\\r\\n      debug('readyState', x.readyState);\\r\\n      switch (x.readyState) {\\r\\n      case 3:\\r\\n        // IE doesn't like peeking into responseText or status\\r\\n        // on Microsoft.XMLHTTP and readystate=3\\r\\n        try {\\r\\n          status = x.status;\\r\\n          text = x.responseText;\\r\\n        } catch (e) {\\r\\n          // intentionally empty\\r\\n        }\\r\\n        debug('status', status);\\r\\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\r\\n        if (status === 1223) {\\r\\n          status = 204;\\r\\n        }\\r\\n\\r\\n        // IE does return readystate == 3 for 404 answers.\\r\\n        if (status === 200 && text && text.length > 0) {\\r\\n          debug('chunk');\\r\\n          self.emit('chunk', status, text);\\r\\n        }\\r\\n        break;\\r\\n      case 4:\\r\\n        status = x.status;\\r\\n        debug('status', status);\\r\\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\r\\n        if (status === 1223) {\\r\\n          status = 204;\\r\\n        }\\r\\n        // IE returns this for a bad port\\r\\n        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\\r\\n        if (status === 12005 || status === 12029) {\\r\\n          status = 0;\\r\\n        }\\r\\n\\r\\n        debug('finish', status, x.responseText);\\r\\n        self.emit('finish', status, x.responseText);\\r\\n        self._cleanup(false);\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  try {\\r\\n    self.xhr.send(payload);\\r\\n  } catch (e) {\\r\\n    self.emit('finish', 0, '');\\r\\n    self._cleanup(false);\\r\\n  }\\r\\n};\\r\\n\\r\\nAbstractXHRObject.prototype._cleanup = function(abort) {\\r\\n  debug('cleanup');\\r\\n  if (!this.xhr) {\\r\\n    return;\\r\\n  }\\r\\n  this.removeAllListeners();\\r\\n  utils.unloadDel(this.unloadRef);\\r\\n\\r\\n  // IE needs this field to be a function\\r\\n  this.xhr.onreadystatechange = function() {};\\r\\n  if (this.xhr.ontimeout) {\\r\\n    this.xhr.ontimeout = null;\\r\\n  }\\r\\n\\r\\n  if (abort) {\\r\\n    try {\\r\\n      this.xhr.abort();\\r\\n    } catch (x) {\\r\\n      // intentionally empty\\r\\n    }\\r\\n  }\\r\\n  this.unloadRef = this.xhr = null;\\r\\n};\\r\\n\\r\\nAbstractXHRObject.prototype.close = function() {\\r\\n  debug('close');\\r\\n  this._cleanup(true);\\r\\n};\\r\\n\\r\\nAbstractXHRObject.enabled = !!XHR;\\r\\n// override XMLHttpRequest for IE6/7\\r\\n// obfuscate to avoid firewalls\\r\\nvar axo = ['Active'].concat('Object').join('X');\\r\\nif (!AbstractXHRObject.enabled && (axo in global)) {\\r\\n  debug('overriding xmlhttprequest');\\r\\n  XHR = function() {\\r\\n    try {\\r\\n      return new global[axo]('Microsoft.XMLHTTP');\\r\\n    } catch (e) {\\r\\n      return null;\\r\\n    }\\r\\n  };\\r\\n  AbstractXHRObject.enabled = !!new XHR();\\r\\n}\\r\\n\\r\\nvar cors = false;\\r\\ntry {\\r\\n  cors = 'withCredentials' in new XHR();\\r\\n} catch (ignored) {\\r\\n  // intentionally empty\\r\\n}\\r\\n\\r\\nAbstractXHRObject.supportsCORS = cors;\\r\\n\\r\\nmodule.exports = AbstractXHRObject;\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/event\\\":46,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],18:[function(require,module,exports){\\r\\n(function (global){\\r\\nmodule.exports = global.EventSource;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],19:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar Driver = global.WebSocket || global.MozWebSocket;\\r\\nif (Driver) {\\r\\n\\tmodule.exports = function WebSocketBrowserDriver(url) {\\r\\n\\t\\treturn new Driver(url);\\r\\n\\t};\\r\\n} else {\\r\\n\\tmodule.exports = undefined;\\r\\n}\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],20:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  , EventSourceReceiver = require('./receiver/eventsource')\\r\\n  , XHRCorsObject = require('./sender/xhr-cors')\\r\\n  , EventSourceDriver = require('eventsource')\\r\\n  ;\\r\\n\\r\\nfunction EventSourceTransport(transUrl) {\\r\\n  if (!EventSourceTransport.enabled()) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n\\r\\n  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\\r\\n}\\r\\n\\r\\ninherits(EventSourceTransport, AjaxBasedTransport);\\r\\n\\r\\nEventSourceTransport.enabled = function() {\\r\\n  return !!EventSourceDriver;\\r\\n};\\r\\n\\r\\nEventSourceTransport.transportName = 'eventsource';\\r\\nEventSourceTransport.roundTrips = 2;\\r\\n\\r\\nmodule.exports = EventSourceTransport;\\r\\n\\r\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/eventsource\\\":29,\\\"./sender/xhr-cors\\\":35,\\\"eventsource\\\":18,\\\"inherits\\\":57}],21:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , HtmlfileReceiver = require('./receiver/htmlfile')\\r\\n  , XHRLocalObject = require('./sender/xhr-local')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  ;\\r\\n\\r\\nfunction HtmlFileTransport(transUrl) {\\r\\n  if (!HtmlfileReceiver.enabled) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\\r\\n}\\r\\n\\r\\ninherits(HtmlFileTransport, AjaxBasedTransport);\\r\\n\\r\\nHtmlFileTransport.enabled = function(info) {\\r\\n  return HtmlfileReceiver.enabled && info.sameOrigin;\\r\\n};\\r\\n\\r\\nHtmlFileTransport.transportName = 'htmlfile';\\r\\nHtmlFileTransport.roundTrips = 2;\\r\\n\\r\\nmodule.exports = HtmlFileTransport;\\r\\n\\r\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/htmlfile\\\":30,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],22:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\n// Few cool transports do work only for same-origin. In order to make\\r\\n// them work cross-domain we shall use iframe, served from the\\r\\n// remote domain. New browsers have capabilities to communicate with\\r\\n// cross domain iframe using postMessage(). In IE it was implemented\\r\\n// from IE 8+, but of course, IE got some details wrong:\\r\\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\\r\\n//    http://stevesouders.com/misc/test-postmessage.php\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , JSON3 = require('json3')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  , version = require('../version')\\r\\n  , urlUtils = require('../utils/url')\\r\\n  , iframeUtils = require('../utils/iframe')\\r\\n  , eventUtils = require('../utils/event')\\r\\n  , random = require('../utils/random')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:transport:iframe');\\r\\n}\\r\\n\\r\\nfunction IframeTransport(transport, transUrl, baseUrl) {\\r\\n  if (!IframeTransport.enabled()) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n  this.origin = urlUtils.getOrigin(baseUrl);\\r\\n  this.baseUrl = baseUrl;\\r\\n  this.transUrl = transUrl;\\r\\n  this.transport = transport;\\r\\n  this.windowId = random.string(8);\\r\\n\\r\\n  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\\r\\n  debug(transport, transUrl, iframeUrl);\\r\\n\\r\\n  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {\\r\\n    debug('err callback');\\r\\n    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\\r\\n    self.close();\\r\\n  });\\r\\n\\r\\n  this.onmessageCallback = this._message.bind(this);\\r\\n  eventUtils.attachEvent('message', this.onmessageCallback);\\r\\n}\\r\\n\\r\\ninherits(IframeTransport, EventEmitter);\\r\\n\\r\\nIframeTransport.prototype.close = function() {\\r\\n  debug('close');\\r\\n  this.removeAllListeners();\\r\\n  if (this.iframeObj) {\\r\\n    eventUtils.detachEvent('message', this.onmessageCallback);\\r\\n    try {\\r\\n      // When the iframe is not loaded, IE raises an exception\\r\\n      // on 'contentWindow'.\\r\\n      this.postMessage('c');\\r\\n    } catch (x) {\\r\\n      // intentionally empty\\r\\n    }\\r\\n    this.iframeObj.cleanup();\\r\\n    this.iframeObj = null;\\r\\n    this.onmessageCallback = this.iframeObj = null;\\r\\n  }\\r\\n};\\r\\n\\r\\nIframeTransport.prototype._message = function(e) {\\r\\n  debug('message', e.data);\\r\\n  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\\r\\n    debug('not same origin', e.origin, this.origin);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  var iframeMessage;\\r\\n  try {\\r\\n    iframeMessage = JSON3.parse(e.data);\\r\\n  } catch (ignored) {\\r\\n    debug('bad json', e.data);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (iframeMessage.windowId !== this.windowId) {\\r\\n    debug('mismatched window id', iframeMessage.windowId, this.windowId);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  switch (iframeMessage.type) {\\r\\n  case 's':\\r\\n    this.iframeObj.loaded();\\r\\n    // window global dependency\\r\\n    this.postMessage('s', JSON3.stringify([\\r\\n      version\\r\\n    , this.transport\\r\\n    , this.transUrl\\r\\n    , this.baseUrl\\r\\n    ]));\\r\\n    break;\\r\\n  case 't':\\r\\n    this.emit('message', iframeMessage.data);\\r\\n    break;\\r\\n  case 'c':\\r\\n    var cdata;\\r\\n    try {\\r\\n      cdata = JSON3.parse(iframeMessage.data);\\r\\n    } catch (ignored) {\\r\\n      debug('bad json', iframeMessage.data);\\r\\n      return;\\r\\n    }\\r\\n    this.emit('close', cdata[0], cdata[1]);\\r\\n    this.close();\\r\\n    break;\\r\\n  }\\r\\n};\\r\\n\\r\\nIframeTransport.prototype.postMessage = function(type, data) {\\r\\n  debug('postMessage', type, data);\\r\\n  this.iframeObj.post(JSON3.stringify({\\r\\n    windowId: this.windowId\\r\\n  , type: type\\r\\n  , data: data || ''\\r\\n  }), this.origin);\\r\\n};\\r\\n\\r\\nIframeTransport.prototype.send = function(message) {\\r\\n  debug('send', message);\\r\\n  this.postMessage('m', message);\\r\\n};\\r\\n\\r\\nIframeTransport.enabled = function() {\\r\\n  return iframeUtils.iframeEnabled;\\r\\n};\\r\\n\\r\\nIframeTransport.transportName = 'iframe';\\r\\nIframeTransport.roundTrips = 2;\\r\\n\\r\\nmodule.exports = IframeTransport;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"../utils/event\\\":46,\\\"../utils/iframe\\\":47,\\\"../utils/random\\\":50,\\\"../utils/url\\\":52,\\\"../version\\\":53,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],23:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\n// The simplest and most robust transport, using the well-know cross\\r\\n// domain hack - JSONP. This transport is quite inefficient - one\\r\\n// message could use up to one http request. But at least it works almost\\r\\n// everywhere.\\r\\n// Known limitations:\\r\\n//   o you will get a spinning cursor\\r\\n//   o for Konqueror a dumb timer is needed to detect errors\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , SenderReceiver = require('./lib/sender-receiver')\\r\\n  , JsonpReceiver = require('./receiver/jsonp')\\r\\n  , jsonpSender = require('./sender/jsonp')\\r\\n  ;\\r\\n\\r\\nfunction JsonPTransport(transUrl) {\\r\\n  if (!JsonPTransport.enabled()) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\\r\\n}\\r\\n\\r\\ninherits(JsonPTransport, SenderReceiver);\\r\\n\\r\\nJsonPTransport.enabled = function() {\\r\\n  return !!global.document;\\r\\n};\\r\\n\\r\\nJsonPTransport.transportName = 'jsonp-polling';\\r\\nJsonPTransport.roundTrips = 1;\\r\\nJsonPTransport.needBody = true;\\r\\n\\r\\nmodule.exports = JsonPTransport;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./lib/sender-receiver\\\":28,\\\"./receiver/jsonp\\\":31,\\\"./sender/jsonp\\\":33,\\\"inherits\\\":57}],24:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  , SenderReceiver = require('./sender-receiver')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:ajax-based');\\r\\n}\\r\\n\\r\\nfunction createAjaxSender(AjaxObject) {\\r\\n  return function(url, payload, callback) {\\r\\n    debug('create ajax sender', url, payload);\\r\\n    var opt = {};\\r\\n    if (typeof payload === 'string') {\\r\\n      opt.headers = {'Content-type': 'text/plain'};\\r\\n    }\\r\\n    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\\r\\n    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\\r\\n    xo.once('finish', function(status) {\\r\\n      debug('finish', status);\\r\\n      xo = null;\\r\\n\\r\\n      if (status !== 200 && status !== 204) {\\r\\n        return callback(new Error('http status ' + status));\\r\\n      }\\r\\n      callback();\\r\\n    });\\r\\n    return function() {\\r\\n      debug('abort');\\r\\n      xo.close();\\r\\n      xo = null;\\r\\n\\r\\n      var err = new Error('Aborted');\\r\\n      err.code = 1000;\\r\\n      callback(err);\\r\\n    };\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\\r\\n  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\\r\\n}\\r\\n\\r\\ninherits(AjaxBasedTransport, SenderReceiver);\\r\\n\\r\\nmodule.exports = AjaxBasedTransport;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"../../utils/url\\\":52,\\\"./sender-receiver\\\":28,\\\"debug\\\":55,\\\"inherits\\\":57}],25:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:buffered-sender');\\r\\n}\\r\\n\\r\\nfunction BufferedSender(url, sender) {\\r\\n  debug(url);\\r\\n  EventEmitter.call(this);\\r\\n  this.sendBuffer = [];\\r\\n  this.sender = sender;\\r\\n  this.url = url;\\r\\n}\\r\\n\\r\\ninherits(BufferedSender, EventEmitter);\\r\\n\\r\\nBufferedSender.prototype.send = function(message) {\\r\\n  debug('send', message);\\r\\n  this.sendBuffer.push(message);\\r\\n  if (!this.sendStop) {\\r\\n    this.sendSchedule();\\r\\n  }\\r\\n};\\r\\n\\r\\n// For polling transports in a situation when in the message callback,\\r\\n// new message is being send. If the sending connection was started\\r\\n// before receiving one, it is possible to saturate the network and\\r\\n// timeout due to the lack of receiving socket. To avoid that we delay\\r\\n// sending messages by some small time, in order to let receiving\\r\\n// connection be started beforehand. This is only a halfmeasure and\\r\\n// does not fix the big problem, but it does make the tests go more\\r\\n// stable on slow networks.\\r\\nBufferedSender.prototype.sendScheduleWait = function() {\\r\\n  debug('sendScheduleWait');\\r\\n  var self = this;\\r\\n  var tref;\\r\\n  this.sendStop = function() {\\r\\n    debug('sendStop');\\r\\n    self.sendStop = null;\\r\\n    clearTimeout(tref);\\r\\n  };\\r\\n  tref = setTimeout(function() {\\r\\n    debug('timeout');\\r\\n    self.sendStop = null;\\r\\n    self.sendSchedule();\\r\\n  }, 25);\\r\\n};\\r\\n\\r\\nBufferedSender.prototype.sendSchedule = function() {\\r\\n  debug('sendSchedule', this.sendBuffer.length);\\r\\n  var self = this;\\r\\n  if (this.sendBuffer.length > 0) {\\r\\n    var payload = '[' + this.sendBuffer.join(',') + ']';\\r\\n    this.sendStop = this.sender(this.url, payload, function(err) {\\r\\n      self.sendStop = null;\\r\\n      if (err) {\\r\\n        debug('error', err);\\r\\n        self.emit('close', err.code || 1006, 'Sending error: ' + err);\\r\\n        self.close();\\r\\n      } else {\\r\\n        self.sendScheduleWait();\\r\\n      }\\r\\n    });\\r\\n    this.sendBuffer = [];\\r\\n  }\\r\\n};\\r\\n\\r\\nBufferedSender.prototype._cleanup = function() {\\r\\n  debug('_cleanup');\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nBufferedSender.prototype.close = function() {\\r\\n  debug('close');\\r\\n  this._cleanup();\\r\\n  if (this.sendStop) {\\r\\n    this.sendStop();\\r\\n    this.sendStop = null;\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = BufferedSender;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],26:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , IframeTransport = require('../iframe')\\r\\n  , objectUtils = require('../../utils/object')\\r\\n  ;\\r\\n\\r\\nmodule.exports = function(transport) {\\r\\n\\r\\n  function IframeWrapTransport(transUrl, baseUrl) {\\r\\n    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\\r\\n  }\\r\\n\\r\\n  inherits(IframeWrapTransport, IframeTransport);\\r\\n\\r\\n  IframeWrapTransport.enabled = function(url, info) {\\r\\n    if (!global.document) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    var iframeInfo = objectUtils.extend({}, info);\\r\\n    iframeInfo.sameOrigin = true;\\r\\n    return transport.enabled(iframeInfo) && IframeTransport.enabled();\\r\\n  };\\r\\n\\r\\n  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\\r\\n  IframeWrapTransport.needBody = true;\\r\\n  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\\r\\n\\r\\n  IframeWrapTransport.facadeTransport = transport;\\r\\n\\r\\n  return IframeWrapTransport;\\r\\n};\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/object\\\":49,\\\"../iframe\\\":22,\\\"inherits\\\":57}],27:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:polling');\\r\\n}\\r\\n\\r\\nfunction Polling(Receiver, receiveUrl, AjaxObject) {\\r\\n  debug(receiveUrl);\\r\\n  EventEmitter.call(this);\\r\\n  this.Receiver = Receiver;\\r\\n  this.receiveUrl = receiveUrl;\\r\\n  this.AjaxObject = AjaxObject;\\r\\n  this._scheduleReceiver();\\r\\n}\\r\\n\\r\\ninherits(Polling, EventEmitter);\\r\\n\\r\\nPolling.prototype._scheduleReceiver = function() {\\r\\n  debug('_scheduleReceiver');\\r\\n  var self = this;\\r\\n  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\\r\\n\\r\\n  poll.on('message', function(msg) {\\r\\n    debug('message', msg);\\r\\n    self.emit('message', msg);\\r\\n  });\\r\\n\\r\\n  poll.once('close', function(code, reason) {\\r\\n    debug('close', code, reason, self.pollIsClosing);\\r\\n    self.poll = poll = null;\\r\\n\\r\\n    if (!self.pollIsClosing) {\\r\\n      if (reason === 'network') {\\r\\n        self._scheduleReceiver();\\r\\n      } else {\\r\\n        self.emit('close', code || 1006, reason);\\r\\n        self.removeAllListeners();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nPolling.prototype.abort = function() {\\r\\n  debug('abort');\\r\\n  this.removeAllListeners();\\r\\n  this.pollIsClosing = true;\\r\\n  if (this.poll) {\\r\\n    this.poll.abort();\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = Polling;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],28:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  , BufferedSender = require('./buffered-sender')\\r\\n  , Polling = require('./polling')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:sender-receiver');\\r\\n}\\r\\n\\r\\nfunction SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\\r\\n  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\\r\\n  debug(pollUrl);\\r\\n  var self = this;\\r\\n  BufferedSender.call(this, transUrl, senderFunc);\\r\\n\\r\\n  this.poll = new Polling(Receiver, pollUrl, AjaxObject);\\r\\n  this.poll.on('message', function(msg) {\\r\\n    debug('poll message', msg);\\r\\n    self.emit('message', msg);\\r\\n  });\\r\\n  this.poll.once('close', function(code, reason) {\\r\\n    debug('poll close', code, reason);\\r\\n    self.poll = null;\\r\\n    self.emit('close', code, reason);\\r\\n    self.close();\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(SenderReceiver, BufferedSender);\\r\\n\\r\\nSenderReceiver.prototype.close = function() {\\r\\n  BufferedSender.prototype.close.call(this);\\r\\n  debug('close');\\r\\n  this.removeAllListeners();\\r\\n  if (this.poll) {\\r\\n    this.poll.abort();\\r\\n    this.poll = null;\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = SenderReceiver;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"../../utils/url\\\":52,\\\"./buffered-sender\\\":25,\\\"./polling\\\":27,\\\"debug\\\":55,\\\"inherits\\\":57}],29:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  , EventSourceDriver = require('eventsource')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:receiver:eventsource');\\r\\n}\\r\\n\\r\\nfunction EventSourceReceiver(url) {\\r\\n  debug(url);\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n  var es = this.es = new EventSourceDriver(url);\\r\\n  es.onmessage = function(e) {\\r\\n    debug('message', e.data);\\r\\n    self.emit('message', decodeURI(e.data));\\r\\n  };\\r\\n  es.onerror = function(e) {\\r\\n    debug('error', es.readyState, e);\\r\\n    // ES on reconnection has readyState = 0 or 1.\\r\\n    // on network error it's CLOSED = 2\\r\\n    var reason = (es.readyState !== 2 ? 'network' : 'permanent');\\r\\n    self._cleanup();\\r\\n    self._close(reason);\\r\\n  };\\r\\n}\\r\\n\\r\\ninherits(EventSourceReceiver, EventEmitter);\\r\\n\\r\\nEventSourceReceiver.prototype.abort = function() {\\r\\n  debug('abort');\\r\\n  this._cleanup();\\r\\n  this._close('user');\\r\\n};\\r\\n\\r\\nEventSourceReceiver.prototype._cleanup = function() {\\r\\n  debug('cleanup');\\r\\n  var es = this.es;\\r\\n  if (es) {\\r\\n    es.onmessage = es.onerror = null;\\r\\n    es.close();\\r\\n    this.es = null;\\r\\n  }\\r\\n};\\r\\n\\r\\nEventSourceReceiver.prototype._close = function(reason) {\\r\\n  debug('close', reason);\\r\\n  var self = this;\\r\\n  // Safari and chrome < 15 crash if we close window before\\r\\n  // waiting for ES cleanup. See:\\r\\n  // https://code.google.com/p/chromium/issues/detail?id=89155\\r\\n  setTimeout(function() {\\r\\n    self.emit('close', null, reason);\\r\\n    self.removeAllListeners();\\r\\n  }, 200);\\r\\n};\\r\\n\\r\\nmodule.exports = EventSourceReceiver;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"eventsource\\\":18,\\\"inherits\\\":57}],30:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , iframeUtils = require('../../utils/iframe')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  , random = require('../../utils/random')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:receiver:htmlfile');\\r\\n}\\r\\n\\r\\nfunction HtmlfileReceiver(url) {\\r\\n  debug(url);\\r\\n  EventEmitter.call(this);\\r\\n  var self = this;\\r\\n  iframeUtils.polluteGlobalNamespace();\\r\\n\\r\\n  this.id = 'a' + random.string(6);\\r\\n  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\\r\\n\\r\\n  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\\r\\n  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?\\r\\n      iframeUtils.createHtmlfile : iframeUtils.createIframe;\\r\\n\\r\\n  global[iframeUtils.WPrefix][this.id] = {\\r\\n    start: function() {\\r\\n      debug('start');\\r\\n      self.iframeObj.loaded();\\r\\n    }\\r\\n  , message: function(data) {\\r\\n      debug('message', data);\\r\\n      self.emit('message', data);\\r\\n    }\\r\\n  , stop: function() {\\r\\n      debug('stop');\\r\\n      self._cleanup();\\r\\n      self._close('network');\\r\\n    }\\r\\n  };\\r\\n  this.iframeObj = constructFunc(url, function() {\\r\\n    debug('callback');\\r\\n    self._cleanup();\\r\\n    self._close('permanent');\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(HtmlfileReceiver, EventEmitter);\\r\\n\\r\\nHtmlfileReceiver.prototype.abort = function() {\\r\\n  debug('abort');\\r\\n  this._cleanup();\\r\\n  this._close('user');\\r\\n};\\r\\n\\r\\nHtmlfileReceiver.prototype._cleanup = function() {\\r\\n  debug('_cleanup');\\r\\n  if (this.iframeObj) {\\r\\n    this.iframeObj.cleanup();\\r\\n    this.iframeObj = null;\\r\\n  }\\r\\n  delete global[iframeUtils.WPrefix][this.id];\\r\\n};\\r\\n\\r\\nHtmlfileReceiver.prototype._close = function(reason) {\\r\\n  debug('_close', reason);\\r\\n  this.emit('close', null, reason);\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nHtmlfileReceiver.htmlfileEnabled = false;\\r\\n\\r\\n// obfuscate to avoid firewalls\\r\\nvar axo = ['Active'].concat('Object').join('X');\\r\\nif (axo in global) {\\r\\n  try {\\r\\n    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\\r\\n  } catch (x) {\\r\\n    // intentionally empty\\r\\n  }\\r\\n}\\r\\n\\r\\nHtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\\r\\n\\r\\nmodule.exports = HtmlfileReceiver;\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/iframe\\\":47,\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],31:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar utils = require('../../utils/iframe')\\r\\n  , random = require('../../utils/random')\\r\\n  , browser = require('../../utils/browser')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  , inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:receiver:jsonp');\\r\\n}\\r\\n\\r\\nfunction JsonpReceiver(url) {\\r\\n  debug(url);\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  utils.polluteGlobalNamespace();\\r\\n\\r\\n  this.id = 'a' + random.string(6);\\r\\n  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\\r\\n\\r\\n  global[utils.WPrefix][this.id] = this._callback.bind(this);\\r\\n  this._createScript(urlWithId);\\r\\n\\r\\n  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\\r\\n  this.timeoutId = setTimeout(function() {\\r\\n    debug('timeout');\\r\\n    self._abort(new Error('JSONP script loaded abnormally (timeout)'));\\r\\n  }, JsonpReceiver.timeout);\\r\\n}\\r\\n\\r\\ninherits(JsonpReceiver, EventEmitter);\\r\\n\\r\\nJsonpReceiver.prototype.abort = function() {\\r\\n  debug('abort');\\r\\n  if (global[utils.WPrefix][this.id]) {\\r\\n    var err = new Error('JSONP user aborted read');\\r\\n    err.code = 1000;\\r\\n    this._abort(err);\\r\\n  }\\r\\n};\\r\\n\\r\\nJsonpReceiver.timeout = 35000;\\r\\nJsonpReceiver.scriptErrorTimeout = 1000;\\r\\n\\r\\nJsonpReceiver.prototype._callback = function(data) {\\r\\n  debug('_callback', data);\\r\\n  this._cleanup();\\r\\n\\r\\n  if (this.aborting) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (data) {\\r\\n    debug('message', data);\\r\\n    this.emit('message', data);\\r\\n  }\\r\\n  this.emit('close', null, 'network');\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nJsonpReceiver.prototype._abort = function(err) {\\r\\n  debug('_abort', err);\\r\\n  this._cleanup();\\r\\n  this.aborting = true;\\r\\n  this.emit('close', err.code, err.message);\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nJsonpReceiver.prototype._cleanup = function() {\\r\\n  debug('_cleanup');\\r\\n  clearTimeout(this.timeoutId);\\r\\n  if (this.script2) {\\r\\n    this.script2.parentNode.removeChild(this.script2);\\r\\n    this.script2 = null;\\r\\n  }\\r\\n  if (this.script) {\\r\\n    var script = this.script;\\r\\n    // Unfortunately, you can't really abort script loading of\\r\\n    // the script.\\r\\n    script.parentNode.removeChild(script);\\r\\n    script.onreadystatechange = script.onerror =\\r\\n        script.onload = script.onclick = null;\\r\\n    this.script = null;\\r\\n  }\\r\\n  delete global[utils.WPrefix][this.id];\\r\\n};\\r\\n\\r\\nJsonpReceiver.prototype._scriptError = function() {\\r\\n  debug('_scriptError');\\r\\n  var self = this;\\r\\n  if (this.errorTimer) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  this.errorTimer = setTimeout(function() {\\r\\n    if (!self.loadedOkay) {\\r\\n      self._abort(new Error('JSONP script loaded abnormally (onerror)'));\\r\\n    }\\r\\n  }, JsonpReceiver.scriptErrorTimeout);\\r\\n};\\r\\n\\r\\nJsonpReceiver.prototype._createScript = function(url) {\\r\\n  debug('_createScript', url);\\r\\n  var self = this;\\r\\n  var script = this.script = global.document.createElement('script');\\r\\n  var script2;  // Opera synchronous load trick.\\r\\n\\r\\n  script.id = 'a' + random.string(8);\\r\\n  script.src = url;\\r\\n  script.type = 'text/javascript';\\r\\n  script.charset = 'UTF-8';\\r\\n  script.onerror = this._scriptError.bind(this);\\r\\n  script.onload = function() {\\r\\n    debug('onload');\\r\\n    self._abort(new Error('JSONP script loaded abnormally (onload)'));\\r\\n  };\\r\\n\\r\\n  // IE9 fires 'error' event after onreadystatechange or before, in random order.\\r\\n  // Use loadedOkay to determine if actually errored\\r\\n  script.onreadystatechange = function() {\\r\\n    debug('onreadystatechange', script.readyState);\\r\\n    if (/loaded|closed/.test(script.readyState)) {\\r\\n      if (script && script.htmlFor && script.onclick) {\\r\\n        self.loadedOkay = true;\\r\\n        try {\\r\\n          // In IE, actually execute the script.\\r\\n          script.onclick();\\r\\n        } catch (x) {\\r\\n          // intentionally empty\\r\\n        }\\r\\n      }\\r\\n      if (script) {\\r\\n        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n  // IE: event/htmlFor/onclick trick.\\r\\n  // One can't rely on proper order for onreadystatechange. In order to\\r\\n  // make sure, set a 'htmlFor' and 'event' properties, so that\\r\\n  // script code will be installed as 'onclick' handler for the\\r\\n  // script object. Later, onreadystatechange, manually execute this\\r\\n  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\\r\\n  // set. For reference see:\\r\\n  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\\r\\n  // Also, read on that about script ordering:\\r\\n  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\\r\\n  if (typeof script.async === 'undefined' && global.document.attachEvent) {\\r\\n    // According to mozilla docs, in recent browsers script.async defaults\\r\\n    // to 'true', so we may use it to detect a good browser:\\r\\n    // https://developer.mozilla.org/en/HTML/Element/script\\r\\n    if (!browser.isOpera()) {\\r\\n      // Naively assume we're in IE\\r\\n      try {\\r\\n        script.htmlFor = script.id;\\r\\n        script.event = 'onclick';\\r\\n      } catch (x) {\\r\\n        // intentionally empty\\r\\n      }\\r\\n      script.async = true;\\r\\n    } else {\\r\\n      // Opera, second sync script hack\\r\\n      script2 = this.script2 = global.document.createElement('script');\\r\\n      script2.text = \\\"try{var a = document.getElementById('\\\" + script.id + \\\"'); if(a)a.onerror();}catch(x){};\\\";\\r\\n      script.async = script2.async = false;\\r\\n    }\\r\\n  }\\r\\n  if (typeof script.async !== 'undefined') {\\r\\n    script.async = true;\\r\\n  }\\r\\n\\r\\n  var head = global.document.getElementsByTagName('head')[0];\\r\\n  head.insertBefore(script, head.firstChild);\\r\\n  if (script2) {\\r\\n    head.insertBefore(script2, head.firstChild);\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = JsonpReceiver;\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/browser\\\":44,\\\"../../utils/iframe\\\":47,\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],32:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:receiver:xhr');\\r\\n}\\r\\n\\r\\nfunction XhrReceiver(url, AjaxObject) {\\r\\n  debug(url);\\r\\n  EventEmitter.call(this);\\r\\n  var self = this;\\r\\n\\r\\n  this.bufferPosition = 0;\\r\\n\\r\\n  this.xo = new AjaxObject('POST', url, null);\\r\\n  this.xo.on('chunk', this._chunkHandler.bind(this));\\r\\n  this.xo.once('finish', function(status, text) {\\r\\n    debug('finish', status, text);\\r\\n    self._chunkHandler(status, text);\\r\\n    self.xo = null;\\r\\n    var reason = status === 200 ? 'network' : 'permanent';\\r\\n    debug('close', reason);\\r\\n    self.emit('close', null, reason);\\r\\n    self._cleanup();\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(XhrReceiver, EventEmitter);\\r\\n\\r\\nXhrReceiver.prototype._chunkHandler = function(status, text) {\\r\\n  debug('_chunkHandler', status);\\r\\n  if (status !== 200 || !text) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  for (var idx = -1; ; this.bufferPosition += idx + 1) {\\r\\n    var buf = text.slice(this.bufferPosition);\\r\\n    idx = buf.indexOf('\\\\n');\\r\\n    if (idx === -1) {\\r\\n      break;\\r\\n    }\\r\\n    var msg = buf.slice(0, idx);\\r\\n    if (msg) {\\r\\n      debug('message', msg);\\r\\n      this.emit('message', msg);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nXhrReceiver.prototype._cleanup = function() {\\r\\n  debug('_cleanup');\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nXhrReceiver.prototype.abort = function() {\\r\\n  debug('abort');\\r\\n  if (this.xo) {\\r\\n    this.xo.close();\\r\\n    debug('close');\\r\\n    this.emit('close', null, 'user');\\r\\n    this.xo = null;\\r\\n  }\\r\\n  this._cleanup();\\r\\n};\\r\\n\\r\\nmodule.exports = XhrReceiver;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],33:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar random = require('../../utils/random')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:sender:jsonp');\\r\\n}\\r\\n\\r\\nvar form, area;\\r\\n\\r\\nfunction createIframe(id) {\\r\\n  debug('createIframe', id);\\r\\n  try {\\r\\n    // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\r\\n    return global.document.createElement('<iframe name=\\\"' + id + '\\\">');\\r\\n  } catch (x) {\\r\\n    var iframe = global.document.createElement('iframe');\\r\\n    iframe.name = id;\\r\\n    return iframe;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createForm() {\\r\\n  debug('createForm');\\r\\n  form = global.document.createElement('form');\\r\\n  form.style.display = 'none';\\r\\n  form.style.position = 'absolute';\\r\\n  form.method = 'POST';\\r\\n  form.enctype = 'application/x-www-form-urlencoded';\\r\\n  form.acceptCharset = 'UTF-8';\\r\\n\\r\\n  area = global.document.createElement('textarea');\\r\\n  area.name = 'd';\\r\\n  form.appendChild(area);\\r\\n\\r\\n  global.document.body.appendChild(form);\\r\\n}\\r\\n\\r\\nmodule.exports = function(url, payload, callback) {\\r\\n  debug(url, payload);\\r\\n  if (!form) {\\r\\n    createForm();\\r\\n  }\\r\\n  var id = 'a' + random.string(8);\\r\\n  form.target = id;\\r\\n  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\\r\\n\\r\\n  var iframe = createIframe(id);\\r\\n  iframe.id = id;\\r\\n  iframe.style.display = 'none';\\r\\n  form.appendChild(iframe);\\r\\n\\r\\n  try {\\r\\n    area.value = payload;\\r\\n  } catch (e) {\\r\\n    // seriously broken browsers get here\\r\\n  }\\r\\n  form.submit();\\r\\n\\r\\n  var completed = function(err) {\\r\\n    debug('completed', id, err);\\r\\n    if (!iframe.onerror) {\\r\\n      return;\\r\\n    }\\r\\n    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\\r\\n    // Opera mini doesn't like if we GC iframe\\r\\n    // immediately, thus this timeout.\\r\\n    setTimeout(function() {\\r\\n      debug('cleaning up', id);\\r\\n      iframe.parentNode.removeChild(iframe);\\r\\n      iframe = null;\\r\\n    }, 500);\\r\\n    area.value = '';\\r\\n    // It is not possible to detect if the iframe succeeded or\\r\\n    // failed to submit our form.\\r\\n    callback(err);\\r\\n  };\\r\\n  iframe.onerror = function() {\\r\\n    debug('onerror', id);\\r\\n    completed();\\r\\n  };\\r\\n  iframe.onload = function() {\\r\\n    debug('onload', id);\\r\\n    completed();\\r\\n  };\\r\\n  iframe.onreadystatechange = function(e) {\\r\\n    debug('onreadystatechange', id, iframe.readyState, e);\\r\\n    if (iframe.readyState === 'complete') {\\r\\n      completed();\\r\\n    }\\r\\n  };\\r\\n  return function() {\\r\\n    debug('aborted', id);\\r\\n    completed(new Error('Aborted'));\\r\\n  };\\r\\n};\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55}],34:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  , eventUtils = require('../../utils/event')\\r\\n  , browser = require('../../utils/browser')\\r\\n  , urlUtils = require('../../utils/url')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:sender:xdr');\\r\\n}\\r\\n\\r\\n// References:\\r\\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\\r\\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\\r\\n\\r\\nfunction XDRObject(method, url, payload) {\\r\\n  debug(method, url);\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  setTimeout(function() {\\r\\n    self._start(method, url, payload);\\r\\n  }, 0);\\r\\n}\\r\\n\\r\\ninherits(XDRObject, EventEmitter);\\r\\n\\r\\nXDRObject.prototype._start = function(method, url, payload) {\\r\\n  debug('_start');\\r\\n  var self = this;\\r\\n  var xdr = new global.XDomainRequest();\\r\\n  // IE caches even POSTs\\r\\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\\r\\n\\r\\n  xdr.onerror = function() {\\r\\n    debug('onerror');\\r\\n    self._error();\\r\\n  };\\r\\n  xdr.ontimeout = function() {\\r\\n    debug('ontimeout');\\r\\n    self._error();\\r\\n  };\\r\\n  xdr.onprogress = function() {\\r\\n    debug('progress', xdr.responseText);\\r\\n    self.emit('chunk', 200, xdr.responseText);\\r\\n  };\\r\\n  xdr.onload = function() {\\r\\n    debug('load');\\r\\n    self.emit('finish', 200, xdr.responseText);\\r\\n    self._cleanup(false);\\r\\n  };\\r\\n  this.xdr = xdr;\\r\\n  this.unloadRef = eventUtils.unloadAdd(function() {\\r\\n    self._cleanup(true);\\r\\n  });\\r\\n  try {\\r\\n    // Fails with AccessDenied if port number is bogus\\r\\n    this.xdr.open(method, url);\\r\\n    if (this.timeout) {\\r\\n      this.xdr.timeout = this.timeout;\\r\\n    }\\r\\n    this.xdr.send(payload);\\r\\n  } catch (x) {\\r\\n    this._error();\\r\\n  }\\r\\n};\\r\\n\\r\\nXDRObject.prototype._error = function() {\\r\\n  this.emit('finish', 0, '');\\r\\n  this._cleanup(false);\\r\\n};\\r\\n\\r\\nXDRObject.prototype._cleanup = function(abort) {\\r\\n  debug('cleanup', abort);\\r\\n  if (!this.xdr) {\\r\\n    return;\\r\\n  }\\r\\n  this.removeAllListeners();\\r\\n  eventUtils.unloadDel(this.unloadRef);\\r\\n\\r\\n  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\\r\\n  if (abort) {\\r\\n    try {\\r\\n      this.xdr.abort();\\r\\n    } catch (x) {\\r\\n      // intentionally empty\\r\\n    }\\r\\n  }\\r\\n  this.unloadRef = this.xdr = null;\\r\\n};\\r\\n\\r\\nXDRObject.prototype.close = function() {\\r\\n  debug('close');\\r\\n  this._cleanup(true);\\r\\n};\\r\\n\\r\\n// IE 8/9 if the request target uses the same scheme - #79\\r\\nXDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\\r\\n\\r\\nmodule.exports = XDRObject;\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../../utils/browser\\\":44,\\\"../../utils/event\\\":46,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],35:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , XhrDriver = require('../driver/xhr')\\r\\n  ;\\r\\n\\r\\nfunction XHRCorsObject(method, url, payload, opts) {\\r\\n  XhrDriver.call(this, method, url, payload, opts);\\r\\n}\\r\\n\\r\\ninherits(XHRCorsObject, XhrDriver);\\r\\n\\r\\nXHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\\r\\n\\r\\nmodule.exports = XHRCorsObject;\\r\\n\\r\\n},{\\\"../driver/xhr\\\":17,\\\"inherits\\\":57}],36:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar EventEmitter = require('events').EventEmitter\\r\\n  , inherits = require('inherits')\\r\\n  ;\\r\\n\\r\\nfunction XHRFake(/* method, url, payload, opts */) {\\r\\n  var self = this;\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  this.to = setTimeout(function() {\\r\\n    self.emit('finish', 200, '{}');\\r\\n  }, XHRFake.timeout);\\r\\n}\\r\\n\\r\\ninherits(XHRFake, EventEmitter);\\r\\n\\r\\nXHRFake.prototype.close = function() {\\r\\n  clearTimeout(this.to);\\r\\n};\\r\\n\\r\\nXHRFake.timeout = 2000;\\r\\n\\r\\nmodule.exports = XHRFake;\\r\\n\\r\\n},{\\\"events\\\":3,\\\"inherits\\\":57}],37:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , XhrDriver = require('../driver/xhr')\\r\\n  ;\\r\\n\\r\\nfunction XHRLocalObject(method, url, payload /*, opts */) {\\r\\n  XhrDriver.call(this, method, url, payload, {\\r\\n    noCredentials: true\\r\\n  });\\r\\n}\\r\\n\\r\\ninherits(XHRLocalObject, XhrDriver);\\r\\n\\r\\nXHRLocalObject.enabled = XhrDriver.enabled;\\r\\n\\r\\nmodule.exports = XHRLocalObject;\\r\\n\\r\\n},{\\\"../driver/xhr\\\":17,\\\"inherits\\\":57}],38:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar utils = require('../utils/event')\\r\\n  , urlUtils = require('../utils/url')\\r\\n  , inherits = require('inherits')\\r\\n  , EventEmitter = require('events').EventEmitter\\r\\n  , WebsocketDriver = require('./driver/websocket')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:websocket');\\r\\n}\\r\\n\\r\\nfunction WebSocketTransport(transUrl, ignore, options) {\\r\\n  if (!WebSocketTransport.enabled()) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n  debug('constructor', transUrl);\\r\\n\\r\\n  var self = this;\\r\\n  var url = urlUtils.addPath(transUrl, '/websocket');\\r\\n  if (url.slice(0, 5) === 'https') {\\r\\n    url = 'wss' + url.slice(5);\\r\\n  } else {\\r\\n    url = 'ws' + url.slice(4);\\r\\n  }\\r\\n  this.url = url;\\r\\n\\r\\n  this.ws = new WebsocketDriver(this.url, [], options);\\r\\n  this.ws.onmessage = function(e) {\\r\\n    debug('message event', e.data);\\r\\n    self.emit('message', e.data);\\r\\n  };\\r\\n  // Firefox has an interesting bug. If a websocket connection is\\r\\n  // created after onunload, it stays alive even when user\\r\\n  // navigates away from the page. In such situation let's lie -\\r\\n  // let's not open the ws connection at all. See:\\r\\n  // https://github.com/sockjs/sockjs-client/issues/28\\r\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\\r\\n  this.unloadRef = utils.unloadAdd(function() {\\r\\n    debug('unload');\\r\\n    self.ws.close();\\r\\n  });\\r\\n  this.ws.onclose = function(e) {\\r\\n    debug('close event', e.code, e.reason);\\r\\n    self.emit('close', e.code, e.reason);\\r\\n    self._cleanup();\\r\\n  };\\r\\n  this.ws.onerror = function(e) {\\r\\n    debug('error event', e);\\r\\n    self.emit('close', 1006, 'WebSocket connection broken');\\r\\n    self._cleanup();\\r\\n  };\\r\\n}\\r\\n\\r\\ninherits(WebSocketTransport, EventEmitter);\\r\\n\\r\\nWebSocketTransport.prototype.send = function(data) {\\r\\n  var msg = '[' + data + ']';\\r\\n  debug('send', msg);\\r\\n  this.ws.send(msg);\\r\\n};\\r\\n\\r\\nWebSocketTransport.prototype.close = function() {\\r\\n  debug('close');\\r\\n  var ws = this.ws;\\r\\n  this._cleanup();\\r\\n  if (ws) {\\r\\n    ws.close();\\r\\n  }\\r\\n};\\r\\n\\r\\nWebSocketTransport.prototype._cleanup = function() {\\r\\n  debug('_cleanup');\\r\\n  var ws = this.ws;\\r\\n  if (ws) {\\r\\n    ws.onmessage = ws.onclose = ws.onerror = null;\\r\\n  }\\r\\n  utils.unloadDel(this.unloadRef);\\r\\n  this.unloadRef = this.ws = null;\\r\\n  this.removeAllListeners();\\r\\n};\\r\\n\\r\\nWebSocketTransport.enabled = function() {\\r\\n  debug('enabled');\\r\\n  return !!WebsocketDriver;\\r\\n};\\r\\nWebSocketTransport.transportName = 'websocket';\\r\\n\\r\\n// In theory, ws should require 1 round trip. But in chrome, this is\\r\\n// not very stable over SSL. Most likely a ws connection requires a\\r\\n// separate SSL connection, in which case 2 round trips are an\\r\\n// absolute minumum.\\r\\nWebSocketTransport.roundTrips = 2;\\r\\n\\r\\nmodule.exports = WebSocketTransport;\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"../utils/event\\\":46,\\\"../utils/url\\\":52,\\\"./driver/websocket\\\":19,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],39:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  , XdrStreamingTransport = require('./xdr-streaming')\\r\\n  , XhrReceiver = require('./receiver/xhr')\\r\\n  , XDRObject = require('./sender/xdr')\\r\\n  ;\\r\\n\\r\\nfunction XdrPollingTransport(transUrl) {\\r\\n  if (!XDRObject.enabled) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\\r\\n}\\r\\n\\r\\ninherits(XdrPollingTransport, AjaxBasedTransport);\\r\\n\\r\\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\\r\\nXdrPollingTransport.transportName = 'xdr-polling';\\r\\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\\r\\n\\r\\nmodule.exports = XdrPollingTransport;\\r\\n\\r\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xdr\\\":34,\\\"./xdr-streaming\\\":40,\\\"inherits\\\":57}],40:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  , XhrReceiver = require('./receiver/xhr')\\r\\n  , XDRObject = require('./sender/xdr')\\r\\n  ;\\r\\n\\r\\n// According to:\\r\\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\\r\\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\\r\\n\\r\\nfunction XdrStreamingTransport(transUrl) {\\r\\n  if (!XDRObject.enabled) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\\r\\n}\\r\\n\\r\\ninherits(XdrStreamingTransport, AjaxBasedTransport);\\r\\n\\r\\nXdrStreamingTransport.enabled = function(info) {\\r\\n  if (info.cookie_needed || info.nullOrigin) {\\r\\n    return false;\\r\\n  }\\r\\n  return XDRObject.enabled && info.sameScheme;\\r\\n};\\r\\n\\r\\nXdrStreamingTransport.transportName = 'xdr-streaming';\\r\\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\\r\\n\\r\\nmodule.exports = XdrStreamingTransport;\\r\\n\\r\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xdr\\\":34,\\\"inherits\\\":57}],41:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  , XhrReceiver = require('./receiver/xhr')\\r\\n  , XHRCorsObject = require('./sender/xhr-cors')\\r\\n  , XHRLocalObject = require('./sender/xhr-local')\\r\\n  ;\\r\\n\\r\\nfunction XhrPollingTransport(transUrl) {\\r\\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\\r\\n}\\r\\n\\r\\ninherits(XhrPollingTransport, AjaxBasedTransport);\\r\\n\\r\\nXhrPollingTransport.enabled = function(info) {\\r\\n  if (info.nullOrigin) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  if (XHRLocalObject.enabled && info.sameOrigin) {\\r\\n    return true;\\r\\n  }\\r\\n  return XHRCorsObject.enabled;\\r\\n};\\r\\n\\r\\nXhrPollingTransport.transportName = 'xhr-polling';\\r\\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\\r\\n\\r\\nmodule.exports = XhrPollingTransport;\\r\\n\\r\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xhr-cors\\\":35,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],42:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar inherits = require('inherits')\\r\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\r\\n  , XhrReceiver = require('./receiver/xhr')\\r\\n  , XHRCorsObject = require('./sender/xhr-cors')\\r\\n  , XHRLocalObject = require('./sender/xhr-local')\\r\\n  , browser = require('../utils/browser')\\r\\n  ;\\r\\n\\r\\nfunction XhrStreamingTransport(transUrl) {\\r\\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\r\\n    throw new Error('Transport created when disabled');\\r\\n  }\\r\\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\\r\\n}\\r\\n\\r\\ninherits(XhrStreamingTransport, AjaxBasedTransport);\\r\\n\\r\\nXhrStreamingTransport.enabled = function(info) {\\r\\n  if (info.nullOrigin) {\\r\\n    return false;\\r\\n  }\\r\\n  // Opera doesn't support xhr-streaming #60\\r\\n  // But it might be able to #92\\r\\n  if (browser.isOpera()) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  return XHRCorsObject.enabled;\\r\\n};\\r\\n\\r\\nXhrStreamingTransport.transportName = 'xhr-streaming';\\r\\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\\r\\n\\r\\n// Safari gets confused when a streaming ajax request is started\\r\\n// before onload. This causes the load indicator to spin indefinetely.\\r\\n// Only require body when used in a browser\\r\\nXhrStreamingTransport.needBody = !!global.document;\\r\\n\\r\\nmodule.exports = XhrStreamingTransport;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"../utils/browser\\\":44,\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xhr-cors\\\":35,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],43:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nif (global.crypto && global.crypto.getRandomValues) {\\r\\n  module.exports.randomBytes = function(length) {\\r\\n    var bytes = new Uint8Array(length);\\r\\n    global.crypto.getRandomValues(bytes);\\r\\n    return bytes;\\r\\n  };\\r\\n} else {\\r\\n  module.exports.randomBytes = function(length) {\\r\\n    var bytes = new Array(length);\\r\\n    for (var i = 0; i < length; i++) {\\r\\n      bytes[i] = Math.floor(Math.random() * 256);\\r\\n    }\\r\\n    return bytes;\\r\\n  };\\r\\n}\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],44:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nmodule.exports = {\\r\\n  isOpera: function() {\\r\\n    return global.navigator &&\\r\\n      /opera/i.test(global.navigator.userAgent);\\r\\n  }\\r\\n\\r\\n, isKonqueror: function() {\\r\\n    return global.navigator &&\\r\\n      /konqueror/i.test(global.navigator.userAgent);\\r\\n  }\\r\\n\\r\\n  // #187 wrap document.domain in try/catch because of WP8 from file:///\\r\\n, hasDomain: function () {\\r\\n    // non-browser client always has a domain\\r\\n    if (!global.document) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      return !!global.document.domain;\\r\\n    } catch (e) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],45:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar JSON3 = require('json3');\\r\\n\\r\\n// Some extra characters that Chrome gets wrong, and substitutes with\\r\\n// something else on the wire.\\r\\n// eslint-disable-next-line no-control-regex\\r\\nvar extraEscapable = /[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff\\\\u0300-\\\\u0333\\\\u033d-\\\\u0346\\\\u034a-\\\\u034c\\\\u0350-\\\\u0352\\\\u0357-\\\\u0358\\\\u035c-\\\\u0362\\\\u0374\\\\u037e\\\\u0387\\\\u0591-\\\\u05af\\\\u05c4\\\\u0610-\\\\u0617\\\\u0653-\\\\u0654\\\\u0657-\\\\u065b\\\\u065d-\\\\u065e\\\\u06df-\\\\u06e2\\\\u06eb-\\\\u06ec\\\\u0730\\\\u0732-\\\\u0733\\\\u0735-\\\\u0736\\\\u073a\\\\u073d\\\\u073f-\\\\u0741\\\\u0743\\\\u0745\\\\u0747\\\\u07eb-\\\\u07f1\\\\u0951\\\\u0958-\\\\u095f\\\\u09dc-\\\\u09dd\\\\u09df\\\\u0a33\\\\u0a36\\\\u0a59-\\\\u0a5b\\\\u0a5e\\\\u0b5c-\\\\u0b5d\\\\u0e38-\\\\u0e39\\\\u0f43\\\\u0f4d\\\\u0f52\\\\u0f57\\\\u0f5c\\\\u0f69\\\\u0f72-\\\\u0f76\\\\u0f78\\\\u0f80-\\\\u0f83\\\\u0f93\\\\u0f9d\\\\u0fa2\\\\u0fa7\\\\u0fac\\\\u0fb9\\\\u1939-\\\\u193a\\\\u1a17\\\\u1b6b\\\\u1cda-\\\\u1cdb\\\\u1dc0-\\\\u1dcf\\\\u1dfc\\\\u1dfe\\\\u1f71\\\\u1f73\\\\u1f75\\\\u1f77\\\\u1f79\\\\u1f7b\\\\u1f7d\\\\u1fbb\\\\u1fbe\\\\u1fc9\\\\u1fcb\\\\u1fd3\\\\u1fdb\\\\u1fe3\\\\u1feb\\\\u1fee-\\\\u1fef\\\\u1ff9\\\\u1ffb\\\\u1ffd\\\\u2000-\\\\u2001\\\\u20d0-\\\\u20d1\\\\u20d4-\\\\u20d7\\\\u20e7-\\\\u20e9\\\\u2126\\\\u212a-\\\\u212b\\\\u2329-\\\\u232a\\\\u2adc\\\\u302b-\\\\u302c\\\\uaab2-\\\\uaab3\\\\uf900-\\\\ufa0d\\\\ufa10\\\\ufa12\\\\ufa15-\\\\ufa1e\\\\ufa20\\\\ufa22\\\\ufa25-\\\\ufa26\\\\ufa2a-\\\\ufa2d\\\\ufa30-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb1d\\\\ufb1f\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4e\\\\ufff0-\\\\uffff]/g\\r\\n  , extraLookup;\\r\\n\\r\\n// This may be quite slow, so let's delay until user actually uses bad\\r\\n// characters.\\r\\nvar unrollLookup = function(escapable) {\\r\\n  var i;\\r\\n  var unrolled = {};\\r\\n  var c = [];\\r\\n  for (i = 0; i < 65536; i++) {\\r\\n    c.push( String.fromCharCode(i) );\\r\\n  }\\r\\n  escapable.lastIndex = 0;\\r\\n  c.join('').replace(escapable, function(a) {\\r\\n    unrolled[ a ] = '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\r\\n    return '';\\r\\n  });\\r\\n  escapable.lastIndex = 0;\\r\\n  return unrolled;\\r\\n};\\r\\n\\r\\n// Quote string, also taking care of unicode characters that browsers\\r\\n// often break. Especially, take care of unicode surrogates:\\r\\n// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\\r\\nmodule.exports = {\\r\\n  quote: function(string) {\\r\\n    var quoted = JSON3.stringify(string);\\r\\n\\r\\n    // In most cases this should be very fast and good enough.\\r\\n    extraEscapable.lastIndex = 0;\\r\\n    if (!extraEscapable.test(quoted)) {\\r\\n      return quoted;\\r\\n    }\\r\\n\\r\\n    if (!extraLookup) {\\r\\n      extraLookup = unrollLookup(extraEscapable);\\r\\n    }\\r\\n\\r\\n    return quoted.replace(extraEscapable, function(a) {\\r\\n      return extraLookup[a];\\r\\n    });\\r\\n  }\\r\\n};\\r\\n\\r\\n},{\\\"json3\\\":58}],46:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar random = require('./random');\\r\\n\\r\\nvar onUnload = {}\\r\\n  , afterUnload = false\\r\\n    // detect google chrome packaged apps because they don't allow the 'unload' event\\r\\n  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime\\r\\n  ;\\r\\n\\r\\nmodule.exports = {\\r\\n  attachEvent: function(event, listener) {\\r\\n    if (typeof global.addEventListener !== 'undefined') {\\r\\n      global.addEventListener(event, listener, false);\\r\\n    } else if (global.document && global.attachEvent) {\\r\\n      // IE quirks.\\r\\n      // According to: http://stevesouders.com/misc/test-postmessage.php\\r\\n      // the message gets delivered only to 'document', not 'window'.\\r\\n      global.document.attachEvent('on' + event, listener);\\r\\n      // I get 'window' for ie8.\\r\\n      global.attachEvent('on' + event, listener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n, detachEvent: function(event, listener) {\\r\\n    if (typeof global.addEventListener !== 'undefined') {\\r\\n      global.removeEventListener(event, listener, false);\\r\\n    } else if (global.document && global.detachEvent) {\\r\\n      global.document.detachEvent('on' + event, listener);\\r\\n      global.detachEvent('on' + event, listener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n, unloadAdd: function(listener) {\\r\\n    if (isChromePackagedApp) {\\r\\n      return null;\\r\\n    }\\r\\n\\r\\n    var ref = random.string(8);\\r\\n    onUnload[ref] = listener;\\r\\n    if (afterUnload) {\\r\\n      setTimeout(this.triggerUnloadCallbacks, 0);\\r\\n    }\\r\\n    return ref;\\r\\n  }\\r\\n\\r\\n, unloadDel: function(ref) {\\r\\n    if (ref in onUnload) {\\r\\n      delete onUnload[ref];\\r\\n    }\\r\\n  }\\r\\n\\r\\n, triggerUnloadCallbacks: function() {\\r\\n    for (var ref in onUnload) {\\r\\n      onUnload[ref]();\\r\\n      delete onUnload[ref];\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nvar unloadTriggered = function() {\\r\\n  if (afterUnload) {\\r\\n    return;\\r\\n  }\\r\\n  afterUnload = true;\\r\\n  module.exports.triggerUnloadCallbacks();\\r\\n};\\r\\n\\r\\n// 'unload' alone is not reliable in opera within an iframe, but we\\r\\n// can't use `beforeunload` as IE fires it on javascript: links.\\r\\nif (!isChromePackagedApp) {\\r\\n  module.exports.attachEvent('unload', unloadTriggered);\\r\\n}\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./random\\\":50}],47:[function(require,module,exports){\\r\\n(function (process,global){\\r\\n'use strict';\\r\\n\\r\\nvar eventUtils = require('./event')\\r\\n  , JSON3 = require('json3')\\r\\n  , browser = require('./browser')\\r\\n  ;\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:utils:iframe');\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n  WPrefix: '_jp'\\r\\n, currentWindowId: null\\r\\n\\r\\n, polluteGlobalNamespace: function() {\\r\\n    if (!(module.exports.WPrefix in global)) {\\r\\n      global[module.exports.WPrefix] = {};\\r\\n    }\\r\\n  }\\r\\n\\r\\n, postMessage: function(type, data) {\\r\\n    if (global.parent !== global) {\\r\\n      global.parent.postMessage(JSON3.stringify({\\r\\n        windowId: module.exports.currentWindowId\\r\\n      , type: type\\r\\n      , data: data || ''\\r\\n      }), '*');\\r\\n    } else {\\r\\n      debug('Cannot postMessage, no parent window.', type, data);\\r\\n    }\\r\\n  }\\r\\n\\r\\n, createIframe: function(iframeUrl, errorCallback) {\\r\\n    var iframe = global.document.createElement('iframe');\\r\\n    var tref, unloadRef;\\r\\n    var unattach = function() {\\r\\n      debug('unattach');\\r\\n      clearTimeout(tref);\\r\\n      // Explorer had problems with that.\\r\\n      try {\\r\\n        iframe.onload = null;\\r\\n      } catch (x) {\\r\\n        // intentionally empty\\r\\n      }\\r\\n      iframe.onerror = null;\\r\\n    };\\r\\n    var cleanup = function() {\\r\\n      debug('cleanup');\\r\\n      if (iframe) {\\r\\n        unattach();\\r\\n        // This timeout makes chrome fire onbeforeunload event\\r\\n        // within iframe. Without the timeout it goes straight to\\r\\n        // onunload.\\r\\n        setTimeout(function() {\\r\\n          if (iframe) {\\r\\n            iframe.parentNode.removeChild(iframe);\\r\\n          }\\r\\n          iframe = null;\\r\\n        }, 0);\\r\\n        eventUtils.unloadDel(unloadRef);\\r\\n      }\\r\\n    };\\r\\n    var onerror = function(err) {\\r\\n      debug('onerror', err);\\r\\n      if (iframe) {\\r\\n        cleanup();\\r\\n        errorCallback(err);\\r\\n      }\\r\\n    };\\r\\n    var post = function(msg, origin) {\\r\\n      debug('post', msg, origin);\\r\\n      setTimeout(function() {\\r\\n        try {\\r\\n          // When the iframe is not loaded, IE raises an exception\\r\\n          // on 'contentWindow'.\\r\\n          if (iframe && iframe.contentWindow) {\\r\\n            iframe.contentWindow.postMessage(msg, origin);\\r\\n          }\\r\\n        } catch (x) {\\r\\n          // intentionally empty\\r\\n        }\\r\\n      }, 0);\\r\\n    };\\r\\n\\r\\n    iframe.src = iframeUrl;\\r\\n    iframe.style.display = 'none';\\r\\n    iframe.style.position = 'absolute';\\r\\n    iframe.onerror = function() {\\r\\n      onerror('onerror');\\r\\n    };\\r\\n    iframe.onload = function() {\\r\\n      debug('onload');\\r\\n      // `onload` is triggered before scripts on the iframe are\\r\\n      // executed. Give it few seconds to actually load stuff.\\r\\n      clearTimeout(tref);\\r\\n      tref = setTimeout(function() {\\r\\n        onerror('onload timeout');\\r\\n      }, 2000);\\r\\n    };\\r\\n    global.document.body.appendChild(iframe);\\r\\n    tref = setTimeout(function() {\\r\\n      onerror('timeout');\\r\\n    }, 15000);\\r\\n    unloadRef = eventUtils.unloadAdd(cleanup);\\r\\n    return {\\r\\n      post: post\\r\\n    , cleanup: cleanup\\r\\n    , loaded: unattach\\r\\n    };\\r\\n  }\\r\\n\\r\\n/* eslint no-undef: \\\"off\\\", new-cap: \\\"off\\\" */\\r\\n, createHtmlfile: function(iframeUrl, errorCallback) {\\r\\n    var axo = ['Active'].concat('Object').join('X');\\r\\n    var doc = new global[axo]('htmlfile');\\r\\n    var tref, unloadRef;\\r\\n    var iframe;\\r\\n    var unattach = function() {\\r\\n      clearTimeout(tref);\\r\\n      iframe.onerror = null;\\r\\n    };\\r\\n    var cleanup = function() {\\r\\n      if (doc) {\\r\\n        unattach();\\r\\n        eventUtils.unloadDel(unloadRef);\\r\\n        iframe.parentNode.removeChild(iframe);\\r\\n        iframe = doc = null;\\r\\n        CollectGarbage();\\r\\n      }\\r\\n    };\\r\\n    var onerror = function(r) {\\r\\n      debug('onerror', r);\\r\\n      if (doc) {\\r\\n        cleanup();\\r\\n        errorCallback(r);\\r\\n      }\\r\\n    };\\r\\n    var post = function(msg, origin) {\\r\\n      try {\\r\\n        // When the iframe is not loaded, IE raises an exception\\r\\n        // on 'contentWindow'.\\r\\n        setTimeout(function() {\\r\\n          if (iframe && iframe.contentWindow) {\\r\\n              iframe.contentWindow.postMessage(msg, origin);\\r\\n          }\\r\\n        }, 0);\\r\\n      } catch (x) {\\r\\n        // intentionally empty\\r\\n      }\\r\\n    };\\r\\n\\r\\n    doc.open();\\r\\n    doc.write('<html><s' + 'cript>' +\\r\\n              'document.domain=\\\"' + global.document.domain + '\\\";' +\\r\\n              '</s' + 'cript></html>');\\r\\n    doc.close();\\r\\n    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\\r\\n    var c = doc.createElement('div');\\r\\n    doc.body.appendChild(c);\\r\\n    iframe = doc.createElement('iframe');\\r\\n    c.appendChild(iframe);\\r\\n    iframe.src = iframeUrl;\\r\\n    iframe.onerror = function() {\\r\\n      onerror('onerror');\\r\\n    };\\r\\n    tref = setTimeout(function() {\\r\\n      onerror('timeout');\\r\\n    }, 15000);\\r\\n    unloadRef = eventUtils.unloadAdd(cleanup);\\r\\n    return {\\r\\n      post: post\\r\\n    , cleanup: cleanup\\r\\n    , loaded: unattach\\r\\n    };\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports.iframeEnabled = false;\\r\\nif (global.document) {\\r\\n  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\\r\\n  // huge delay, or not at all.\\r\\n  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||\\r\\n    typeof global.postMessage === 'object') && (!browser.isKonqueror());\\r\\n}\\r\\n\\r\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"./browser\\\":44,\\\"./event\\\":46,\\\"debug\\\":55,\\\"json3\\\":58}],48:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar logObject = {};\\r\\n['log', 'debug', 'warn'].forEach(function (level) {\\r\\n  var levelExists;\\r\\n\\r\\n  try {\\r\\n    levelExists = global.console && global.console[level] && global.console[level].apply;\\r\\n  } catch(e) {\\r\\n    // do nothing\\r\\n  }\\r\\n\\r\\n  logObject[level] = levelExists ? function () {\\r\\n    return global.console[level].apply(global.console, arguments);\\r\\n  } : (level === 'log' ? function () {} : logObject.log);\\r\\n});\\r\\n\\r\\nmodule.exports = logObject;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],49:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nmodule.exports = {\\r\\n  isObject: function(obj) {\\r\\n    var type = typeof obj;\\r\\n    return type === 'function' || type === 'object' && !!obj;\\r\\n  }\\r\\n\\r\\n, extend: function(obj) {\\r\\n    if (!this.isObject(obj)) {\\r\\n      return obj;\\r\\n    }\\r\\n    var source, prop;\\r\\n    for (var i = 1, length = arguments.length; i < length; i++) {\\r\\n      source = arguments[i];\\r\\n      for (prop in source) {\\r\\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\\r\\n          obj[prop] = source[prop];\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return obj;\\r\\n  }\\r\\n};\\r\\n\\r\\n},{}],50:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\n/* global crypto:true */\\r\\nvar crypto = require('crypto');\\r\\n\\r\\n// This string has length 32, a power of 2, so the modulus doesn't introduce a\\r\\n// bias.\\r\\nvar _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\\r\\nmodule.exports = {\\r\\n  string: function(length) {\\r\\n    var max = _randomStringChars.length;\\r\\n    var bytes = crypto.randomBytes(length);\\r\\n    var ret = [];\\r\\n    for (var i = 0; i < length; i++) {\\r\\n      ret.push(_randomStringChars.substr(bytes[i] % max, 1));\\r\\n    }\\r\\n    return ret.join('');\\r\\n  }\\r\\n\\r\\n, number: function(max) {\\r\\n    return Math.floor(Math.random() * max);\\r\\n  }\\r\\n\\r\\n, numberString: function(max) {\\r\\n    var t = ('' + (max - 1)).length;\\r\\n    var p = new Array(t + 1).join('0');\\r\\n    return (p + this.number(max)).slice(-t);\\r\\n  }\\r\\n};\\r\\n\\r\\n},{\\\"crypto\\\":43}],51:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:utils:transport');\\r\\n}\\r\\n\\r\\nmodule.exports = function(availableTransports) {\\r\\n  return {\\r\\n    filterToEnabled: function(transportsWhitelist, info) {\\r\\n      var transports = {\\r\\n        main: []\\r\\n      , facade: []\\r\\n      };\\r\\n      if (!transportsWhitelist) {\\r\\n        transportsWhitelist = [];\\r\\n      } else if (typeof transportsWhitelist === 'string') {\\r\\n        transportsWhitelist = [transportsWhitelist];\\r\\n      }\\r\\n\\r\\n      availableTransports.forEach(function(trans) {\\r\\n        if (!trans) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        if (trans.transportName === 'websocket' && info.websocket === false) {\\r\\n          debug('disabled from server', 'websocket');\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        if (transportsWhitelist.length &&\\r\\n            transportsWhitelist.indexOf(trans.transportName) === -1) {\\r\\n          debug('not in whitelist', trans.transportName);\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        if (trans.enabled(info)) {\\r\\n          debug('enabled', trans.transportName);\\r\\n          transports.main.push(trans);\\r\\n          if (trans.facadeTransport) {\\r\\n            transports.facade.push(trans.facadeTransport);\\r\\n          }\\r\\n        } else {\\r\\n          debug('disabled', trans.transportName);\\r\\n        }\\r\\n      });\\r\\n      return transports;\\r\\n    }\\r\\n  };\\r\\n};\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55}],52:[function(require,module,exports){\\r\\n(function (process){\\r\\n'use strict';\\r\\n\\r\\nvar URL = require('url-parse');\\r\\n\\r\\nvar debug = function() {};\\r\\nif (process.env.NODE_ENV !== 'production') {\\r\\n  debug = require('debug')('sockjs-client:utils:url');\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n  getOrigin: function(url) {\\r\\n    if (!url) {\\r\\n      return null;\\r\\n    }\\r\\n\\r\\n    var p = new URL(url);\\r\\n    if (p.protocol === 'file:') {\\r\\n      return null;\\r\\n    }\\r\\n\\r\\n    var port = p.port;\\r\\n    if (!port) {\\r\\n      port = (p.protocol === 'https:') ? '443' : '80';\\r\\n    }\\r\\n\\r\\n    return p.protocol + '//' + p.hostname + ':' + port;\\r\\n  }\\r\\n\\r\\n, isOriginEqual: function(a, b) {\\r\\n    var res = this.getOrigin(a) === this.getOrigin(b);\\r\\n    debug('same', a, b, res);\\r\\n    return res;\\r\\n  }\\r\\n\\r\\n, isSchemeEqual: function(a, b) {\\r\\n    return (a.split(':')[0] === b.split(':')[0]);\\r\\n  }\\r\\n\\r\\n, addPath: function (url, path) {\\r\\n    var qs = url.split('?');\\r\\n    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\\r\\n  }\\r\\n\\r\\n, addQuery: function (url, q) {\\r\\n    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));\\r\\n  }\\r\\n};\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"debug\\\":55,\\\"url-parse\\\":61}],53:[function(require,module,exports){\\r\\nmodule.exports = '1.3.0';\\r\\n\\r\\n},{}],54:[function(require,module,exports){\\r\\n/**\\r\\n * Helpers.\\r\\n */\\r\\n\\r\\nvar s = 1000;\\r\\nvar m = s * 60;\\r\\nvar h = m * 60;\\r\\nvar d = h * 24;\\r\\nvar w = d * 7;\\r\\nvar y = d * 365.25;\\r\\n\\r\\n/**\\r\\n * Parse or format the given `val`.\\r\\n *\\r\\n * Options:\\r\\n *\\r\\n *  - `long` verbose formatting [false]\\r\\n *\\r\\n * @param {String|Number} val\\r\\n * @param {Object} [options]\\r\\n * @throws {Error} throw an error if val is not a non-empty string or a number\\r\\n * @return {String|Number}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function(val, options) {\\r\\n  options = options || {};\\r\\n  var type = typeof val;\\r\\n  if (type === 'string' && val.length > 0) {\\r\\n    return parse(val);\\r\\n  } else if (type === 'number' && isNaN(val) === false) {\\r\\n    return options.long ? fmtLong(val) : fmtShort(val);\\r\\n  }\\r\\n  throw new Error(\\r\\n    'val is not a non-empty string or a valid number. val=' +\\r\\n      JSON.stringify(val)\\r\\n  );\\r\\n};\\r\\n\\r\\n/**\\r\\n * Parse the given `str` and return milliseconds.\\r\\n *\\r\\n * @param {String} str\\r\\n * @return {Number}\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction parse(str) {\\r\\n  str = String(str);\\r\\n  if (str.length > 100) {\\r\\n    return;\\r\\n  }\\r\\n  var match = /^((?:\\\\d+)?\\\\-?\\\\d?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\\r\\n    str\\r\\n  );\\r\\n  if (!match) {\\r\\n    return;\\r\\n  }\\r\\n  var n = parseFloat(match[1]);\\r\\n  var type = (match[2] || 'ms').toLowerCase();\\r\\n  switch (type) {\\r\\n    case 'years':\\r\\n    case 'year':\\r\\n    case 'yrs':\\r\\n    case 'yr':\\r\\n    case 'y':\\r\\n      return n * y;\\r\\n    case 'weeks':\\r\\n    case 'week':\\r\\n    case 'w':\\r\\n      return n * w;\\r\\n    case 'days':\\r\\n    case 'day':\\r\\n    case 'd':\\r\\n      return n * d;\\r\\n    case 'hours':\\r\\n    case 'hour':\\r\\n    case 'hrs':\\r\\n    case 'hr':\\r\\n    case 'h':\\r\\n      return n * h;\\r\\n    case 'minutes':\\r\\n    case 'minute':\\r\\n    case 'mins':\\r\\n    case 'min':\\r\\n    case 'm':\\r\\n      return n * m;\\r\\n    case 'seconds':\\r\\n    case 'second':\\r\\n    case 'secs':\\r\\n    case 'sec':\\r\\n    case 's':\\r\\n      return n * s;\\r\\n    case 'milliseconds':\\r\\n    case 'millisecond':\\r\\n    case 'msecs':\\r\\n    case 'msec':\\r\\n    case 'ms':\\r\\n      return n;\\r\\n    default:\\r\\n      return undefined;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Short format for `ms`.\\r\\n *\\r\\n * @param {Number} ms\\r\\n * @return {String}\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction fmtShort(ms) {\\r\\n  var msAbs = Math.abs(ms);\\r\\n  if (msAbs >= d) {\\r\\n    return Math.round(ms / d) + 'd';\\r\\n  }\\r\\n  if (msAbs >= h) {\\r\\n    return Math.round(ms / h) + 'h';\\r\\n  }\\r\\n  if (msAbs >= m) {\\r\\n    return Math.round(ms / m) + 'm';\\r\\n  }\\r\\n  if (msAbs >= s) {\\r\\n    return Math.round(ms / s) + 's';\\r\\n  }\\r\\n  return ms + 'ms';\\r\\n}\\r\\n\\r\\n/**\\r\\n * Long format for `ms`.\\r\\n *\\r\\n * @param {Number} ms\\r\\n * @return {String}\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction fmtLong(ms) {\\r\\n  var msAbs = Math.abs(ms);\\r\\n  if (msAbs >= d) {\\r\\n    return plural(ms, msAbs, d, 'day');\\r\\n  }\\r\\n  if (msAbs >= h) {\\r\\n    return plural(ms, msAbs, h, 'hour');\\r\\n  }\\r\\n  if (msAbs >= m) {\\r\\n    return plural(ms, msAbs, m, 'minute');\\r\\n  }\\r\\n  if (msAbs >= s) {\\r\\n    return plural(ms, msAbs, s, 'second');\\r\\n  }\\r\\n  return ms + ' ms';\\r\\n}\\r\\n\\r\\n/**\\r\\n * Pluralization helper.\\r\\n */\\r\\n\\r\\nfunction plural(ms, msAbs, n, name) {\\r\\n  var isPlural = msAbs >= n * 1.5;\\r\\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\\r\\n}\\r\\n\\r\\n},{}],55:[function(require,module,exports){\\r\\n(function (process){\\r\\n\\\"use strict\\\";\\r\\n\\r\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\r\\n\\r\\n/* eslint-env browser */\\r\\n\\r\\n/**\\r\\n * This is the web browser implementation of `debug()`.\\r\\n */\\r\\nexports.log = log;\\r\\nexports.formatArgs = formatArgs;\\r\\nexports.save = save;\\r\\nexports.load = load;\\r\\nexports.useColors = useColors;\\r\\nexports.storage = localstorage();\\r\\n/**\\r\\n * Colors.\\r\\n */\\r\\n\\r\\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\\r\\n/**\\r\\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\\r\\n * and the Firebug extension (any Firefox version) are known\\r\\n * to support \\\"%c\\\" CSS customizations.\\r\\n *\\r\\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\\r\\n */\\r\\n// eslint-disable-next-line complexity\\r\\n\\r\\nfunction useColors() {\\r\\n  // NB: In an Electron preload script, document will be defined but not fully\\r\\n  // initialized. Since we know we're in Chrome, we'll just detect this case\\r\\n  // explicitly\\r\\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\\r\\n    return true;\\r\\n  } // Internet Explorer and Edge do not support colors.\\r\\n\\r\\n\\r\\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\\\/(\\\\d+)/)) {\\r\\n    return false;\\r\\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\\r\\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\\r\\n\\r\\n\\r\\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\\r\\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\\r\\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\\r\\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\\r\\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);\\r\\n}\\r\\n/**\\r\\n * Colorize log arguments if enabled.\\r\\n *\\r\\n * @api public\\r\\n */\\r\\n\\r\\n\\r\\nfunction formatArgs(args) {\\r\\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\\r\\n\\r\\n  if (!this.useColors) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  var c = 'color: ' + this.color;\\r\\n  args.splice(1, 0, c, 'color: inherit'); // The final \\\"%c\\\" is somewhat tricky, because there could be other\\r\\n  // arguments passed either before or after the %c, so we need to\\r\\n  // figure out the correct index to insert the CSS into\\r\\n\\r\\n  var index = 0;\\r\\n  var lastC = 0;\\r\\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\\r\\n    if (match === '%%') {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    index++;\\r\\n\\r\\n    if (match === '%c') {\\r\\n      // We only are interested in the *last* %c\\r\\n      // (the user may have provided their own)\\r\\n      lastC = index;\\r\\n    }\\r\\n  });\\r\\n  args.splice(lastC, 0, c);\\r\\n}\\r\\n/**\\r\\n * Invokes `console.log()` when available.\\r\\n * No-op when `console.log` is not a \\\"function\\\".\\r\\n *\\r\\n * @api public\\r\\n */\\r\\n\\r\\n\\r\\nfunction log() {\\r\\n  var _console;\\r\\n\\r\\n  // This hackery is required for IE8/9, where\\r\\n  // the `console.log` function doesn't have 'apply'\\r\\n  return (typeof console === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\\r\\n}\\r\\n/**\\r\\n * Save `namespaces`.\\r\\n *\\r\\n * @param {String} namespaces\\r\\n * @api private\\r\\n */\\r\\n\\r\\n\\r\\nfunction save(namespaces) {\\r\\n  try {\\r\\n    if (namespaces) {\\r\\n      exports.storage.setItem('debug', namespaces);\\r\\n    } else {\\r\\n      exports.storage.removeItem('debug');\\r\\n    }\\r\\n  } catch (error) {// Swallow\\r\\n    // XXX (@Qix-) should we be logging these?\\r\\n  }\\r\\n}\\r\\n/**\\r\\n * Load `namespaces`.\\r\\n *\\r\\n * @return {String} returns the previously persisted debug modes\\r\\n * @api private\\r\\n */\\r\\n\\r\\n\\r\\nfunction load() {\\r\\n  var r;\\r\\n\\r\\n  try {\\r\\n    r = exports.storage.getItem('debug');\\r\\n  } catch (error) {} // Swallow\\r\\n  // XXX (@Qix-) should we be logging these?\\r\\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\\r\\n\\r\\n\\r\\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\\r\\n    r = process.env.DEBUG;\\r\\n  }\\r\\n\\r\\n  return r;\\r\\n}\\r\\n/**\\r\\n * Localstorage attempts to return the localstorage.\\r\\n *\\r\\n * This is necessary because safari throws\\r\\n * when a user disables cookies/localstorage\\r\\n * and you attempt to access it.\\r\\n *\\r\\n * @return {LocalStorage}\\r\\n * @api private\\r\\n */\\r\\n\\r\\n\\r\\nfunction localstorage() {\\r\\n  try {\\r\\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\\r\\n    // The Browser also has localStorage in the global context.\\r\\n    return localStorage;\\r\\n  } catch (error) {// Swallow\\r\\n    // XXX (@Qix-) should we be logging these?\\r\\n  }\\r\\n}\\r\\n\\r\\nmodule.exports = require('./common')(exports);\\r\\nvar formatters = module.exports.formatters;\\r\\n/**\\r\\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\\r\\n */\\r\\n\\r\\nformatters.j = function (v) {\\r\\n  try {\\r\\n    return JSON.stringify(v);\\r\\n  } catch (error) {\\r\\n    return '[UnexpectedJSONParseError]: ' + error.message;\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n}).call(this,{ env: {} })\\r\\n\\r\\n},{\\\"./common\\\":56}],56:[function(require,module,exports){\\r\\n\\\"use strict\\\";\\r\\n\\r\\n/**\\r\\n * This is the common logic for both the Node.js and web browser\\r\\n * implementations of `debug()`.\\r\\n */\\r\\nfunction setup(env) {\\r\\n  createDebug.debug = createDebug;\\r\\n  createDebug.default = createDebug;\\r\\n  createDebug.coerce = coerce;\\r\\n  createDebug.disable = disable;\\r\\n  createDebug.enable = enable;\\r\\n  createDebug.enabled = enabled;\\r\\n  createDebug.humanize = require('ms');\\r\\n  Object.keys(env).forEach(function (key) {\\r\\n    createDebug[key] = env[key];\\r\\n  });\\r\\n  /**\\r\\n  * Active `debug` instances.\\r\\n  */\\r\\n\\r\\n  createDebug.instances = [];\\r\\n  /**\\r\\n  * The currently active debug mode names, and names to skip.\\r\\n  */\\r\\n\\r\\n  createDebug.names = [];\\r\\n  createDebug.skips = [];\\r\\n  /**\\r\\n  * Map of special \\\"%n\\\" handling functions, for the debug \\\"format\\\" argument.\\r\\n  *\\r\\n  * Valid key names are a single, lower or upper-case letter, i.e. \\\"n\\\" and \\\"N\\\".\\r\\n  */\\r\\n\\r\\n  createDebug.formatters = {};\\r\\n  /**\\r\\n  * Selects a color for a debug namespace\\r\\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\\r\\n  * @return {Number|String} An ANSI color code for the given namespace\\r\\n  * @api private\\r\\n  */\\r\\n\\r\\n  function selectColor(namespace) {\\r\\n    var hash = 0;\\r\\n\\r\\n    for (var i = 0; i < namespace.length; i++) {\\r\\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\\r\\n      hash |= 0; // Convert to 32bit integer\\r\\n    }\\r\\n\\r\\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\\r\\n  }\\r\\n\\r\\n  createDebug.selectColor = selectColor;\\r\\n  /**\\r\\n  * Create a debugger with the given `namespace`.\\r\\n  *\\r\\n  * @param {String} namespace\\r\\n  * @return {Function}\\r\\n  * @api public\\r\\n  */\\r\\n\\r\\n  function createDebug(namespace) {\\r\\n    var prevTime;\\r\\n\\r\\n    function debug() {\\r\\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\r\\n        args[_key] = arguments[_key];\\r\\n      }\\r\\n\\r\\n      // Disabled?\\r\\n      if (!debug.enabled) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      var self = debug; // Set `diff` timestamp\\r\\n\\r\\n      var curr = Number(new Date());\\r\\n      var ms = curr - (prevTime || curr);\\r\\n      self.diff = ms;\\r\\n      self.prev = prevTime;\\r\\n      self.curr = curr;\\r\\n      prevTime = curr;\\r\\n      args[0] = createDebug.coerce(args[0]);\\r\\n\\r\\n      if (typeof args[0] !== 'string') {\\r\\n        // Anything else let's inspect with %O\\r\\n        args.unshift('%O');\\r\\n      } // Apply any `formatters` transformations\\r\\n\\r\\n\\r\\n      var index = 0;\\r\\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\\r\\n        // If we encounter an escaped % then don't increase the array index\\r\\n        if (match === '%%') {\\r\\n          return match;\\r\\n        }\\r\\n\\r\\n        index++;\\r\\n        var formatter = createDebug.formatters[format];\\r\\n\\r\\n        if (typeof formatter === 'function') {\\r\\n          var val = args[index];\\r\\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\\r\\n\\r\\n          args.splice(index, 1);\\r\\n          index--;\\r\\n        }\\r\\n\\r\\n        return match;\\r\\n      }); // Apply env-specific formatting (colors, etc.)\\r\\n\\r\\n      createDebug.formatArgs.call(self, args);\\r\\n      var logFn = self.log || createDebug.log;\\r\\n      logFn.apply(self, args);\\r\\n    }\\r\\n\\r\\n    debug.namespace = namespace;\\r\\n    debug.enabled = createDebug.enabled(namespace);\\r\\n    debug.useColors = createDebug.useColors();\\r\\n    debug.color = selectColor(namespace);\\r\\n    debug.destroy = destroy;\\r\\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\\r\\n    // debug.rawLog = rawLog;\\r\\n    // env-specific initialization logic for debug instances\\r\\n\\r\\n    if (typeof createDebug.init === 'function') {\\r\\n      createDebug.init(debug);\\r\\n    }\\r\\n\\r\\n    createDebug.instances.push(debug);\\r\\n    return debug;\\r\\n  }\\r\\n\\r\\n  function destroy() {\\r\\n    var index = createDebug.instances.indexOf(this);\\r\\n\\r\\n    if (index !== -1) {\\r\\n      createDebug.instances.splice(index, 1);\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  function extend(namespace, delimiter) {\\r\\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\\r\\n  }\\r\\n  /**\\r\\n  * Enables a debug mode by namespaces. This can include modes\\r\\n  * separated by a colon and wildcards.\\r\\n  *\\r\\n  * @param {String} namespaces\\r\\n  * @api public\\r\\n  */\\r\\n\\r\\n\\r\\n  function enable(namespaces) {\\r\\n    createDebug.save(namespaces);\\r\\n    createDebug.names = [];\\r\\n    createDebug.skips = [];\\r\\n    var i;\\r\\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);\\r\\n    var len = split.length;\\r\\n\\r\\n    for (i = 0; i < len; i++) {\\r\\n      if (!split[i]) {\\r\\n        // ignore empty strings\\r\\n        continue;\\r\\n      }\\r\\n\\r\\n      namespaces = split[i].replace(/\\\\*/g, '.*?');\\r\\n\\r\\n      if (namespaces[0] === '-') {\\r\\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\\r\\n      } else {\\r\\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    for (i = 0; i < createDebug.instances.length; i++) {\\r\\n      var instance = createDebug.instances[i];\\r\\n      instance.enabled = createDebug.enabled(instance.namespace);\\r\\n    }\\r\\n  }\\r\\n  /**\\r\\n  * Disable debug output.\\r\\n  *\\r\\n  * @api public\\r\\n  */\\r\\n\\r\\n\\r\\n  function disable() {\\r\\n    createDebug.enable('');\\r\\n  }\\r\\n  /**\\r\\n  * Returns true if the given mode name is enabled, false otherwise.\\r\\n  *\\r\\n  * @param {String} name\\r\\n  * @return {Boolean}\\r\\n  * @api public\\r\\n  */\\r\\n\\r\\n\\r\\n  function enabled(name) {\\r\\n    if (name[name.length - 1] === '*') {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    var i;\\r\\n    var len;\\r\\n\\r\\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\\r\\n      if (createDebug.skips[i].test(name)) {\\r\\n        return false;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\\r\\n      if (createDebug.names[i].test(name)) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n  }\\r\\n  /**\\r\\n  * Coerce `val`.\\r\\n  *\\r\\n  * @param {Mixed} val\\r\\n  * @return {Mixed}\\r\\n  * @api private\\r\\n  */\\r\\n\\r\\n\\r\\n  function coerce(val) {\\r\\n    if (val instanceof Error) {\\r\\n      return val.stack || val.message;\\r\\n    }\\r\\n\\r\\n    return val;\\r\\n  }\\r\\n\\r\\n  createDebug.enable(createDebug.load());\\r\\n  return createDebug;\\r\\n}\\r\\n\\r\\nmodule.exports = setup;\\r\\n\\r\\n\\r\\n},{\\\"ms\\\":54}],57:[function(require,module,exports){\\r\\nif (typeof Object.create === 'function') {\\r\\n  // implementation from standard node.js 'util' module\\r\\n  module.exports = function inherits(ctor, superCtor) {\\r\\n    ctor.super_ = superCtor\\r\\n    ctor.prototype = Object.create(superCtor.prototype, {\\r\\n      constructor: {\\r\\n        value: ctor,\\r\\n        enumerable: false,\\r\\n        writable: true,\\r\\n        configurable: true\\r\\n      }\\r\\n    });\\r\\n  };\\r\\n} else {\\r\\n  // old school shim for old browsers\\r\\n  module.exports = function inherits(ctor, superCtor) {\\r\\n    ctor.super_ = superCtor\\r\\n    var TempCtor = function () {}\\r\\n    TempCtor.prototype = superCtor.prototype\\r\\n    ctor.prototype = new TempCtor()\\r\\n    ctor.prototype.constructor = ctor\\r\\n  }\\r\\n}\\r\\n\\r\\n},{}],58:[function(require,module,exports){\\r\\n(function (global){\\r\\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\\r\\n;(function () {\\r\\n  // Detect the `define` function exposed by asynchronous module loaders. The\\r\\n  // strict `define` check is necessary for compatibility with `r.js`.\\r\\n  var isLoader = typeof define === \\\"function\\\" && define.amd;\\r\\n\\r\\n  // A set of types used to distinguish objects from primitives.\\r\\n  var objectTypes = {\\r\\n    \\\"function\\\": true,\\r\\n    \\\"object\\\": true\\r\\n  };\\r\\n\\r\\n  // Detect the `exports` object exposed by CommonJS implementations.\\r\\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\\r\\n\\r\\n  // Use the `global` object exposed by Node (including Browserify via\\r\\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\\r\\n  // and the `window` object in browsers. Rhino exports a `global` function\\r\\n  // instead.\\r\\n  var root = objectTypes[typeof window] && window || this,\\r\\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \\\"object\\\" && global;\\r\\n\\r\\n  if (freeGlobal && (freeGlobal[\\\"global\\\"] === freeGlobal || freeGlobal[\\\"window\\\"] === freeGlobal || freeGlobal[\\\"self\\\"] === freeGlobal)) {\\r\\n    root = freeGlobal;\\r\\n  }\\r\\n\\r\\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\\r\\n  // `stringify` and `parse` functions to the specified `exports` object.\\r\\n  function runInContext(context, exports) {\\r\\n    context || (context = root[\\\"Object\\\"]());\\r\\n    exports || (exports = root[\\\"Object\\\"]());\\r\\n\\r\\n    // Native constructor aliases.\\r\\n    var Number = context[\\\"Number\\\"] || root[\\\"Number\\\"],\\r\\n        String = context[\\\"String\\\"] || root[\\\"String\\\"],\\r\\n        Object = context[\\\"Object\\\"] || root[\\\"Object\\\"],\\r\\n        Date = context[\\\"Date\\\"] || root[\\\"Date\\\"],\\r\\n        SyntaxError = context[\\\"SyntaxError\\\"] || root[\\\"SyntaxError\\\"],\\r\\n        TypeError = context[\\\"TypeError\\\"] || root[\\\"TypeError\\\"],\\r\\n        Math = context[\\\"Math\\\"] || root[\\\"Math\\\"],\\r\\n        nativeJSON = context[\\\"JSON\\\"] || root[\\\"JSON\\\"];\\r\\n\\r\\n    // Delegate to the native `stringify` and `parse` implementations.\\r\\n    if (typeof nativeJSON == \\\"object\\\" && nativeJSON) {\\r\\n      exports.stringify = nativeJSON.stringify;\\r\\n      exports.parse = nativeJSON.parse;\\r\\n    }\\r\\n\\r\\n    // Convenience aliases.\\r\\n    var objectProto = Object.prototype,\\r\\n        getClass = objectProto.toString,\\r\\n        isProperty, forEach, undef;\\r\\n\\r\\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\\r\\n    var isExtended = new Date(-3509827334573292);\\r\\n    try {\\r\\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\\r\\n      // results for certain dates in Opera >= 10.53.\\r\\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\\r\\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\\r\\n        // but clips the values returned by the date methods to the range of\\r\\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\\r\\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\\r\\n    } catch (exception) {}\\r\\n\\r\\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\\r\\n    // implementations are spec-compliant. Based on work by Ken Snyder.\\r\\n    function has(name) {\\r\\n      if (has[name] !== undef) {\\r\\n        // Return cached feature test result.\\r\\n        return has[name];\\r\\n      }\\r\\n      var isSupported;\\r\\n      if (name == \\\"bug-string-char-index\\\") {\\r\\n        // IE <= 7 doesn't support accessing string characters using square\\r\\n        // bracket notation. IE 8 only supports this for primitives.\\r\\n        isSupported = \\\"a\\\"[0] != \\\"a\\\";\\r\\n      } else if (name == \\\"json\\\") {\\r\\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\\r\\n        // supported.\\r\\n        isSupported = has(\\\"json-stringify\\\") && has(\\\"json-parse\\\");\\r\\n      } else {\\r\\n        var value, serialized = '{\\\"a\\\":[1,true,false,null,\\\"\\\\\\\\u0000\\\\\\\\b\\\\\\\\n\\\\\\\\f\\\\\\\\r\\\\\\\\t\\\"]}';\\r\\n        // Test `JSON.stringify`.\\r\\n        if (name == \\\"json-stringify\\\") {\\r\\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \\\"function\\\" && isExtended;\\r\\n          if (stringifySupported) {\\r\\n            // A test function object with a custom `toJSON` method.\\r\\n            (value = function () {\\r\\n              return 1;\\r\\n            }).toJSON = value;\\r\\n            try {\\r\\n              stringifySupported =\\r\\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\\r\\n                // primitives as object literals.\\r\\n                stringify(0) === \\\"0\\\" &&\\r\\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\\r\\n                // literals.\\r\\n                stringify(new Number()) === \\\"0\\\" &&\\r\\n                stringify(new String()) == '\\\"\\\"' &&\\r\\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\\r\\n                // does not define a canonical JSON representation (this applies to\\r\\n                // objects with `toJSON` properties as well, *unless* they are nested\\r\\n                // within an object or array).\\r\\n                stringify(getClass) === undef &&\\r\\n                // IE 8 serializes `undefined` as `\\\"undefined\\\"`. Safari <= 5.1.7 and\\r\\n                // FF 3.1b3 pass this test.\\r\\n                stringify(undef) === undef &&\\r\\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\\r\\n                // respectively, if the value is omitted entirely.\\r\\n                stringify() === undef &&\\r\\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\\r\\n                // string, array, object, Boolean, or `null` literal. This applies to\\r\\n                // objects with custom `toJSON` methods as well, unless they are nested\\r\\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\\r\\n                // methods entirely.\\r\\n                stringify(value) === \\\"1\\\" &&\\r\\n                stringify([value]) == \\\"[1]\\\" &&\\r\\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\\\"[]\\\"` instead of\\r\\n                // `\\\"[null]\\\"`.\\r\\n                stringify([undef]) == \\\"[null]\\\" &&\\r\\n                // YUI 3.0.0b1 fails to serialize `null` literals.\\r\\n                stringify(null) == \\\"null\\\" &&\\r\\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\\r\\n                // `[1, true, getClass, 1]` serializes as \\\"[1,true,],\\\". FF 3.1b3\\r\\n                // elides non-JSON values from objects and arrays, unless they\\r\\n                // define custom `toJSON` methods.\\r\\n                stringify([undef, getClass, null]) == \\\"[null,null,null]\\\" &&\\r\\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\\r\\n                // where character escape codes are expected (e.g., `\\\\b` => `\\\\u0008`).\\r\\n                stringify({ \\\"a\\\": [value, true, false, null, \\\"\\\\x00\\\\b\\\\n\\\\f\\\\r\\\\t\\\"] }) == serialized &&\\r\\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\\r\\n                stringify(null, value) === \\\"1\\\" &&\\r\\n                stringify([1, 2], null, 1) == \\\"[\\\\n 1,\\\\n 2\\\\n]\\\" &&\\r\\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\\r\\n                // serialize extended years.\\r\\n                stringify(new Date(-8.64e15)) == '\\\"-271821-04-20T00:00:00.000Z\\\"' &&\\r\\n                // The milliseconds are optional in ES 5, but required in 5.1.\\r\\n                stringify(new Date(8.64e15)) == '\\\"+275760-09-13T00:00:00.000Z\\\"' &&\\r\\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\\r\\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\\r\\n                stringify(new Date(-621987552e5)) == '\\\"-000001-01-01T00:00:00.000Z\\\"' &&\\r\\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\\r\\n                // values less than 1000. Credits: @Yaffle.\\r\\n                stringify(new Date(-1)) == '\\\"1969-12-31T23:59:59.999Z\\\"';\\r\\n            } catch (exception) {\\r\\n              stringifySupported = false;\\r\\n            }\\r\\n          }\\r\\n          isSupported = stringifySupported;\\r\\n        }\\r\\n        // Test `JSON.parse`.\\r\\n        if (name == \\\"json-parse\\\") {\\r\\n          var parse = exports.parse;\\r\\n          if (typeof parse == \\\"function\\\") {\\r\\n            try {\\r\\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\\r\\n              // Conforming implementations should also coerce the initial argument to\\r\\n              // a string prior to parsing.\\r\\n              if (parse(\\\"0\\\") === 0 && !parse(false)) {\\r\\n                // Simple parsing test.\\r\\n                value = parse(serialized);\\r\\n                var parseSupported = value[\\\"a\\\"].length == 5 && value[\\\"a\\\"][0] === 1;\\r\\n                if (parseSupported) {\\r\\n                  try {\\r\\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\\r\\n                    parseSupported = !parse('\\\"\\\\t\\\"');\\r\\n                  } catch (exception) {}\\r\\n                  if (parseSupported) {\\r\\n                    try {\\r\\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\\r\\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\\r\\n                      // certain octal literals.\\r\\n                      parseSupported = parse(\\\"01\\\") !== 1;\\r\\n                    } catch (exception) {}\\r\\n                  }\\r\\n                  if (parseSupported) {\\r\\n                    try {\\r\\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\\r\\n                      // points. These environments, along with FF 3.1b1 and 2,\\r\\n                      // also allow trailing commas in JSON objects and arrays.\\r\\n                      parseSupported = parse(\\\"1.\\\") !== 1;\\r\\n                    } catch (exception) {}\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            } catch (exception) {\\r\\n              parseSupported = false;\\r\\n            }\\r\\n          }\\r\\n          isSupported = parseSupported;\\r\\n        }\\r\\n      }\\r\\n      return has[name] = !!isSupported;\\r\\n    }\\r\\n\\r\\n    if (!has(\\\"json\\\")) {\\r\\n      // Common `[[Class]]` name aliases.\\r\\n      var functionClass = \\\"[object Function]\\\",\\r\\n          dateClass = \\\"[object Date]\\\",\\r\\n          numberClass = \\\"[object Number]\\\",\\r\\n          stringClass = \\\"[object String]\\\",\\r\\n          arrayClass = \\\"[object Array]\\\",\\r\\n          booleanClass = \\\"[object Boolean]\\\";\\r\\n\\r\\n      // Detect incomplete support for accessing string characters by index.\\r\\n      var charIndexBuggy = has(\\\"bug-string-char-index\\\");\\r\\n\\r\\n      // Define additional utility methods if the `Date` methods are buggy.\\r\\n      if (!isExtended) {\\r\\n        var floor = Math.floor;\\r\\n        // A mapping between the months of the year and the number of days between\\r\\n        // January 1st and the first of the respective month.\\r\\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\\r\\n        // Internal: Calculates the number of days between the Unix epoch and the\\r\\n        // first day of the given month.\\r\\n        var getDay = function (year, month) {\\r\\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\\r\\n        };\\r\\n      }\\r\\n\\r\\n      // Internal: Determines if a property is a direct property of the given\\r\\n      // object. Delegates to the native `Object#hasOwnProperty` method.\\r\\n      if (!(isProperty = objectProto.hasOwnProperty)) {\\r\\n        isProperty = function (property) {\\r\\n          var members = {}, constructor;\\r\\n          if ((members.__proto__ = null, members.__proto__ = {\\r\\n            // The *proto* property cannot be set multiple times in recent\\r\\n            // versions of Firefox and SeaMonkey.\\r\\n            \\\"toString\\\": 1\\r\\n          }, members).toString != getClass) {\\r\\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\\r\\n            // supports the mutable *proto* property.\\r\\n            isProperty = function (property) {\\r\\n              // Capture and break the object's prototype chain (see section 8.6.2\\r\\n              // of the ES 5.1 spec). The parenthesized expression prevents an\\r\\n              // unsafe transformation by the Closure Compiler.\\r\\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\\r\\n              // Restore the original prototype chain.\\r\\n              this.__proto__ = original;\\r\\n              return result;\\r\\n            };\\r\\n          } else {\\r\\n            // Capture a reference to the top-level `Object` constructor.\\r\\n            constructor = members.constructor;\\r\\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\\r\\n            // other environments.\\r\\n            isProperty = function (property) {\\r\\n              var parent = (this.constructor || constructor).prototype;\\r\\n              return property in this && !(property in parent && this[property] === parent[property]);\\r\\n            };\\r\\n          }\\r\\n          members = null;\\r\\n          return isProperty.call(this, property);\\r\\n        };\\r\\n      }\\r\\n\\r\\n      // Internal: Normalizes the `for...in` iteration algorithm across\\r\\n      // environments. Each enumerated key is yielded to a `callback` function.\\r\\n      forEach = function (object, callback) {\\r\\n        var size = 0, Properties, members, property;\\r\\n\\r\\n        // Tests for bugs in the current environment's `for...in` algorithm. The\\r\\n        // `valueOf` property inherits the non-enumerable flag from\\r\\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\\r\\n        (Properties = function () {\\r\\n          this.valueOf = 0;\\r\\n        }).prototype.valueOf = 0;\\r\\n\\r\\n        // Iterate over a new instance of the `Properties` class.\\r\\n        members = new Properties();\\r\\n        for (property in members) {\\r\\n          // Ignore all properties inherited from `Object.prototype`.\\r\\n          if (isProperty.call(members, property)) {\\r\\n            size++;\\r\\n          }\\r\\n        }\\r\\n        Properties = members = null;\\r\\n\\r\\n        // Normalize the iteration algorithm.\\r\\n        if (!size) {\\r\\n          // A list of non-enumerable properties inherited from `Object.prototype`.\\r\\n          members = [\\\"valueOf\\\", \\\"toString\\\", \\\"toLocaleString\\\", \\\"propertyIsEnumerable\\\", \\\"isPrototypeOf\\\", \\\"hasOwnProperty\\\", \\\"constructor\\\"];\\r\\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\\r\\n          // properties.\\r\\n          forEach = function (object, callback) {\\r\\n            var isFunction = getClass.call(object) == functionClass, property, length;\\r\\n            var hasProperty = !isFunction && typeof object.constructor != \\\"function\\\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\\r\\n            for (property in object) {\\r\\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\\r\\n              // certain conditions; IE does not.\\r\\n              if (!(isFunction && property == \\\"prototype\\\") && hasProperty.call(object, property)) {\\r\\n                callback(property);\\r\\n              }\\r\\n            }\\r\\n            // Manually invoke the callback for each non-enumerable property.\\r\\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\\r\\n          };\\r\\n        } else if (size == 2) {\\r\\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\\r\\n          forEach = function (object, callback) {\\r\\n            // Create a set of iterated properties.\\r\\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\\r\\n            for (property in object) {\\r\\n              // Store each property name to prevent double enumeration. The\\r\\n              // `prototype` property of functions is not enumerated due to cross-\\r\\n              // environment inconsistencies.\\r\\n              if (!(isFunction && property == \\\"prototype\\\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\\r\\n                callback(property);\\r\\n              }\\r\\n            }\\r\\n          };\\r\\n        } else {\\r\\n          // No bugs detected; use the standard `for...in` algorithm.\\r\\n          forEach = function (object, callback) {\\r\\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\\r\\n            for (property in object) {\\r\\n              if (!(isFunction && property == \\\"prototype\\\") && isProperty.call(object, property) && !(isConstructor = property === \\\"constructor\\\")) {\\r\\n                callback(property);\\r\\n              }\\r\\n            }\\r\\n            // Manually invoke the callback for the `constructor` property due to\\r\\n            // cross-environment inconsistencies.\\r\\n            if (isConstructor || isProperty.call(object, (property = \\\"constructor\\\"))) {\\r\\n              callback(property);\\r\\n            }\\r\\n          };\\r\\n        }\\r\\n        return forEach(object, callback);\\r\\n      };\\r\\n\\r\\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\\r\\n      // `filter` argument may specify either a function that alters how object and\\r\\n      // array members are serialized, or an array of strings and numbers that\\r\\n      // indicates which properties should be serialized. The optional `width`\\r\\n      // argument may be either a string or number that specifies the indentation\\r\\n      // level of the output.\\r\\n      if (!has(\\\"json-stringify\\\")) {\\r\\n        // Internal: A map of control characters and their escaped equivalents.\\r\\n        var Escapes = {\\r\\n          92: \\\"\\\\\\\\\\\\\\\\\\\",\\r\\n          34: '\\\\\\\\\\\"',\\r\\n          8: \\\"\\\\\\\\b\\\",\\r\\n          12: \\\"\\\\\\\\f\\\",\\r\\n          10: \\\"\\\\\\\\n\\\",\\r\\n          13: \\\"\\\\\\\\r\\\",\\r\\n          9: \\\"\\\\\\\\t\\\"\\r\\n        };\\r\\n\\r\\n        // Internal: Converts `value` into a zero-padded string such that its\\r\\n        // length is at least equal to `width`. The `width` must be <= 6.\\r\\n        var leadingZeroes = \\\"000000\\\";\\r\\n        var toPaddedString = function (width, value) {\\r\\n          // The `|| 0` expression is necessary to work around a bug in\\r\\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \\\"0\\\"`.\\r\\n          return (leadingZeroes + (value || 0)).slice(-width);\\r\\n        };\\r\\n\\r\\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\\r\\n        // characters (characters with code unit values between 0 and 31) with\\r\\n        // their escaped equivalents. This is an implementation of the\\r\\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\\r\\n        var unicodePrefix = \\\"\\\\\\\\u00\\\";\\r\\n        var quote = function (value) {\\r\\n          var result = '\\\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\\r\\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\\\"\\\") : value);\\r\\n          for (; index < length; index++) {\\r\\n            var charCode = value.charCodeAt(index);\\r\\n            // If the character is a control character, append its Unicode or\\r\\n            // shorthand escape sequence; otherwise, append the character as-is.\\r\\n            switch (charCode) {\\r\\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\\r\\n                result += Escapes[charCode];\\r\\n                break;\\r\\n              default:\\r\\n                if (charCode < 32) {\\r\\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\\r\\n                  break;\\r\\n                }\\r\\n                result += useCharIndex ? symbols[index] : value.charAt(index);\\r\\n            }\\r\\n          }\\r\\n          return result + '\\\"';\\r\\n        };\\r\\n\\r\\n        // Internal: Recursively serializes an object. Implements the\\r\\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\\r\\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\\r\\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\\r\\n          try {\\r\\n            // Necessary for host object support.\\r\\n            value = object[property];\\r\\n          } catch (exception) {}\\r\\n          if (typeof value == \\\"object\\\" && value) {\\r\\n            className = getClass.call(value);\\r\\n            if (className == dateClass && !isProperty.call(value, \\\"toJSON\\\")) {\\r\\n              if (value > -1 / 0 && value < 1 / 0) {\\r\\n                // Dates are serialized according to the `Date#toJSON` method\\r\\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\\r\\n                // for the ISO 8601 date time string format.\\r\\n                if (getDay) {\\r\\n                  // Manually compute the year, month, date, hours, minutes,\\r\\n                  // seconds, and milliseconds if the `getUTC*` methods are\\r\\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\\r\\n                  date = floor(value / 864e5);\\r\\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\\r\\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\\r\\n                  date = 1 + date - getDay(year, month);\\r\\n                  // The `time` value specifies the time within the day (see ES\\r\\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\\r\\n                  // to compute `A modulo B`, as the `%` operator does not\\r\\n                  // correspond to the `modulo` operation for negative numbers.\\r\\n                  time = (value % 864e5 + 864e5) % 864e5;\\r\\n                  // The hours, minutes, seconds, and milliseconds are obtained by\\r\\n                  // decomposing the time within the day. See section 15.9.1.10.\\r\\n                  hours = floor(time / 36e5) % 24;\\r\\n                  minutes = floor(time / 6e4) % 60;\\r\\n                  seconds = floor(time / 1e3) % 60;\\r\\n                  milliseconds = time % 1e3;\\r\\n                } else {\\r\\n                  year = value.getUTCFullYear();\\r\\n                  month = value.getUTCMonth();\\r\\n                  date = value.getUTCDate();\\r\\n                  hours = value.getUTCHours();\\r\\n                  minutes = value.getUTCMinutes();\\r\\n                  seconds = value.getUTCSeconds();\\r\\n                  milliseconds = value.getUTCMilliseconds();\\r\\n                }\\r\\n                // Serialize extended years correctly.\\r\\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \\\"-\\\" : \\\"+\\\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\\r\\n                  \\\"-\\\" + toPaddedString(2, month + 1) + \\\"-\\\" + toPaddedString(2, date) +\\r\\n                  // Months, dates, hours, minutes, and seconds should have two\\r\\n                  // digits; milliseconds should have three.\\r\\n                  \\\"T\\\" + toPaddedString(2, hours) + \\\":\\\" + toPaddedString(2, minutes) + \\\":\\\" + toPaddedString(2, seconds) +\\r\\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\\r\\n                  \\\".\\\" + toPaddedString(3, milliseconds) + \\\"Z\\\";\\r\\n              } else {\\r\\n                value = null;\\r\\n              }\\r\\n            } else if (typeof value.toJSON == \\\"function\\\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \\\"toJSON\\\"))) {\\r\\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\\r\\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\\r\\n              // ignores all `toJSON` methods on these objects unless they are\\r\\n              // defined directly on an instance.\\r\\n              value = value.toJSON(property);\\r\\n            }\\r\\n          }\\r\\n          if (callback) {\\r\\n            // If a replacement function was provided, call it to obtain the value\\r\\n            // for serialization.\\r\\n            value = callback.call(object, property, value);\\r\\n          }\\r\\n          if (value === null) {\\r\\n            return \\\"null\\\";\\r\\n          }\\r\\n          className = getClass.call(value);\\r\\n          if (className == booleanClass) {\\r\\n            // Booleans are represented literally.\\r\\n            return \\\"\\\" + value;\\r\\n          } else if (className == numberClass) {\\r\\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\\r\\n            // `\\\"null\\\"`.\\r\\n            return value > -1 / 0 && value < 1 / 0 ? \\\"\\\" + value : \\\"null\\\";\\r\\n          } else if (className == stringClass) {\\r\\n            // Strings are double-quoted and escaped.\\r\\n            return quote(\\\"\\\" + value);\\r\\n          }\\r\\n          // Recursively serialize objects and arrays.\\r\\n          if (typeof value == \\\"object\\\") {\\r\\n            // Check for cyclic structures. This is a linear search; performance\\r\\n            // is inversely proportional to the number of unique nested objects.\\r\\n            for (length = stack.length; length--;) {\\r\\n              if (stack[length] === value) {\\r\\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\\r\\n                throw TypeError();\\r\\n              }\\r\\n            }\\r\\n            // Add the object to the stack of traversed objects.\\r\\n            stack.push(value);\\r\\n            results = [];\\r\\n            // Save the current indentation level and indent one additional level.\\r\\n            prefix = indentation;\\r\\n            indentation += whitespace;\\r\\n            if (className == arrayClass) {\\r\\n              // Recursively serialize array elements.\\r\\n              for (index = 0, length = value.length; index < length; index++) {\\r\\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\\r\\n                results.push(element === undef ? \\\"null\\\" : element);\\r\\n              }\\r\\n              result = results.length ? (whitespace ? \\\"[\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"]\\\" : (\\\"[\\\" + results.join(\\\",\\\") + \\\"]\\\")) : \\\"[]\\\";\\r\\n            } else {\\r\\n              // Recursively serialize object members. Members are selected from\\r\\n              // either a user-specified list of property names, or the object\\r\\n              // itself.\\r\\n              forEach(properties || value, function (property) {\\r\\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\\r\\n                if (element !== undef) {\\r\\n                  // According to ES 5.1 section 15.12.3: \\\"If `gap` {whitespace}\\r\\n                  // is not the empty string, let `member` {quote(property) + \\\":\\\"}\\r\\n                  // be the concatenation of `member` and the `space` character.\\\"\\r\\n                  // The \\\"`space` character\\\" refers to the literal space\\r\\n                  // character, not the `space` {width} argument provided to\\r\\n                  // `JSON.stringify`.\\r\\n                  results.push(quote(property) + \\\":\\\" + (whitespace ? \\\" \\\" : \\\"\\\") + element);\\r\\n                }\\r\\n              });\\r\\n              result = results.length ? (whitespace ? \\\"{\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"}\\\" : (\\\"{\\\" + results.join(\\\",\\\") + \\\"}\\\")) : \\\"{}\\\";\\r\\n            }\\r\\n            // Remove the object from the traversed object stack.\\r\\n            stack.pop();\\r\\n            return result;\\r\\n          }\\r\\n        };\\r\\n\\r\\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\\r\\n        exports.stringify = function (source, filter, width) {\\r\\n          var whitespace, callback, properties, className;\\r\\n          if (objectTypes[typeof filter] && filter) {\\r\\n            if ((className = getClass.call(filter)) == functionClass) {\\r\\n              callback = filter;\\r\\n            } else if (className == arrayClass) {\\r\\n              // Convert the property names array into a makeshift set.\\r\\n              properties = {};\\r\\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\\r\\n            }\\r\\n          }\\r\\n          if (width) {\\r\\n            if ((className = getClass.call(width)) == numberClass) {\\r\\n              // Convert the `width` to an integer and create a string containing\\r\\n              // `width` number of space characters.\\r\\n              if ((width -= width % 1) > 0) {\\r\\n                for (whitespace = \\\"\\\", width > 10 && (width = 10); whitespace.length < width; whitespace += \\\" \\\");\\r\\n              }\\r\\n            } else if (className == stringClass) {\\r\\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\\r\\n            }\\r\\n          }\\r\\n          // Opera <= 7.54u2 discards the values associated with empty string keys\\r\\n          // (`\\\"\\\"`) only if they are used directly within an object member list\\r\\n          // (e.g., `!(\\\"\\\" in { \\\"\\\": 1})`).\\r\\n          return serialize(\\\"\\\", (value = {}, value[\\\"\\\"] = source, value), callback, properties, whitespace, \\\"\\\", []);\\r\\n        };\\r\\n      }\\r\\n\\r\\n      // Public: Parses a JSON source string.\\r\\n      if (!has(\\\"json-parse\\\")) {\\r\\n        var fromCharCode = String.fromCharCode;\\r\\n\\r\\n        // Internal: A map of escaped control characters and their unescaped\\r\\n        // equivalents.\\r\\n        var Unescapes = {\\r\\n          92: \\\"\\\\\\\\\\\",\\r\\n          34: '\\\"',\\r\\n          47: \\\"/\\\",\\r\\n          98: \\\"\\\\b\\\",\\r\\n          116: \\\"\\\\t\\\",\\r\\n          110: \\\"\\\\n\\\",\\r\\n          102: \\\"\\\\f\\\",\\r\\n          114: \\\"\\\\r\\\"\\r\\n        };\\r\\n\\r\\n        // Internal: Stores the parser state.\\r\\n        var Index, Source;\\r\\n\\r\\n        // Internal: Resets the parser state and throws a `SyntaxError`.\\r\\n        var abort = function () {\\r\\n          Index = Source = null;\\r\\n          throw SyntaxError();\\r\\n        };\\r\\n\\r\\n        // Internal: Returns the next token, or `\\\"$\\\"` if the parser has reached\\r\\n        // the end of the source string. A token may be a string, number, `null`\\r\\n        // literal, or Boolean literal.\\r\\n        var lex = function () {\\r\\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\\r\\n          while (Index < length) {\\r\\n            charCode = source.charCodeAt(Index);\\r\\n            switch (charCode) {\\r\\n              case 9: case 10: case 13: case 32:\\r\\n                // Skip whitespace tokens, including tabs, carriage returns, line\\r\\n                // feeds, and space characters.\\r\\n                Index++;\\r\\n                break;\\r\\n              case 123: case 125: case 91: case 93: case 58: case 44:\\r\\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\\r\\n                // the current position.\\r\\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\\r\\n                Index++;\\r\\n                return value;\\r\\n              case 34:\\r\\n                // `\\\"` delimits a JSON string; advance to the next character and\\r\\n                // begin parsing the string. String tokens are prefixed with the\\r\\n                // sentinel `@` character to distinguish them from punctuators and\\r\\n                // end-of-string tokens.\\r\\n                for (value = \\\"@\\\", Index++; Index < length;) {\\r\\n                  charCode = source.charCodeAt(Index);\\r\\n                  if (charCode < 32) {\\r\\n                    // Unescaped ASCII control characters (those with a code unit\\r\\n                    // less than the space character) are not permitted.\\r\\n                    abort();\\r\\n                  } else if (charCode == 92) {\\r\\n                    // A reverse solidus (`\\\\`) marks the beginning of an escaped\\r\\n                    // control character (including `\\\"`, `\\\\`, and `/`) or Unicode\\r\\n                    // escape sequence.\\r\\n                    charCode = source.charCodeAt(++Index);\\r\\n                    switch (charCode) {\\r\\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\\r\\n                        // Revive escaped control characters.\\r\\n                        value += Unescapes[charCode];\\r\\n                        Index++;\\r\\n                        break;\\r\\n                      case 117:\\r\\n                        // `\\\\u` marks the beginning of a Unicode escape sequence.\\r\\n                        // Advance to the first character and validate the\\r\\n                        // four-digit code point.\\r\\n                        begin = ++Index;\\r\\n                        for (position = Index + 4; Index < position; Index++) {\\r\\n                          charCode = source.charCodeAt(Index);\\r\\n                          // A valid sequence comprises four hexdigits (case-\\r\\n                          // insensitive) that form a single hexadecimal value.\\r\\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\\r\\n                            // Invalid Unicode escape sequence.\\r\\n                            abort();\\r\\n                          }\\r\\n                        }\\r\\n                        // Revive the escaped character.\\r\\n                        value += fromCharCode(\\\"0x\\\" + source.slice(begin, Index));\\r\\n                        break;\\r\\n                      default:\\r\\n                        // Invalid escape sequence.\\r\\n                        abort();\\r\\n                    }\\r\\n                  } else {\\r\\n                    if (charCode == 34) {\\r\\n                      // An unescaped double-quote character marks the end of the\\r\\n                      // string.\\r\\n                      break;\\r\\n                    }\\r\\n                    charCode = source.charCodeAt(Index);\\r\\n                    begin = Index;\\r\\n                    // Optimize for the common case where a string is valid.\\r\\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\\r\\n                      charCode = source.charCodeAt(++Index);\\r\\n                    }\\r\\n                    // Append the string as-is.\\r\\n                    value += source.slice(begin, Index);\\r\\n                  }\\r\\n                }\\r\\n                if (source.charCodeAt(Index) == 34) {\\r\\n                  // Advance to the next character and return the revived string.\\r\\n                  Index++;\\r\\n                  return value;\\r\\n                }\\r\\n                // Unterminated string.\\r\\n                abort();\\r\\n              default:\\r\\n                // Parse numbers and literals.\\r\\n                begin = Index;\\r\\n                // Advance past the negative sign, if one is specified.\\r\\n                if (charCode == 45) {\\r\\n                  isSigned = true;\\r\\n                  charCode = source.charCodeAt(++Index);\\r\\n                }\\r\\n                // Parse an integer or floating-point value.\\r\\n                if (charCode >= 48 && charCode <= 57) {\\r\\n                  // Leading zeroes are interpreted as octal literals.\\r\\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\\r\\n                    // Illegal octal literal.\\r\\n                    abort();\\r\\n                  }\\r\\n                  isSigned = false;\\r\\n                  // Parse the integer component.\\r\\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\\r\\n                  // Floats cannot contain a leading decimal point; however, this\\r\\n                  // case is already accounted for by the parser.\\r\\n                  if (source.charCodeAt(Index) == 46) {\\r\\n                    position = ++Index;\\r\\n                    // Parse the decimal component.\\r\\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\r\\n                    if (position == Index) {\\r\\n                      // Illegal trailing decimal.\\r\\n                      abort();\\r\\n                    }\\r\\n                    Index = position;\\r\\n                  }\\r\\n                  // Parse exponents. The `e` denoting the exponent is\\r\\n                  // case-insensitive.\\r\\n                  charCode = source.charCodeAt(Index);\\r\\n                  if (charCode == 101 || charCode == 69) {\\r\\n                    charCode = source.charCodeAt(++Index);\\r\\n                    // Skip past the sign following the exponent, if one is\\r\\n                    // specified.\\r\\n                    if (charCode == 43 || charCode == 45) {\\r\\n                      Index++;\\r\\n                    }\\r\\n                    // Parse the exponential component.\\r\\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\r\\n                    if (position == Index) {\\r\\n                      // Illegal empty exponent.\\r\\n                      abort();\\r\\n                    }\\r\\n                    Index = position;\\r\\n                  }\\r\\n                  // Coerce the parsed value to a JavaScript number.\\r\\n                  return +source.slice(begin, Index);\\r\\n                }\\r\\n                // A negative sign may only precede numbers.\\r\\n                if (isSigned) {\\r\\n                  abort();\\r\\n                }\\r\\n                // `true`, `false`, and `null` literals.\\r\\n                if (source.slice(Index, Index + 4) == \\\"true\\\") {\\r\\n                  Index += 4;\\r\\n                  return true;\\r\\n                } else if (source.slice(Index, Index + 5) == \\\"false\\\") {\\r\\n                  Index += 5;\\r\\n                  return false;\\r\\n                } else if (source.slice(Index, Index + 4) == \\\"null\\\") {\\r\\n                  Index += 4;\\r\\n                  return null;\\r\\n                }\\r\\n                // Unrecognized token.\\r\\n                abort();\\r\\n            }\\r\\n          }\\r\\n          // Return the sentinel `$` character if the parser has reached the end\\r\\n          // of the source string.\\r\\n          return \\\"$\\\";\\r\\n        };\\r\\n\\r\\n        // Internal: Parses a JSON `value` token.\\r\\n        var get = function (value) {\\r\\n          var results, hasMembers;\\r\\n          if (value == \\\"$\\\") {\\r\\n            // Unexpected end of input.\\r\\n            abort();\\r\\n          }\\r\\n          if (typeof value == \\\"string\\\") {\\r\\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \\\"@\\\") {\\r\\n              // Remove the sentinel `@` character.\\r\\n              return value.slice(1);\\r\\n            }\\r\\n            // Parse object and array literals.\\r\\n            if (value == \\\"[\\\") {\\r\\n              // Parses a JSON array, returning a new JavaScript array.\\r\\n              results = [];\\r\\n              for (;; hasMembers || (hasMembers = true)) {\\r\\n                value = lex();\\r\\n                // A closing square bracket marks the end of the array literal.\\r\\n                if (value == \\\"]\\\") {\\r\\n                  break;\\r\\n                }\\r\\n                // If the array literal contains elements, the current token\\r\\n                // should be a comma separating the previous element from the\\r\\n                // next.\\r\\n                if (hasMembers) {\\r\\n                  if (value == \\\",\\\") {\\r\\n                    value = lex();\\r\\n                    if (value == \\\"]\\\") {\\r\\n                      // Unexpected trailing `,` in array literal.\\r\\n                      abort();\\r\\n                    }\\r\\n                  } else {\\r\\n                    // A `,` must separate each array element.\\r\\n                    abort();\\r\\n                  }\\r\\n                }\\r\\n                // Elisions and leading commas are not permitted.\\r\\n                if (value == \\\",\\\") {\\r\\n                  abort();\\r\\n                }\\r\\n                results.push(get(value));\\r\\n              }\\r\\n              return results;\\r\\n            } else if (value == \\\"{\\\") {\\r\\n              // Parses a JSON object, returning a new JavaScript object.\\r\\n              results = {};\\r\\n              for (;; hasMembers || (hasMembers = true)) {\\r\\n                value = lex();\\r\\n                // A closing curly brace marks the end of the object literal.\\r\\n                if (value == \\\"}\\\") {\\r\\n                  break;\\r\\n                }\\r\\n                // If the object literal contains members, the current token\\r\\n                // should be a comma separator.\\r\\n                if (hasMembers) {\\r\\n                  if (value == \\\",\\\") {\\r\\n                    value = lex();\\r\\n                    if (value == \\\"}\\\") {\\r\\n                      // Unexpected trailing `,` in object literal.\\r\\n                      abort();\\r\\n                    }\\r\\n                  } else {\\r\\n                    // A `,` must separate each object member.\\r\\n                    abort();\\r\\n                  }\\r\\n                }\\r\\n                // Leading commas are not permitted, object property names must be\\r\\n                // double-quoted strings, and a `:` must separate each property\\r\\n                // name and value.\\r\\n                if (value == \\\",\\\" || typeof value != \\\"string\\\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \\\"@\\\" || lex() != \\\":\\\") {\\r\\n                  abort();\\r\\n                }\\r\\n                results[value.slice(1)] = get(lex());\\r\\n              }\\r\\n              return results;\\r\\n            }\\r\\n            // Unexpected token encountered.\\r\\n            abort();\\r\\n          }\\r\\n          return value;\\r\\n        };\\r\\n\\r\\n        // Internal: Updates a traversed object member.\\r\\n        var update = function (source, property, callback) {\\r\\n          var element = walk(source, property, callback);\\r\\n          if (element === undef) {\\r\\n            delete source[property];\\r\\n          } else {\\r\\n            source[property] = element;\\r\\n          }\\r\\n        };\\r\\n\\r\\n        // Internal: Recursively traverses a parsed JSON object, invoking the\\r\\n        // `callback` function for each value. This is an implementation of the\\r\\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\\r\\n        var walk = function (source, property, callback) {\\r\\n          var value = source[property], length;\\r\\n          if (typeof value == \\\"object\\\" && value) {\\r\\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\\r\\n            // because its `Object#hasOwnProperty` implementation returns `false`\\r\\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\\\"0\\\")`).\\r\\n            if (getClass.call(value) == arrayClass) {\\r\\n              for (length = value.length; length--;) {\\r\\n                update(value, length, callback);\\r\\n              }\\r\\n            } else {\\r\\n              forEach(value, function (property) {\\r\\n                update(value, property, callback);\\r\\n              });\\r\\n            }\\r\\n          }\\r\\n          return callback.call(source, property, value);\\r\\n        };\\r\\n\\r\\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\\r\\n        exports.parse = function (source, callback) {\\r\\n          var result, value;\\r\\n          Index = 0;\\r\\n          Source = \\\"\\\" + source;\\r\\n          result = get(lex());\\r\\n          // If a JSON string contains multiple tokens, it is invalid.\\r\\n          if (lex() != \\\"$\\\") {\\r\\n            abort();\\r\\n          }\\r\\n          // Reset the parser state.\\r\\n          Index = Source = null;\\r\\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\\\"\\\"] = result, value), \\\"\\\", callback) : result;\\r\\n        };\\r\\n      }\\r\\n    }\\r\\n\\r\\n    exports[\\\"runInContext\\\"] = runInContext;\\r\\n    return exports;\\r\\n  }\\r\\n\\r\\n  if (freeExports && !isLoader) {\\r\\n    // Export for CommonJS environments.\\r\\n    runInContext(root, freeExports);\\r\\n  } else {\\r\\n    // Export for web browsers and JavaScript engines.\\r\\n    var nativeJSON = root.JSON,\\r\\n        previousJSON = root[\\\"JSON3\\\"],\\r\\n        isRestored = false;\\r\\n\\r\\n    var JSON3 = runInContext(root, (root[\\\"JSON3\\\"] = {\\r\\n      // Public: Restores the original value of the global `JSON` object and\\r\\n      // returns a reference to the `JSON3` object.\\r\\n      \\\"noConflict\\\": function () {\\r\\n        if (!isRestored) {\\r\\n          isRestored = true;\\r\\n          root.JSON = nativeJSON;\\r\\n          root[\\\"JSON3\\\"] = previousJSON;\\r\\n          nativeJSON = previousJSON = null;\\r\\n        }\\r\\n        return JSON3;\\r\\n      }\\r\\n    }));\\r\\n\\r\\n    root.JSON = {\\r\\n      \\\"parse\\\": JSON3.parse,\\r\\n      \\\"stringify\\\": JSON3.stringify\\r\\n    };\\r\\n  }\\r\\n\\r\\n  // Export for asynchronous module loaders.\\r\\n  if (isLoader) {\\r\\n    define(function () {\\r\\n      return JSON3;\\r\\n    });\\r\\n  }\\r\\n}).call(this);\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{}],59:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\nvar has = Object.prototype.hasOwnProperty;\\r\\n\\r\\n/**\\r\\n * Decode a URI encoded string.\\r\\n *\\r\\n * @param {String} input The URI encoded string.\\r\\n * @returns {String} The decoded string.\\r\\n * @api private\\r\\n */\\r\\nfunction decode(input) {\\r\\n  return decodeURIComponent(input.replace(/\\\\+/g, ' '));\\r\\n}\\r\\n\\r\\n/**\\r\\n * Simple query string parser.\\r\\n *\\r\\n * @param {String} query The query string that needs to be parsed.\\r\\n * @returns {Object}\\r\\n * @api public\\r\\n */\\r\\nfunction querystring(query) {\\r\\n  var parser = /([^=?&]+)=?([^&]*)/g\\r\\n    , result = {}\\r\\n    , part;\\r\\n\\r\\n  while (part = parser.exec(query)) {\\r\\n    var key = decode(part[1])\\r\\n      , value = decode(part[2]);\\r\\n\\r\\n    //\\r\\n    // Prevent overriding of existing properties. This ensures that build-in\\r\\n    // methods like `toString` or __proto__ are not overriden by malicious\\r\\n    // querystrings.\\r\\n    //\\r\\n    if (key in result) continue;\\r\\n    result[key] = value;\\r\\n  }\\r\\n\\r\\n  return result;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Transform a query string to an object.\\r\\n *\\r\\n * @param {Object} obj Object that should be transformed.\\r\\n * @param {String} prefix Optional prefix.\\r\\n * @returns {String}\\r\\n * @api public\\r\\n */\\r\\nfunction querystringify(obj, prefix) {\\r\\n  prefix = prefix || '';\\r\\n\\r\\n  var pairs = [];\\r\\n\\r\\n  //\\r\\n  // Optionally prefix with a '?' if needed\\r\\n  //\\r\\n  if ('string' !== typeof prefix) prefix = '?';\\r\\n\\r\\n  for (var key in obj) {\\r\\n    if (has.call(obj, key)) {\\r\\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return pairs.length ? prefix + pairs.join('&') : '';\\r\\n}\\r\\n\\r\\n//\\r\\n// Expose the module.\\r\\n//\\r\\nexports.stringify = querystringify;\\r\\nexports.parse = querystring;\\r\\n\\r\\n},{}],60:[function(require,module,exports){\\r\\n'use strict';\\r\\n\\r\\n/**\\r\\n * Check if we're required to add a port number.\\r\\n *\\r\\n * @see https://url.spec.whatwg.org/#default-port\\r\\n * @param {Number|String} port Port number we need to check\\r\\n * @param {String} protocol Protocol we need to check against.\\r\\n * @returns {Boolean} Is it a default port for the given protocol\\r\\n * @api private\\r\\n */\\r\\nmodule.exports = function required(port, protocol) {\\r\\n  protocol = protocol.split(':')[0];\\r\\n  port = +port;\\r\\n\\r\\n  if (!port) return false;\\r\\n\\r\\n  switch (protocol) {\\r\\n    case 'http':\\r\\n    case 'ws':\\r\\n    return port !== 80;\\r\\n\\r\\n    case 'https':\\r\\n    case 'wss':\\r\\n    return port !== 443;\\r\\n\\r\\n    case 'ftp':\\r\\n    return port !== 21;\\r\\n\\r\\n    case 'gopher':\\r\\n    return port !== 70;\\r\\n\\r\\n    case 'file':\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  return port !== 0;\\r\\n};\\r\\n\\r\\n},{}],61:[function(require,module,exports){\\r\\n(function (global){\\r\\n'use strict';\\r\\n\\r\\nvar required = require('requires-port')\\r\\n  , qs = require('querystringify')\\r\\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\\\/\\\\/)?([\\\\S\\\\s]*)/i\\r\\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\\\/\\\\//;\\r\\n\\r\\n/**\\r\\n * These are the parse rules for the URL parser, it informs the parser\\r\\n * about:\\r\\n *\\r\\n * 0. The char it Needs to parse, if it's a string it should be done using\\r\\n *    indexOf, RegExp using exec and NaN means set as current value.\\r\\n * 1. The property we should set when parsing this value.\\r\\n * 2. Indication if it's backwards or forward parsing, when set as number it's\\r\\n *    the value of extra chars that should be split off.\\r\\n * 3. Inherit from location if non existing in the parser.\\r\\n * 4. `toLowerCase` the resulting value.\\r\\n */\\r\\nvar rules = [\\r\\n  ['#', 'hash'],                        // Extract from the back.\\r\\n  ['?', 'query'],                       // Extract from the back.\\r\\n  function sanitize(address) {          // Sanitize what is left of the address\\r\\n    return address.replace('\\\\\\\\', '/');\\r\\n  },\\r\\n  ['/', 'pathname'],                    // Extract from the back.\\r\\n  ['@', 'auth', 1],                     // Extract from the front.\\r\\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\\r\\n  [/:(\\\\d+)$/, 'port', undefined, 1],    // RegExp the back.\\r\\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\\r\\n];\\r\\n\\r\\n/**\\r\\n * These properties should not be copied or inherited from. This is only needed\\r\\n * for all non blob URL's as a blob URL does not include a hash, only the\\r\\n * origin.\\r\\n *\\r\\n * @type {Object}\\r\\n * @private\\r\\n */\\r\\nvar ignore = { hash: 1, query: 1 };\\r\\n\\r\\n/**\\r\\n * The location object differs when your code is loaded through a normal page,\\r\\n * Worker or through a worker using a blob. And with the blobble begins the\\r\\n * trouble as the location object will contain the URL of the blob, not the\\r\\n * location of the page where our code is loaded in. The actual origin is\\r\\n * encoded in the `pathname` so we can thankfully generate a good \\\"default\\\"\\r\\n * location from it so we can generate proper relative URL's again.\\r\\n *\\r\\n * @param {Object|String} loc Optional default location object.\\r\\n * @returns {Object} lolcation object.\\r\\n * @public\\r\\n */\\r\\nfunction lolcation(loc) {\\r\\n  var location = global && global.location || {};\\r\\n  loc = loc || location;\\r\\n\\r\\n  var finaldestination = {}\\r\\n    , type = typeof loc\\r\\n    , key;\\r\\n\\r\\n  if ('blob:' === loc.protocol) {\\r\\n    finaldestination = new Url(unescape(loc.pathname), {});\\r\\n  } else if ('string' === type) {\\r\\n    finaldestination = new Url(loc, {});\\r\\n    for (key in ignore) delete finaldestination[key];\\r\\n  } else if ('object' === type) {\\r\\n    for (key in loc) {\\r\\n      if (key in ignore) continue;\\r\\n      finaldestination[key] = loc[key];\\r\\n    }\\r\\n\\r\\n    if (finaldestination.slashes === undefined) {\\r\\n      finaldestination.slashes = slashes.test(loc.href);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return finaldestination;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @typedef ProtocolExtract\\r\\n * @type Object\\r\\n * @property {String} protocol Protocol matched in the URL, in lowercase.\\r\\n * @property {Boolean} slashes `true` if protocol is followed by \\\"//\\\", else `false`.\\r\\n * @property {String} rest Rest of the URL that is not part of the protocol.\\r\\n */\\r\\n\\r\\n/**\\r\\n * Extract protocol information from a URL with/without double slash (\\\"//\\\").\\r\\n *\\r\\n * @param {String} address URL we want to extract from.\\r\\n * @return {ProtocolExtract} Extracted information.\\r\\n * @private\\r\\n */\\r\\nfunction extractProtocol(address) {\\r\\n  var match = protocolre.exec(address);\\r\\n\\r\\n  return {\\r\\n    protocol: match[1] ? match[1].toLowerCase() : '',\\r\\n    slashes: !!match[2],\\r\\n    rest: match[3]\\r\\n  };\\r\\n}\\r\\n\\r\\n/**\\r\\n * Resolve a relative URL pathname against a base URL pathname.\\r\\n *\\r\\n * @param {String} relative Pathname of the relative URL.\\r\\n * @param {String} base Pathname of the base URL.\\r\\n * @return {String} Resolved pathname.\\r\\n * @private\\r\\n */\\r\\nfunction resolve(relative, base) {\\r\\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\\r\\n    , i = path.length\\r\\n    , last = path[i - 1]\\r\\n    , unshift = false\\r\\n    , up = 0;\\r\\n\\r\\n  while (i--) {\\r\\n    if (path[i] === '.') {\\r\\n      path.splice(i, 1);\\r\\n    } else if (path[i] === '..') {\\r\\n      path.splice(i, 1);\\r\\n      up++;\\r\\n    } else if (up) {\\r\\n      if (i === 0) unshift = true;\\r\\n      path.splice(i, 1);\\r\\n      up--;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (unshift) path.unshift('');\\r\\n  if (last === '.' || last === '..') path.push('');\\r\\n\\r\\n  return path.join('/');\\r\\n}\\r\\n\\r\\n/**\\r\\n * The actual URL instance. Instead of returning an object we've opted-in to\\r\\n * create an actual constructor as it's much more memory efficient and\\r\\n * faster and it pleases my OCD.\\r\\n *\\r\\n * It is worth noting that we should not use `URL` as class name to prevent\\r\\n * clashes with the global URL instance that got introduced in browsers.\\r\\n *\\r\\n * @constructor\\r\\n * @param {String} address URL we want to parse.\\r\\n * @param {Object|String} location Location defaults for relative paths.\\r\\n * @param {Boolean|Function} parser Parser for the query string.\\r\\n * @private\\r\\n */\\r\\nfunction Url(address, location, parser) {\\r\\n  if (!(this instanceof Url)) {\\r\\n    return new Url(address, location, parser);\\r\\n  }\\r\\n\\r\\n  var relative, extracted, parse, instruction, index, key\\r\\n    , instructions = rules.slice()\\r\\n    , type = typeof location\\r\\n    , url = this\\r\\n    , i = 0;\\r\\n\\r\\n  //\\r\\n  // The following if statements allows this module two have compatibility with\\r\\n  // 2 different API:\\r\\n  //\\r\\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\\r\\n  //    where the boolean indicates that the query string should also be parsed.\\r\\n  //\\r\\n  // 2. The `URL` interface of the browser which accepts a URL, object as\\r\\n  //    arguments. The supplied object will be used as default values / fall-back\\r\\n  //    for relative paths.\\r\\n  //\\r\\n  if ('object' !== type && 'string' !== type) {\\r\\n    parser = location;\\r\\n    location = null;\\r\\n  }\\r\\n\\r\\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\\r\\n\\r\\n  location = lolcation(location);\\r\\n\\r\\n  //\\r\\n  // Extract protocol information before running the instructions.\\r\\n  //\\r\\n  extracted = extractProtocol(address || '');\\r\\n  relative = !extracted.protocol && !extracted.slashes;\\r\\n  url.slashes = extracted.slashes || relative && location.slashes;\\r\\n  url.protocol = extracted.protocol || location.protocol || '';\\r\\n  address = extracted.rest;\\r\\n\\r\\n  //\\r\\n  // When the authority component is absent the URL starts with a path\\r\\n  // component.\\r\\n  //\\r\\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\\r\\n\\r\\n  for (; i < instructions.length; i++) {\\r\\n    instruction = instructions[i];\\r\\n\\r\\n    if (typeof instruction === 'function') {\\r\\n      address = instruction(address);\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    parse = instruction[0];\\r\\n    key = instruction[1];\\r\\n\\r\\n    if (parse !== parse) {\\r\\n      url[key] = address;\\r\\n    } else if ('string' === typeof parse) {\\r\\n      if (~(index = address.indexOf(parse))) {\\r\\n        if ('number' === typeof instruction[2]) {\\r\\n          url[key] = address.slice(0, index);\\r\\n          address = address.slice(index + instruction[2]);\\r\\n        } else {\\r\\n          url[key] = address.slice(index);\\r\\n          address = address.slice(0, index);\\r\\n        }\\r\\n      }\\r\\n    } else if ((index = parse.exec(address))) {\\r\\n      url[key] = index[1];\\r\\n      address = address.slice(0, index.index);\\r\\n    }\\r\\n\\r\\n    url[key] = url[key] || (\\r\\n      relative && instruction[3] ? location[key] || '' : ''\\r\\n    );\\r\\n\\r\\n    //\\r\\n    // Hostname, host and protocol should be lowercased so they can be used to\\r\\n    // create a proper `origin`.\\r\\n    //\\r\\n    if (instruction[4]) url[key] = url[key].toLowerCase();\\r\\n  }\\r\\n\\r\\n  //\\r\\n  // Also parse the supplied query string in to an object. If we're supplied\\r\\n  // with a custom parser as function use that instead of the default build-in\\r\\n  // parser.\\r\\n  //\\r\\n  if (parser) url.query = parser(url.query);\\r\\n\\r\\n  //\\r\\n  // If the URL is relative, resolve the pathname against the base URL.\\r\\n  //\\r\\n  if (\\r\\n      relative\\r\\n    && location.slashes\\r\\n    && url.pathname.charAt(0) !== '/'\\r\\n    && (url.pathname !== '' || location.pathname !== '')\\r\\n  ) {\\r\\n    url.pathname = resolve(url.pathname, location.pathname);\\r\\n  }\\r\\n\\r\\n  //\\r\\n  // We should not add port numbers if they are already the default port number\\r\\n  // for a given protocol. As the host also contains the port number we're going\\r\\n  // override it with the hostname which contains no port number.\\r\\n  //\\r\\n  if (!required(url.port, url.protocol)) {\\r\\n    url.host = url.hostname;\\r\\n    url.port = '';\\r\\n  }\\r\\n\\r\\n  //\\r\\n  // Parse down the `auth` for the username and password.\\r\\n  //\\r\\n  url.username = url.password = '';\\r\\n  if (url.auth) {\\r\\n    instruction = url.auth.split(':');\\r\\n    url.username = instruction[0] || '';\\r\\n    url.password = instruction[1] || '';\\r\\n  }\\r\\n\\r\\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\\r\\n    ? url.protocol +'//'+ url.host\\r\\n    : 'null';\\r\\n\\r\\n  //\\r\\n  // The href is just the compiled result.\\r\\n  //\\r\\n  url.href = url.toString();\\r\\n}\\r\\n\\r\\n/**\\r\\n * This is convenience method for changing properties in the URL instance to\\r\\n * insure that they all propagate correctly.\\r\\n *\\r\\n * @param {String} part          Property we need to adjust.\\r\\n * @param {Mixed} value          The newly assigned value.\\r\\n * @param {Boolean|Function} fn  When setting the query, it will be the function\\r\\n *                               used to parse the query.\\r\\n *                               When setting the protocol, double slash will be\\r\\n *                               removed from the final url if it is true.\\r\\n * @returns {URL} URL instance for chaining.\\r\\n * @public\\r\\n */\\r\\nfunction set(part, value, fn) {\\r\\n  var url = this;\\r\\n\\r\\n  switch (part) {\\r\\n    case 'query':\\r\\n      if ('string' === typeof value && value.length) {\\r\\n        value = (fn || qs.parse)(value);\\r\\n      }\\r\\n\\r\\n      url[part] = value;\\r\\n      break;\\r\\n\\r\\n    case 'port':\\r\\n      url[part] = value;\\r\\n\\r\\n      if (!required(value, url.protocol)) {\\r\\n        url.host = url.hostname;\\r\\n        url[part] = '';\\r\\n      } else if (value) {\\r\\n        url.host = url.hostname +':'+ value;\\r\\n      }\\r\\n\\r\\n      break;\\r\\n\\r\\n    case 'hostname':\\r\\n      url[part] = value;\\r\\n\\r\\n      if (url.port) value += ':'+ url.port;\\r\\n      url.host = value;\\r\\n      break;\\r\\n\\r\\n    case 'host':\\r\\n      url[part] = value;\\r\\n\\r\\n      if (/:\\\\d+$/.test(value)) {\\r\\n        value = value.split(':');\\r\\n        url.port = value.pop();\\r\\n        url.hostname = value.join(':');\\r\\n      } else {\\r\\n        url.hostname = value;\\r\\n        url.port = '';\\r\\n      }\\r\\n\\r\\n      break;\\r\\n\\r\\n    case 'protocol':\\r\\n      url.protocol = value.toLowerCase();\\r\\n      url.slashes = !fn;\\r\\n      break;\\r\\n\\r\\n    case 'pathname':\\r\\n    case 'hash':\\r\\n      if (value) {\\r\\n        var char = part === 'pathname' ? '/' : '#';\\r\\n        url[part] = value.charAt(0) !== char ? char + value : value;\\r\\n      } else {\\r\\n        url[part] = value;\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    default:\\r\\n      url[part] = value;\\r\\n  }\\r\\n\\r\\n  for (var i = 0; i < rules.length; i++) {\\r\\n    var ins = rules[i];\\r\\n\\r\\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\\r\\n  }\\r\\n\\r\\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\\r\\n    ? url.protocol +'//'+ url.host\\r\\n    : 'null';\\r\\n\\r\\n  url.href = url.toString();\\r\\n\\r\\n  return url;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Transform the properties back in to a valid and full URL string.\\r\\n *\\r\\n * @param {Function} stringify Optional query stringify function.\\r\\n * @returns {String} Compiled version of the URL.\\r\\n * @public\\r\\n */\\r\\nfunction toString(stringify) {\\r\\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\\r\\n\\r\\n  var query\\r\\n    , url = this\\r\\n    , protocol = url.protocol;\\r\\n\\r\\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\\r\\n\\r\\n  var result = protocol + (url.slashes ? '//' : '');\\r\\n\\r\\n  if (url.username) {\\r\\n    result += url.username;\\r\\n    if (url.password) result += ':'+ url.password;\\r\\n    result += '@';\\r\\n  }\\r\\n\\r\\n  result += url.host + url.pathname;\\r\\n\\r\\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\\r\\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\\r\\n\\r\\n  if (url.hash) result += url.hash;\\r\\n\\r\\n  return result;\\r\\n}\\r\\n\\r\\nUrl.prototype = { set: set, toString: toString };\\r\\n\\r\\n//\\r\\n// Expose the URL parser and some additional properties that might be useful for\\r\\n// others or testing.\\r\\n//\\r\\nUrl.extractProtocol = extractProtocol;\\r\\nUrl.location = lolcation;\\r\\nUrl.qs = qs;\\r\\n\\r\\nmodule.exports = Url;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n\\r\\n},{\\\"querystringify\\\":59,\\\"requires-port\\\":60}]},{},[1])(1)\\r\\n});\\r\\n\\r\\n\\r\\n//# sourceMappingURL=sockjs.js.map\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcz85YmUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxHQUFHLElBQXNELEVBQUUsbUJBQW1CLEtBQUssVUFBK04sQ0FBQyxhQUFhLDBCQUEwQixtQkFBbUIsa0JBQWtCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZUFBZSxzQkFBc0Isb0JBQW9CLGtEQUFrRCxXQUFXLFlBQVksU0FBUyxTQUFTLEtBQUs7QUFDM3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxrQ0FBa0M7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0NBQWdDO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSwrQkFBK0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUscUZBQXFGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSwrSUFBK0k7QUFDbEo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHVDQUF1QyxFQUFFLEdBQUc7QUFDL0MsQ0FBQzs7O0FBR0QiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBzb2NranMtY2xpZW50IHYxLjMuMCB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cclxuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xyXG5cclxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cclxuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XHJcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xyXG4gIEV2ZW50LmNhbGwodGhpcyk7XHJcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcclxuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XHJcbiAgdGhpcy5jb2RlID0gMDtcclxuICB0aGlzLnJlYXNvbiA9ICcnO1xyXG59XHJcblxyXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlRXZlbnQ7XHJcblxyXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxyXG4gIDtcclxuXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xyXG59XHJcblxyXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIGlmICh0eXBlKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICB9XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhciBzZWxmID0gdGhpc1xyXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBnKCkge1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcclxuXHJcbiAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMub24odHlwZSwgZyk7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcclxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG4gIGlmICghbGlzdGVuZXJzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xyXG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XHJcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIH1cclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcclxufVxyXG5cclxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XHJcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xyXG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcclxuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xyXG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcclxuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XHJcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XHJcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XHJcblxyXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxyXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcclxuICovXHJcblxyXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcclxuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcclxuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XHJcbiAgfVxyXG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcclxuICAvLyAjNFxyXG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XHJcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXHJcbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xyXG4gIH1cclxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcclxufTtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcclxuICBpZiAoIWFycikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxyXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxufTtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xyXG4gIHZhciB0ID0gZXZlbnQudHlwZTtcclxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XHJcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxyXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcclxuICAvLyBzZXQuXHJcbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XHJcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICB9XHJcbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XHJcblxyXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xyXG4gIEV2ZW50LmNhbGwodGhpcyk7XHJcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn1cclxuXHJcbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XHJcblxyXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcclxuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcclxuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XHJcbn1cclxuXHJcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xyXG59O1xyXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xyXG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xyXG59O1xyXG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XHJcbn07XHJcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcclxuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xyXG5cclxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwianNvbjNcIjo1OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXHJcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxyXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcclxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcclxuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XHJcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XHJcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XHJcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxyXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXHJcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcclxuICB2YXIgcGFyZW50T3JpZ2luO1xyXG5cclxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cclxuICAgIHZhciBmYWNhZGU7XHJcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcclxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcclxuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xyXG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcclxuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcclxuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xyXG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcclxuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcclxuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcclxuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxyXG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdtJzpcclxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgaWYgKGZhY2FkZSkge1xyXG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmYWNhZGUgPSBudWxsO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG5cclxuICAgIC8vIFN0YXJ0XHJcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xyXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcclxuXHJcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcclxuICAgIHZhciBpbmZvLCBydHQ7XHJcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xyXG4gICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XHJcbiAgICAgICAgaW5mbyA9IHt9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XHJcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy54by5jbG9zZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXHJcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxyXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XHJcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICAgIHNlbGYuaXIgPSBudWxsO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcclxuXHJcbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5pcikge1xyXG4gICAgdGhpcy5pci5jbG9zZSgpO1xyXG4gICAgdGhpcy5pciA9IG51bGw7XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcclxuXHJcbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXHJcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxyXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcclxuXHJcbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICBpZiAobXNnKSB7XHJcbiAgICAgICAgdmFyIGQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XHJcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xyXG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xyXG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcclxuICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xyXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcclxuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBnbygpO1xyXG4gIH1cclxufVxyXG5cclxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xyXG59O1xyXG5cclxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5pZnIpIHtcclxuICAgIHRoaXMuaWZyLmNsb3NlKCk7XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy5pZnIgPSBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjIyLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcclxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxyXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXHJcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxyXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXHJcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXHJcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XHJcbiAgZGVidWcoYmFzZVVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcclxuICB9LCAwKTtcclxufVxyXG5cclxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxyXG5cclxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xyXG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXHJcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xyXG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcclxuICB9XHJcbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xyXG4gIH1cclxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcclxuICB9XHJcbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XHJcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xyXG59O1xyXG5cclxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcclxuICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxyXG4gICAgO1xyXG4gIGRlYnVnKCdkb1hocicsIHVybCk7XHJcblxyXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XHJcblxyXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygndGltZW91dCcpO1xyXG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xyXG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcclxuXHJcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xyXG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcclxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcclxuICB9KTtcclxufTtcclxuXHJcbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xyXG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XHJcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XHJcbiAgICB0aGlzLnhvLmNsb3NlKCk7XHJcbiAgfVxyXG4gIHRoaXMueG8gPSBudWxsO1xyXG59O1xyXG5cclxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbn07XHJcblxyXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xyXG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXHJcbiwgcHJvdG9jb2w6ICdodHRwOidcclxuLCBob3N0OiAnbG9jYWxob3N0J1xyXG4sIHBvcnQ6IDgwXHJcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xyXG4sIGhhc2g6ICcnXHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnJlcXVpcmUoJy4vc2hpbXMnKTtcclxuXHJcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcclxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcclxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxyXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxyXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxyXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXHJcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcclxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcclxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXHJcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxyXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXHJcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXHJcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxyXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XHJcbn1cclxuXHJcbnZhciB0cmFuc3BvcnRzO1xyXG5cclxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcclxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcclxuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICB9XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XHJcbiAgfVxyXG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XHJcblxyXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xyXG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xyXG4gIHRoaXMucHJvdG9jb2wgPSAnJztcclxuXHJcbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcclxuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XHJcbiAgfVxyXG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XHJcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XHJcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcclxuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcclxuICB9XHJcblxyXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XHJcblxyXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XHJcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcclxuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XHJcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcclxuICB9XHJcblxyXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xyXG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxyXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcclxuICB9XHJcblxyXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXHJcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XHJcbiAgaWYgKCFwcm90b2NvbHMpIHtcclxuICAgIHByb3RvY29scyA9IFtdO1xyXG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xyXG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcclxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcclxuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xyXG4gICAgaWYgKCFwcm90bykge1xyXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXHJcbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xyXG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG5cclxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXHJcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xyXG5cclxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxyXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XHJcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcclxuXHJcbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXHJcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXHJcbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcclxuICB0aGlzLl91cmxJbmZvID0ge1xyXG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcclxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxyXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXHJcbiAgfTtcclxuXHJcbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcclxuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcclxufVxyXG5cclxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XHJcblxyXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XHJcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xyXG59XHJcblxyXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XHJcbiAgLy8gU3RlcCAxXHJcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XHJcbiAgfVxyXG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxyXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDMuMVxyXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xyXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XHJcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcclxuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cclxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICBkYXRhID0gJycgKyBkYXRhO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xyXG59O1xyXG5cclxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcclxuXHJcblNvY2tKUy5DT05ORUNUSU5HID0gMDtcclxuU29ja0pTLk9QRU4gPSAxO1xyXG5Tb2NrSlMuQ0xPU0lORyA9IDI7XHJcblNvY2tKUy5DTE9TRUQgPSAzO1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcclxuICB0aGlzLl9pciA9IG51bGw7XHJcbiAgaWYgKCFpbmZvKSB7XHJcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXHJcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXHJcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xyXG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcclxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XHJcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcclxuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xyXG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXHJcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XHJcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XHJcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xyXG5cclxuICB0aGlzLl9jb25uZWN0KCk7XHJcbn07XHJcblxyXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xyXG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XHJcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XHJcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcclxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXHJcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xyXG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XHJcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xyXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcclxuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xyXG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xyXG5cclxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcclxuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XHJcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XHJcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcclxuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XHJcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcclxuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XHJcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xyXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XHJcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XHJcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcclxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxyXG4gICAgLCBwYXlsb2FkXHJcbiAgICA7XHJcblxyXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdvJzpcclxuICAgICAgdGhpcy5fb3BlbigpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlICdoJzpcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xyXG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoY29udGVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcGF5bG9hZCA9IEpTT04zLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ2EnOlxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xyXG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ20nOlxyXG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2MnOlxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufTtcclxuXHJcblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XHJcbiAgZGVidWcoJ190cmFuc3BvcnRDbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24pO1xyXG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcclxuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgdGhpcy5fY29ubmVjdCgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5fY2xvc2UoY29kZSwgcmVhc29uKTtcclxufTtcclxuXHJcblNvY2tKUy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcclxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcclxuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xyXG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XHJcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxyXG4gICAgLy8gY29ubmVjdGlvbi5cclxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XHJcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xyXG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcclxuXHJcbiAgaWYgKHRoaXMuX2lyKSB7XHJcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xyXG4gICAgdGhpcy5faXIuY2xvc2UoKTtcclxuICAgIHRoaXMuX2lyID0gbnVsbDtcclxuICB9XHJcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xyXG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XHJcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xyXG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcclxuXHJcbiAgICBpZiAoZm9yY2VGYWlsKSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XHJcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XHJcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XHJcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XHJcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XHJcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XHJcbiAgfS5iaW5kKHRoaXMpLCAwKTtcclxufTtcclxuXHJcbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cclxuLy8gYW5kIFJGQyAyOTg4LlxyXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XHJcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxyXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXHJcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcclxuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXHJcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcclxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXHJcbiAgaWYgKHJ0dCA+IDEwMCkge1xyXG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcclxuICB9XHJcbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcclxuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xyXG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XHJcbiAgcmV0dXJuIFNvY2tKUztcclxufTtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4vKiBqc2NzOiBkaXNhYmxlICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxyXG5cclxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xyXG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcclxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xyXG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcclxudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XHJcblxyXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG59O1xyXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxufTtcclxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbn07XHJcblxyXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSgpKTtcclxuXHJcbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xyXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxyXG52YXIgZGVmaW5lUHJvcGVydHk7XHJcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XHJcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcclxuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufSBlbHNlIHtcclxuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xyXG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cclxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XHJcbiAgICB9O1xyXG59XHJcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcclxuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xyXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xyXG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdChvKTtcclxufTtcclxuXHJcbi8vXHJcbi8vIFV0aWxcclxuLy8gPT09PT09XHJcbi8vXHJcblxyXG4vLyBFUzUgOS40XHJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxyXG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXHJcblxyXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XHJcbiAgICB2YXIgbiA9ICtudW07XHJcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcclxuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcclxuICAgIHJldHVybiB4ID4+PiAwO1xyXG59XHJcblxyXG4vL1xyXG4vLyBGdW5jdGlvblxyXG4vLyA9PT09PT09PVxyXG4vL1xyXG5cclxuLy8gRVMtNSAxNS4zLjQuNVxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxyXG5cclxuZnVuY3Rpb24gRW1wdHkoKSB7fVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xyXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxyXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcclxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxyXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcclxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXHJcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxyXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxyXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXHJcbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxyXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cclxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXHJcbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXHJcbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxyXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcclxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXHJcbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxyXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cclxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcclxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cclxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcclxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcclxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcclxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcclxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cclxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cclxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxyXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcclxuICAgICAgICAvLyAgICAgICBsYXJnZXIuXHJcbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcclxuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cclxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxyXG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxyXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xyXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cclxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXHJcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxyXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxyXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcclxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcclxuICAgICAgICAvLyAgIGZhbHNlLlxyXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxyXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcclxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxyXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XHJcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcclxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxyXG5cclxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXHJcbiAgICAgICAgcmV0dXJuIGJvdW5kO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vXHJcbi8vIEFycmF5XHJcbi8vID09PT09XHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuNC4zLjJcclxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XHJcblxyXG5cclxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XHJcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcclxuXHJcbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XHJcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxyXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xyXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcclxuICAgICAgICB9LCAneCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcclxufTtcclxuXHJcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcclxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgIGkgPSAtMSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xyXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xyXG5cclxuLy8gRVM1IDE1LjQuNC4xNFxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxyXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XHJcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xyXG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xyXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xyXG5cclxuLy9cclxuLy8gU3RyaW5nXHJcbi8vID09PT09PVxyXG4vL1xyXG5cclxuLy8gRVM1IDE1LjUuNC4xNFxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcclxuXHJcbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cclxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcclxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXHJcbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxyXG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XHJcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXHJcbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxyXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XHJcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXHJcbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxyXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cclxuXHJcbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XHJcbmlmIChcclxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcclxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcclxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XHJcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XHJcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcclxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcclxuKSB7XHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxyXG5cclxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XHJcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXHJcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcclxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xyXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcclxuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcclxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XHJcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXHJcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcclxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xyXG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcclxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xyXG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXHJcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbi8vIFtidWdmaXgsIGNocm9tZV1cclxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcclxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXHJcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcclxuLy8gZWxlbWVudHMuXHJcbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cclxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcclxuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xyXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxyXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXHJcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xyXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxyXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XHJcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcclxuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcclxuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxyXG4gICAgICAgICAgICBsZW5ndGhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XHJcblxyXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXHJcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcclxuXHJcbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxyXG5dO1xyXG5cclxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xyXG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xyXG4gIH0sIDApO1xyXG59XHJcblxyXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdHJ5IHtcclxuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xyXG4gIH0gY2F0Y2ggKHgpIHtcclxuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy54aHIpIHtcclxuICAgIGRlYnVnKCdubyB4aHInKTtcclxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XHJcbiAgICB0aGlzLl9jbGVhbnVwKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXHJcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XHJcblxyXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxyXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxyXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xyXG4gIH0pO1xyXG4gIHRyeSB7XHJcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XHJcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XHJcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xyXG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xyXG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcclxuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cclxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xyXG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xyXG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xyXG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxyXG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXHJcblxyXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XHJcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmIChzZWxmLnhocikge1xyXG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xyXG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xyXG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XHJcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcclxuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xyXG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XHJcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XHJcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XHJcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcclxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcclxuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcclxuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XHJcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xyXG4gICAgICAgICAgc3RhdHVzID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xyXG4gIGRlYnVnKCdjbGVhbnVwJyk7XHJcbiAgaWYgKCF0aGlzLnhocikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XHJcblxyXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxyXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XHJcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xyXG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChhYm9ydCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcclxuICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcclxufTtcclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XHJcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xyXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXHJcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xyXG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XHJcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcclxuICBYSFIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xyXG59XHJcblxyXG52YXIgY29ycyA9IGZhbHNlO1xyXG50cnkge1xyXG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XHJcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbn1cclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XHJcbmlmIChEcml2ZXIpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XHJcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcclxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXHJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcblxyXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xyXG5cclxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xyXG59O1xyXG5cclxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XHJcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcclxuXHJcbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXHJcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xyXG5cclxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcclxuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcclxufTtcclxuXHJcbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xyXG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XHJcblxyXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXHJcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXHJcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXHJcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXHJcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XHJcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XHJcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxyXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXHJcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XHJcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcclxuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xyXG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcclxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcclxuXHJcbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcclxuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xyXG5cclxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcclxuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XHJcbiAgICBzZWxmLmNsb3NlKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XHJcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xyXG59XHJcblxyXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Nsb3NlJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcclxuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXHJcbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cclxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xyXG4gICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICB9XHJcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XHJcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XHJcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xyXG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XHJcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xyXG4gIHRyeSB7XHJcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcclxuICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcclxuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcclxuICBjYXNlICdzJzpcclxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xyXG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XHJcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcclxuICAgICAgdmVyc2lvblxyXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxyXG4gICAgLCB0aGlzLnRyYW5zVXJsXHJcbiAgICAsIHRoaXMuYmFzZVVybFxyXG4gICAgXSkpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAndCc6XHJcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAnYyc6XHJcbiAgICB2YXIgY2RhdGE7XHJcbiAgICB0cnkge1xyXG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XHJcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xyXG4gICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG59O1xyXG5cclxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcclxuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcclxuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XHJcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxyXG4gICwgdHlwZTogdHlwZVxyXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xyXG4gIH0pLCB0aGlzLm9yaWdpbik7XHJcbn07XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcclxuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XHJcbn07XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xyXG59O1xyXG5cclxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcclxuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXHJcbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXHJcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3RcclxuLy8gZXZlcnl3aGVyZS5cclxuLy8gS25vd24gbGltaXRhdGlvbnM6XHJcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3JcclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXHJcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXHJcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcclxufVxyXG5cclxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcclxuXHJcbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XHJcbn07XHJcblxyXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xyXG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcclxuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xyXG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcclxuICAgIHZhciBvcHQgPSB7fTtcclxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XHJcbiAgICB9XHJcbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XHJcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XHJcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcclxuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XHJcbiAgICAgIHhvID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcclxuICAgICAgfVxyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xyXG4gICAgICB4by5jbG9zZSgpO1xyXG4gICAgICB4byA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XHJcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcclxuICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XHJcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcclxuICBkZWJ1Zyh1cmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xyXG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xyXG4gIHRoaXMudXJsID0gdXJsO1xyXG59XHJcblxyXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XHJcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XHJcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XHJcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcclxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxyXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXHJcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcclxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcclxuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxyXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXHJcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxyXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciB0cmVmO1xyXG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xyXG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XHJcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XHJcbiAgfTtcclxuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XHJcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcclxuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XHJcbiAgfSwgMjUpO1xyXG59O1xyXG5cclxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XHJcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XHJcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XHJcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcclxuICAgICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XHJcbiAgfVxyXG59O1xyXG5cclxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ19jbGVhbnVwJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxufTtcclxuXHJcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICBpZiAodGhpcy5zZW5kU3RvcCkge1xyXG4gICAgdGhpcy5zZW5kU3RvcCgpO1xyXG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXHJcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXHJcbiAgO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHJcbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xyXG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcclxuICB9XHJcblxyXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XHJcblxyXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xyXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcclxuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XHJcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcclxuICB9O1xyXG5cclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxyXG5cclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuXHJcbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTd9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xyXG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcclxuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xyXG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XHJcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xyXG59XHJcblxyXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XHJcblxyXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcclxuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XHJcbiAgfSk7XHJcblxyXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcclxuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xyXG5cclxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XHJcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xyXG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xyXG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Fib3J0Jyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xyXG4gIGlmICh0aGlzLnBvbGwpIHtcclxuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcclxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xyXG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcclxuICBkZWJ1Zyhwb2xsVXJsKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XHJcblxyXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcclxuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcclxuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcclxuICB9KTtcclxuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcclxuICAgIHNlbGYucG9sbCA9IG51bGw7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcclxuICAgIHNlbGYuY2xvc2UoKTtcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcclxuXHJcblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgaWYgKHRoaXMucG9sbCkge1xyXG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XHJcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcclxuICBkZWJ1Zyh1cmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xyXG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcclxuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcclxuICB9O1xyXG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcclxuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cclxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXHJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xyXG4gIH07XHJcbn1cclxuXHJcbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdhYm9ydCcpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLl9jbG9zZSgndXNlcicpO1xyXG59O1xyXG5cclxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnY2xlYW51cCcpO1xyXG4gIHZhciBlcyA9IHRoaXMuZXM7XHJcbiAgaWYgKGVzKSB7XHJcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcclxuICAgIGVzLmNsb3NlKCk7XHJcbiAgICB0aGlzLmVzID0gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcclxuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcclxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XHJcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xyXG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB9LCAyMDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxyXG5cclxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxyXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxyXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XHJcbiAgZGVidWcodXJsKTtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xyXG5cclxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcclxuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcclxuXHJcbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xyXG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xyXG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcclxuXHJcbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcclxuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XHJcbiAgICB9XHJcbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XHJcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xyXG4gICAgfVxyXG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdzdG9wJyk7XHJcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcclxuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdhYm9ydCcpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLl9jbG9zZSgndXNlcicpO1xyXG59O1xyXG5cclxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX2NsZWFudXAnKTtcclxuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcclxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcclxuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcclxuICB9XHJcbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcclxufTtcclxuXHJcbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xyXG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xyXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcclxuaWYgKGF4byBpbiBnbG9iYWwpIHtcclxuICB0cnkge1xyXG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcclxuICB9IGNhdGNoICh4KSB7XHJcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgfVxyXG59XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXHJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxyXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxyXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xyXG4gIGRlYnVnKHVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XHJcblxyXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xyXG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcclxuXHJcbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcclxuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcclxuXHJcbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxyXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XHJcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XHJcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Fib3J0Jyk7XHJcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcclxuICAgIGVyci5jb2RlID0gMTAwMDtcclxuICAgIHRoaXMuX2Fib3J0KGVycik7XHJcbiAgfVxyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XHJcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XHJcbiAgdGhpcy5fY2xlYW51cCgpO1xyXG5cclxuICBpZiAodGhpcy5hYm9ydGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XHJcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcclxuICB9XHJcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxufTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xyXG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcclxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX2NsZWFudXAnKTtcclxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xyXG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcclxuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XHJcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xyXG4gIH1cclxuICBpZiAodGhpcy5zY3JpcHQpIHtcclxuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcclxuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcclxuICAgIC8vIHRoZSBzY3JpcHQuXHJcbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xyXG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cclxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xyXG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xyXG4gIH1cclxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcclxuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xyXG4gICAgfVxyXG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcclxufTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcclxuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXHJcblxyXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XHJcbiAgc2NyaXB0LnNyYyA9IHVybDtcclxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcclxuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XHJcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ubG9hZCcpO1xyXG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxyXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXHJcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcclxuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcclxuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xyXG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXHJcbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNjcmlwdCkge1xyXG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxyXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xyXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcclxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXHJcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXHJcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcclxuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxyXG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXHJcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcclxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXHJcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxyXG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xyXG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xyXG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgfVxyXG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXHJcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcclxuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcclxuICBpZiAoc2NyaXB0Mikge1xyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcclxufVxyXG5cclxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XHJcbiAgZGVidWcodXJsKTtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xyXG5cclxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xyXG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XHJcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcclxuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xyXG4gICAgc2VsZi54byA9IG51bGw7XHJcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcclxuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcclxuICAgIHNlbGYuX2NsZWFudXAoKTtcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xyXG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcclxuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xyXG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XHJcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcclxuICAgIGlmIChtc2cpIHtcclxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xyXG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnYWJvcnQnKTtcclxuICBpZiAodGhpcy54bykge1xyXG4gICAgdGhpcy54by5jbG9zZSgpO1xyXG4gICAgZGVidWcoJ2Nsb3NlJyk7XHJcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcclxuICAgIHRoaXMueG8gPSBudWxsO1xyXG4gIH1cclxuICB0aGlzLl9jbGVhbnVwKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxyXG5cclxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcclxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcclxufVxyXG5cclxudmFyIGZvcm0sIGFyZWE7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcclxuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xyXG4gIHRyeSB7XHJcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcclxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xyXG4gIH0gY2F0Y2ggKHgpIHtcclxuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xyXG4gICAgcmV0dXJuIGlmcmFtZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XHJcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcclxuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcclxuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XHJcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XHJcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcclxuXHJcbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gIGFyZWEubmFtZSA9ICdkJztcclxuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xyXG5cclxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcclxuICBpZiAoIWZvcm0pIHtcclxuICAgIGNyZWF0ZUZvcm0oKTtcclxuICB9XHJcbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcclxuICBmb3JtLnRhcmdldCA9IGlkO1xyXG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xyXG5cclxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcclxuICBpZnJhbWUuaWQgPSBpZDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXHJcbiAgfVxyXG4gIGZvcm0uc3VibWl0KCk7XHJcblxyXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcclxuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcclxuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcclxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcclxuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICAgICAgaWZyYW1lID0gbnVsbDtcclxuICAgIH0sIDUwMCk7XHJcbiAgICBhcmVhLnZhbHVlID0gJyc7XHJcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXHJcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxyXG4gICAgY2FsbGJhY2soZXJyKTtcclxuICB9O1xyXG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcclxuICAgIGNvbXBsZXRlZCgpO1xyXG4gIH07XHJcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcclxuICAgIGNvbXBsZXRlZCgpO1xyXG4gIH07XHJcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xyXG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgIGNvbXBsZXRlZCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XHJcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXHJcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xyXG59XHJcblxyXG4vLyBSZWZlcmVuY2VzOlxyXG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxyXG5cclxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XHJcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcclxuICB9LCAwKTtcclxufVxyXG5cclxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xyXG4gIGRlYnVnKCdfc3RhcnQnKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcclxuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xyXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xyXG5cclxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29uZXJyb3InKTtcclxuICAgIHNlbGYuX2Vycm9yKCk7XHJcbiAgfTtcclxuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XHJcbiAgICBzZWxmLl9lcnJvcigpO1xyXG4gIH07XHJcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xyXG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XHJcbiAgfTtcclxuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygnbG9hZCcpO1xyXG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xyXG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XHJcbiAgfTtcclxuICB0aGlzLnhkciA9IHhkcjtcclxuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcclxuICB9KTtcclxuICB0cnkge1xyXG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcclxuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xyXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xyXG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xyXG4gICAgfVxyXG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcclxuICB9IGNhdGNoICh4KSB7XHJcbiAgICB0aGlzLl9lcnJvcigpO1xyXG4gIH1cclxufTtcclxuXHJcblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XHJcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbn07XHJcblxyXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcclxuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcclxuICBpZiAoIXRoaXMueGRyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xyXG5cclxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XHJcbiAgaWYgKGFib3J0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xyXG4gICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xyXG59O1xyXG5cclxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XHJcbn07XHJcblxyXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XHJcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XHJcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xyXG59XHJcblxyXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xyXG5cclxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcclxuXHJcbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XHJcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xyXG59O1xyXG5cclxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcclxuXHJcbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxyXG4gIDtcclxuXHJcbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XHJcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcclxuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XHJcblxyXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xyXG5cclxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXHJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcclxuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XHJcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xyXG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XHJcbiAgfVxyXG4gIHRoaXMudXJsID0gdXJsO1xyXG5cclxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xyXG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcclxuICB9O1xyXG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xyXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXHJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cclxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XHJcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygndW5sb2FkJyk7XHJcbiAgICBzZWxmLndzLmNsb3NlKCk7XHJcbiAgfSk7XHJcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgfTtcclxuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgfTtcclxufVxyXG5cclxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xyXG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcclxuICB0aGlzLndzLnNlbmQobXNnKTtcclxufTtcclxuXHJcbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnY2xvc2UnKTtcclxuICB2YXIgd3MgPSB0aGlzLndzO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICBpZiAod3MpIHtcclxuICAgIHdzLmNsb3NlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIHZhciB3cyA9IHRoaXMud3M7XHJcbiAgaWYgKHdzKSB7XHJcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XHJcbiAgfVxyXG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XHJcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG59O1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnZW5hYmxlZCcpO1xyXG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcclxufTtcclxuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcclxuXHJcbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXHJcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcclxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cclxuLy8gYWJzb2x1dGUgbWludW11bS5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXHJcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcclxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xyXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xyXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcclxuXHJcbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcclxuICA7XHJcblxyXG4vLyBBY2NvcmRpbmcgdG86XHJcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcclxuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cclxuXHJcbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xyXG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XHJcbn07XHJcblxyXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcclxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xyXG5cclxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU3fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcclxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XHJcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XHJcblxyXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XHJcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcclxufTtcclxuXHJcblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XHJcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xyXG5cclxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcclxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcclxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcclxuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XHJcbiAgfVxyXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xyXG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXHJcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXHJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xyXG59O1xyXG5cclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XHJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XHJcblxyXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXHJcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cclxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XHJcbiAgICByZXR1cm4gYnl0ZXM7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgIH1cclxuICAgIHJldHVybiBieXRlcztcclxuICB9O1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXHJcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcclxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xyXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cclxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcclxuXHJcbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxyXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcclxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcclxuICAsIGV4dHJhTG9va3VwO1xyXG5cclxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxyXG4vLyBjaGFyYWN0ZXJzLlxyXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHVucm9sbGVkID0ge307XHJcbiAgdmFyIGMgPSBbXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xyXG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XHJcbiAgfVxyXG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xyXG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcclxuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcclxuICAgIHJldHVybiAnJztcclxuICB9KTtcclxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcclxuICByZXR1cm4gdW5yb2xsZWQ7XHJcbn07XHJcblxyXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcclxuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XHJcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XHJcblxyXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxyXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcclxuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XHJcbiAgICAgIHJldHVybiBxdW90ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xyXG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcclxuXHJcbnZhciBvblVubG9hZCA9IHt9XHJcbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXHJcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcclxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcclxuICA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAvLyBJRSBxdWlya3MuXHJcbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxyXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cclxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxyXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xyXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xyXG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xyXG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XHJcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWY7XHJcbiAgfVxyXG5cclxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xyXG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xyXG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XHJcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcclxuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmIChhZnRlclVubG9hZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBhZnRlclVubG9hZCA9IHRydWU7XHJcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxyXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXHJcbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xyXG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBXUHJlZml4OiAnX2pwJ1xyXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxyXG5cclxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xyXG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XHJcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XHJcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcclxuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXHJcbiAgICAgICwgdHlwZTogdHlwZVxyXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcclxuICAgICAgfSksICcqJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcclxuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xyXG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xyXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XHJcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICAgIH1cclxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XHJcbiAgICAgIGlmIChpZnJhbWUpIHtcclxuICAgICAgICB1bmF0dGFjaCgpO1xyXG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxyXG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xyXG4gICAgICAgIC8vIG9udW5sb2FkLlxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XHJcbiAgICAgIGlmIChpZnJhbWUpIHtcclxuICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xyXG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cclxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cclxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcclxuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xyXG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgb25lcnJvcignb25lcnJvcicpO1xyXG4gICAgfTtcclxuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgZGVidWcoJ29ubG9hZCcpO1xyXG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcclxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cclxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xyXG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xyXG4gICAgICB9LCAyMDAwKTtcclxuICAgIH07XHJcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcclxuICAgIH0sIDE1MDAwKTtcclxuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcG9zdDogcG9zdFxyXG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXHJcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcclxuICAgIH07XHJcbiAgfVxyXG5cclxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXHJcbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XHJcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xyXG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcclxuICAgIHZhciBpZnJhbWU7XHJcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xyXG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGRvYykge1xyXG4gICAgICAgIHVuYXR0YWNoKCk7XHJcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcclxuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XHJcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xyXG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xyXG4gICAgICBpZiAoZG9jKSB7XHJcbiAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cclxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcclxuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jLm9wZW4oKTtcclxuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xyXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcclxuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XHJcbiAgICBkb2MuY2xvc2UoKTtcclxuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XHJcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xyXG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcclxuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcclxuICAgIH07XHJcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgb25lcnJvcigndGltZW91dCcpO1xyXG4gICAgfSwgMTUwMDApO1xyXG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwb3N0OiBwb3N0XHJcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcclxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XHJcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcclxuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcclxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxyXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcclxufVxyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGxvZ09iamVjdCA9IHt9O1xyXG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcclxuICB2YXIgbGV2ZWxFeGlzdHM7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbiAgfVxyXG5cclxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcclxuICB9XHJcblxyXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XHJcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXHJcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxyXG4vLyBiaWFzLlxyXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1JztcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xyXG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XHJcbiAgICB2YXIgcmV0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQuam9pbignJyk7XHJcbiAgfVxyXG5cclxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XHJcbiAgfVxyXG5cclxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xyXG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcclxuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XHJcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XHJcbiAgfVxyXG59O1xyXG5cclxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xyXG4gIHJldHVybiB7XHJcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcclxuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XHJcbiAgICAgICAgbWFpbjogW11cclxuICAgICAgLCBmYWNhZGU6IFtdXHJcbiAgICAgIH07XHJcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xyXG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcclxuICAgICAgICBpZiAoIXRyYW5zKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcclxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xyXG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xyXG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcImRlYnVnXCI6NTV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XHJcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcclxuICAgIGlmICghcG9ydCkge1xyXG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcclxuICB9XHJcblxyXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XHJcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XHJcbiAgfVxyXG5cclxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XHJcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcclxuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcclxuICB9XHJcblxyXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XHJcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcclxuICB9XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSAnMS4zLjAnO1xyXG5cclxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogSGVscGVycy5cclxuICovXHJcblxyXG52YXIgcyA9IDEwMDA7XHJcbnZhciBtID0gcyAqIDYwO1xyXG52YXIgaCA9IG0gKiA2MDtcclxudmFyIGQgPSBoICogMjQ7XHJcbnZhciB3ID0gZCAqIDc7XHJcbnZhciB5ID0gZCAqIDM2NS4yNTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxyXG4gKlxyXG4gKiBPcHRpb25zOlxyXG4gKlxyXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcclxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBwYXJzZSh2YWwpO1xyXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcclxuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XHJcbiAgc3RyID0gU3RyaW5nKHN0cik7XHJcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxyXG4gICAgc3RyXHJcbiAgKTtcclxuICBpZiAoIW1hdGNoKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XHJcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ3llYXJzJzpcclxuICAgIGNhc2UgJ3llYXInOlxyXG4gICAgY2FzZSAneXJzJzpcclxuICAgIGNhc2UgJ3lyJzpcclxuICAgIGNhc2UgJ3knOlxyXG4gICAgICByZXR1cm4gbiAqIHk7XHJcbiAgICBjYXNlICd3ZWVrcyc6XHJcbiAgICBjYXNlICd3ZWVrJzpcclxuICAgIGNhc2UgJ3cnOlxyXG4gICAgICByZXR1cm4gbiAqIHc7XHJcbiAgICBjYXNlICdkYXlzJzpcclxuICAgIGNhc2UgJ2RheSc6XHJcbiAgICBjYXNlICdkJzpcclxuICAgICAgcmV0dXJuIG4gKiBkO1xyXG4gICAgY2FzZSAnaG91cnMnOlxyXG4gICAgY2FzZSAnaG91cic6XHJcbiAgICBjYXNlICdocnMnOlxyXG4gICAgY2FzZSAnaHInOlxyXG4gICAgY2FzZSAnaCc6XHJcbiAgICAgIHJldHVybiBuICogaDtcclxuICAgIGNhc2UgJ21pbnV0ZXMnOlxyXG4gICAgY2FzZSAnbWludXRlJzpcclxuICAgIGNhc2UgJ21pbnMnOlxyXG4gICAgY2FzZSAnbWluJzpcclxuICAgIGNhc2UgJ20nOlxyXG4gICAgICByZXR1cm4gbiAqIG07XHJcbiAgICBjYXNlICdzZWNvbmRzJzpcclxuICAgIGNhc2UgJ3NlY29uZCc6XHJcbiAgICBjYXNlICdzZWNzJzpcclxuICAgIGNhc2UgJ3NlYyc6XHJcbiAgICBjYXNlICdzJzpcclxuICAgICAgcmV0dXJuIG4gKiBzO1xyXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcclxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcclxuICAgIGNhc2UgJ21zZWNzJzpcclxuICAgIGNhc2UgJ21zZWMnOlxyXG4gICAgY2FzZSAnbXMnOlxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xyXG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcclxuICBpZiAobXNBYnMgPj0gZCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcclxuICB9XHJcbiAgaWYgKG1zQWJzID49IGgpIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XHJcbiAgfVxyXG4gIGlmIChtc0FicyA+PSBtKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xyXG4gIH1cclxuICBpZiAobXNBYnMgPj0gcykge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcclxuICB9XHJcbiAgcmV0dXJuIG1zICsgJ21zJztcclxufVxyXG5cclxuLyoqXHJcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XHJcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xyXG4gIGlmIChtc0FicyA+PSBkKSB7XHJcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xyXG4gIH1cclxuICBpZiAobXNBYnMgPj0gaCkge1xyXG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XHJcbiAgfVxyXG4gIGlmIChtc0FicyA+PSBtKSB7XHJcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xyXG4gIH1cclxuICBpZiAobXNBYnMgPj0gcykge1xyXG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcclxuICB9XHJcbiAgcmV0dXJuIG1zICsgJyBtcyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XHJcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcclxuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcclxufVxyXG5cclxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XHJcblxyXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXHJcbiAqL1xyXG5leHBvcnRzLmxvZyA9IGxvZztcclxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcclxuZXhwb3J0cy5zYXZlID0gc2F2ZTtcclxuZXhwb3J0cy5sb2FkID0gbG9hZDtcclxuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XHJcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xyXG4vKipcclxuICogQ29sb3JzLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuY29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XHJcbi8qKlxyXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxyXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cclxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxyXG4gKlxyXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcclxuXHJcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcclxuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XHJcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcclxuICAvLyBleHBsaWNpdGx5XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxyXG5cclxuXHJcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xyXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXHJcblxyXG5cclxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcclxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xyXG59XHJcbi8qKlxyXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xyXG4gIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcclxuXHJcbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xyXG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cclxuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cclxuXHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICB2YXIgbGFzdEMgPSAwO1xyXG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaW5kZXgrKztcclxuXHJcbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcclxuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXHJcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXHJcbiAgICAgIGxhc3RDID0gaW5kZXg7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xyXG59XHJcbi8qKlxyXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cclxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gbG9nKCkge1xyXG4gIHZhciBfY29uc29sZTtcclxuXHJcbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcclxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xyXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcclxufVxyXG4vKipcclxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcclxuICB0cnkge1xyXG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcclxuICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcclxuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xyXG4gIH1cclxufVxyXG4vKipcclxuICogTG9hZCBgbmFtZXNwYWNlc2AuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGxvYWQoKSB7XHJcbiAgdmFyIHI7XHJcblxyXG4gIHRyeSB7XHJcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3dcclxuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cclxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXHJcblxyXG5cclxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcclxuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcclxuICB9XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcbi8qKlxyXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXHJcbiAqXHJcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xyXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxyXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcclxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXHJcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xyXG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XHJcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcclxuLyoqXHJcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cclxuICovXHJcbmZ1bmN0aW9uIHNldHVwKGVudikge1xyXG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XHJcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xyXG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcclxuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcclxuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XHJcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XHJcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xyXG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XHJcbiAgfSk7XHJcbiAgLyoqXHJcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXHJcbiAgKi9cclxuXHJcbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XHJcbiAgLyoqXHJcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cclxuICAqL1xyXG5cclxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xyXG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XHJcbiAgLyoqXHJcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXHJcbiAgKlxyXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxyXG4gICovXHJcblxyXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcclxuICAvKipcclxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcclxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxyXG4gICogQGFwaSBwcml2YXRlXHJcbiAgKi9cclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XHJcbiAgICB2YXIgaGFzaCA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XHJcbiAgLyoqXHJcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXHJcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XHJcbiAgICB2YXIgcHJldlRpbWU7XHJcblxyXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERpc2FibGVkP1xyXG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXHJcblxyXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcclxuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcclxuICAgICAgc2VsZi5kaWZmID0gbXM7XHJcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xyXG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xyXG4gICAgICBwcmV2VGltZSA9IGN1cnI7XHJcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cclxuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XHJcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblxyXG4gICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcclxuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XHJcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XHJcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcclxuXHJcbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICBpbmRleC0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcclxuXHJcbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcclxuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xyXG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xyXG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XHJcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XHJcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcclxuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XHJcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XHJcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xyXG5cclxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XHJcbiAgICByZXR1cm4gZGVidWc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XHJcblxyXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXHJcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxyXG4gICpcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXHJcbiAgKiBAYXBpIHB1YmxpY1xyXG4gICovXHJcblxyXG5cclxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xyXG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcclxuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XHJcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xyXG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKCFzcGxpdFtpXSkge1xyXG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xyXG5cclxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xyXG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcclxuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cclxuICAqXHJcbiAgKiBAYXBpIHB1YmxpY1xyXG4gICovXHJcblxyXG5cclxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xyXG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgKiBAYXBpIHB1YmxpY1xyXG4gICovXHJcblxyXG5cclxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcclxuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW47XHJcblxyXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKipcclxuICAqIENvZXJjZSBgdmFsYC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcclxuICAqIEByZXR1cm4ge01peGVkfVxyXG4gICogQGFwaSBwcml2YXRlXHJcbiAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcclxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWw7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcclxuICByZXR1cm4gY3JlYXRlRGVidWc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XHJcblxyXG5cclxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XHJcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxyXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcclxuICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICB2YWx1ZTogY3RvcixcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XHJcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxyXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cclxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcclxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcclxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxyXG4gIH1cclxufVxyXG5cclxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cclxuOyhmdW5jdGlvbiAoKSB7XHJcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXHJcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cclxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcclxuXHJcbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cclxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XHJcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICBcIm9iamVjdFwiOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxyXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XHJcblxyXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXHJcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcclxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXHJcbiAgLy8gaW5zdGVhZC5cclxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxyXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcclxuXHJcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcclxuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcclxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XHJcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcclxuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xyXG5cclxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxyXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcclxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXHJcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxyXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcclxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXHJcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxyXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcclxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XHJcblxyXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XHJcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XHJcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXHJcbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxyXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXHJcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XHJcblxyXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxyXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxyXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxyXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXHJcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcclxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxyXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cclxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cclxuXHJcbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxyXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcclxuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcclxuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXHJcbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XHJcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcclxuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXHJcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXHJcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcclxuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XHJcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXHJcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxyXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcclxuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XHJcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XHJcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXHJcbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cclxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cclxuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxyXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcclxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXHJcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XHJcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcclxuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcclxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cclxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xyXG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxyXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xyXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcclxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cclxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xyXG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxyXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcclxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxyXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxyXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxyXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcclxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xyXG5cclxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxyXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XHJcblxyXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cclxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XHJcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcclxuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxyXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXHJcbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxyXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXHJcbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xyXG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXHJcbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxyXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XHJcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XHJcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XHJcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cclxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXHJcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxyXG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxyXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcclxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXHJcbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxyXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcclxuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXHJcbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxyXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcclxuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXHJcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cclxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXHJcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cclxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cclxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XHJcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cclxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcclxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcclxuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXHJcbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBzaXplKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxyXG4gICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxyXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcclxuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxyXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cclxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcclxuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXHJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cclxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xyXG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cclxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxyXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXHJcbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxyXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxyXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xyXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXHJcbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcclxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcclxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XHJcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxyXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cclxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cclxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xyXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXHJcbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XHJcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxyXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxyXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxyXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcclxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXHJcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxyXG4gICAgICAgICAgOTogXCJcXFxcdFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXHJcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cclxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XHJcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxyXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXHJcbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXHJcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxyXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXHJcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cclxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xyXG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XHJcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcclxuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cclxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXHJcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxyXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcclxuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cclxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxyXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcclxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cclxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcclxuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcclxuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XHJcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cclxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcclxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cclxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcclxuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XHJcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xyXG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXHJcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xyXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxyXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcclxuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXHJcbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcclxuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcclxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXHJcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxyXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cclxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcclxuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XHJcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXHJcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cclxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xyXG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cclxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XHJcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xyXG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cclxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxyXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxyXG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cclxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxyXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXHJcbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cclxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cclxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcclxuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xyXG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXHJcbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xyXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xyXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcclxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXHJcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxyXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcclxuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcclxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cclxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xyXG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxyXG4gICAgICAgICAgMzQ6ICdcIicsXHJcbiAgICAgICAgICA0NzogXCIvXCIsXHJcbiAgICAgICAgICA5ODogXCJcXGJcIixcclxuICAgICAgICAgIDExNjogXCJcXHRcIixcclxuICAgICAgICAgIDExMDogXCJcXG5cIixcclxuICAgICAgICAgIDEwMjogXCJcXGZcIixcclxuICAgICAgICAgIDExNDogXCJcXHJcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cclxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxyXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcclxuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxyXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxyXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cclxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xyXG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcclxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgIEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XHJcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgIGNhc2UgMzQ6XHJcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cclxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xyXG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XHJcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcclxuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cclxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xyXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxyXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxyXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxyXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXHJcbiAgICAgICAgICByZXR1cm4gXCIkXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cclxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcclxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xyXG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XHJcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcclxuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cclxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cclxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcclxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxyXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcclxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxyXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXHJcbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxyXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXHJcbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXHJcbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcclxuICAgICAgICAgIEluZGV4ID0gMDtcclxuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XHJcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xyXG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXHJcbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXHJcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcclxuICAgIHJldHVybiBleHBvcnRzO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xyXG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXHJcbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxyXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXHJcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxyXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcclxuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxyXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cclxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcclxuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcclxuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcclxuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTjM7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICByb290LkpTT04gPSB7XHJcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXHJcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxyXG4gIGlmIChpc0xvYWRlcikge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIEpTT04zO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuLyoqXHJcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcclxuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cclxuICogQHJldHVybnMge09iamVjdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XHJcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xyXG4gICAgLCByZXN1bHQgPSB7fVxyXG4gICAgLCBwYXJ0O1xyXG5cclxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xyXG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxyXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cclxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcclxuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cclxuICAgIC8vXHJcbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XHJcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XHJcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xyXG5cclxuICB2YXIgcGFpcnMgPSBbXTtcclxuXHJcbiAgLy9cclxuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxyXG4gIC8vXHJcbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcclxufVxyXG5cclxuLy9cclxuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXHJcbi8vXHJcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XHJcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcclxuXHJcbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xyXG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcclxuICBwb3J0ID0gK3BvcnQ7XHJcblxyXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBzd2l0Y2ggKHByb3RvY29sKSB7XHJcbiAgICBjYXNlICdodHRwJzpcclxuICAgIGNhc2UgJ3dzJzpcclxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcclxuXHJcbiAgICBjYXNlICdodHRwcyc6XHJcbiAgICBjYXNlICd3c3MnOlxyXG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcclxuXHJcbiAgICBjYXNlICdmdHAnOlxyXG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xyXG5cclxuICAgIGNhc2UgJ2dvcGhlcic6XHJcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XHJcblxyXG4gICAgY2FzZSAnZmlsZSc6XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcG9ydCAhPT0gMDtcclxufTtcclxuXHJcbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcclxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxyXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxyXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXHJcbiAqIGFib3V0OlxyXG4gKlxyXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xyXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxyXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cclxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXHJcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXHJcbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cclxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxyXG4gKi9cclxudmFyIHJ1bGVzID0gW1xyXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxyXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxyXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXHJcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcclxuICB9LFxyXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxyXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cclxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXHJcbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxyXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cclxuXTtcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXHJcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcclxuICogb3JpZ2luLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcclxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXHJcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxyXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXHJcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXHJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcclxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWwgJiYgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xyXG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcclxuXHJcbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxyXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xyXG4gICAgLCBrZXk7XHJcblxyXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcclxuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcclxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XHJcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcclxuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcclxuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XHJcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcclxuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xyXG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xyXG59XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XHJcbiAqIEB0eXBlIE9iamVjdFxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cclxuICovXHJcblxyXG4vKipcclxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cclxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xyXG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcclxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXHJcbiAgICByZXN0OiBtYXRjaFszXVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cclxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcclxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXHJcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxyXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cclxuICAgICwgdW5zaGlmdCA9IGZhbHNlXHJcbiAgICAsIHVwID0gMDtcclxuXHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgdXArKztcclxuICAgIH0gZWxzZSBpZiAodXApIHtcclxuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgdXAtLTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xyXG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcclxuXHJcbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xyXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXHJcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXHJcbiAqXHJcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxyXG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cclxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xyXG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XHJcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcclxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxyXG4gICAgLCB1cmwgPSB0aGlzXHJcbiAgICAsIGkgPSAwO1xyXG5cclxuICAvL1xyXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXHJcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxyXG4gIC8vXHJcbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xyXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxyXG4gIC8vXHJcbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcclxuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXHJcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxyXG4gIC8vXHJcbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XHJcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcclxuICAgIGxvY2F0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XHJcblxyXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcclxuXHJcbiAgLy9cclxuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXHJcbiAgLy9cclxuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XHJcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcclxuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XHJcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xyXG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcclxuXHJcbiAgLy9cclxuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxyXG4gIC8vIGNvbXBvbmVudC5cclxuICAvL1xyXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xyXG5cclxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XHJcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcclxuXHJcbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XHJcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcclxuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xyXG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XHJcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcclxuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcclxuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcclxuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcclxuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxyXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xyXG4gICAgKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cclxuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cclxuICAgIC8vXHJcbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcclxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXHJcbiAgLy8gcGFyc2VyLlxyXG4gIC8vXHJcbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XHJcblxyXG4gIC8vXHJcbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXHJcbiAgLy9cclxuICBpZiAoXHJcbiAgICAgIHJlbGF0aXZlXHJcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXHJcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcclxuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcclxuICApIHtcclxuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXHJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXHJcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXHJcbiAgLy9cclxuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XHJcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcclxuICAgIHVybC5wb3J0ID0gJyc7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cclxuICAvL1xyXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xyXG4gIGlmICh1cmwuYXV0aCkge1xyXG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xyXG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XHJcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcclxuICB9XHJcblxyXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXHJcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcclxuICAgIDogJ251bGwnO1xyXG5cclxuICAvL1xyXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cclxuICAvL1xyXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXHJcbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxyXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxyXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XHJcbiAgdmFyIHVybCA9IHRoaXM7XHJcblxyXG4gIHN3aXRjaCAocGFydCkge1xyXG4gICAgY2FzZSAncXVlcnknOlxyXG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAncG9ydCc6XHJcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG5cclxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xyXG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xyXG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xyXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcclxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XHJcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJ2hvc3QnOlxyXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcclxuXHJcbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcclxuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xyXG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcclxuICAgICAgICB1cmwucG9ydCA9ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdwcm90b2NvbCc6XHJcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdwYXRobmFtZSc6XHJcbiAgICBjYXNlICdoYXNoJzpcclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xyXG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xyXG5cclxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcclxuICB9XHJcblxyXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXHJcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcclxuICAgIDogJ251bGwnO1xyXG5cclxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xyXG5cclxuICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xyXG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcclxuXHJcbiAgdmFyIHF1ZXJ5XHJcbiAgICAsIHVybCA9IHRoaXNcclxuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XHJcblxyXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xyXG5cclxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xyXG5cclxuICBpZiAodXJsLnVzZXJuYW1lKSB7XHJcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xyXG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xyXG4gICAgcmVzdWx0ICs9ICdAJztcclxuICB9XHJcblxyXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcclxuXHJcbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xyXG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xyXG5cclxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xyXG5cclxuLy9cclxuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3JcclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXHJcbi8vXHJcblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XHJcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcclxuVXJsLnFzID0gcXM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7XCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV19LHt9LFsxXSkoMSlcclxufSk7XHJcblxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///39\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\n\\r\\nvar SockJS = __webpack_require__(39);\\r\\n\\r\\nvar retries = 0;\\r\\nvar sock = null;\\r\\n\\r\\nvar socket = function initSocket(url, handlers) {\\r\\n  sock = new SockJS(url);\\r\\n\\r\\n  sock.onopen = function onopen() {\\r\\n    retries = 0;\\r\\n  };\\r\\n\\r\\n  sock.onclose = function onclose() {\\r\\n    if (retries === 0) {\\r\\n      handlers.close();\\r\\n    }\\r\\n\\r\\n    // Try to reconnect.\\r\\n    sock = null;\\r\\n\\r\\n    // After 10 retries stop trying, to prevent logspam.\\r\\n    if (retries <= 10) {\\r\\n      // Exponentially increase timeout to reconnect.\\r\\n      // Respectfully copied from the package `got`.\\r\\n      // eslint-disable-next-line no-mixed-operators, no-restricted-properties\\r\\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\\r\\n      retries += 1;\\r\\n\\r\\n      setTimeout(function () {\\r\\n        socket(url, handlers);\\r\\n      }, retryInMs);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  sock.onmessage = function onmessage(e) {\\r\\n    // This assumes that all data sent via the websocket is JSON.\\r\\n    var msg = JSON.parse(e.data);\\r\\n    if (handlers[msg.type]) {\\r\\n      handlers[msg.type](msg.data);\\r\\n    }\\r\\n  };\\r\\n};\\r\\n\\r\\nmodule.exports = socket;\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz9lMjljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxFQUEyQjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcclxuXHJcbnZhciByZXRyaWVzID0gMDtcclxudmFyIHNvY2sgPSBudWxsO1xyXG5cclxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xyXG4gIHNvY2sgPSBuZXcgU29ja0pTKHVybCk7XHJcblxyXG4gIHNvY2sub25vcGVuID0gZnVuY3Rpb24gb25vcGVuKCkge1xyXG4gICAgcmV0cmllcyA9IDA7XHJcbiAgfTtcclxuXHJcbiAgc29jay5vbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcclxuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XHJcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHRvIHJlY29ubmVjdC5cclxuICAgIHNvY2sgPSBudWxsO1xyXG5cclxuICAgIC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cclxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XHJcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXHJcbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXHJcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xyXG4gICAgICByZXRyaWVzICs9IDE7XHJcblxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XHJcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoZSkge1xyXG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgYWxsIGRhdGEgc2VudCB2aWEgdGhlIHdlYnNvY2tldCBpcyBKU09OLlxyXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcclxuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///40\\n\")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\\r\\n* loglevel - https://github.com/pimterry/loglevel\\r\\n*\\r\\n* Copyright (c) 2013 Tim Perry\\r\\n* Licensed under the MIT license.\\r\\n*/\\r\\n(function (root, definition) {\\r\\n    \"use strict\";\\r\\n    if (true) {\\r\\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\r\\n    } else {}\\r\\n}(this, function () {\\r\\n    \"use strict\";\\r\\n\\r\\n    // Slightly dubious tricks to cut down minimized file size\\r\\n    var noop = function() {};\\r\\n    var undefinedType = \"undefined\";\\r\\n\\r\\n    var logMethods = [\\r\\n        \"trace\",\\r\\n        \"debug\",\\r\\n        \"info\",\\r\\n        \"warn\",\\r\\n        \"error\"\\r\\n    ];\\r\\n\\r\\n    // Cross-browser bind equivalent that works at least back to IE6\\r\\n    function bindMethod(obj, methodName) {\\r\\n        var method = obj[methodName];\\r\\n        if (typeof method.bind === \\'function\\') {\\r\\n            return method.bind(obj);\\r\\n        } else {\\r\\n            try {\\r\\n                return Function.prototype.bind.call(method, obj);\\r\\n            } catch (e) {\\r\\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\\r\\n                return function() {\\r\\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\\r\\n                };\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Build the best logging method possible for this env\\r\\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\\r\\n    function realMethod(methodName) {\\r\\n        if (methodName === \\'debug\\') {\\r\\n            methodName = \\'log\\';\\r\\n        }\\r\\n\\r\\n        if (typeof console === undefinedType) {\\r\\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\\r\\n        } else if (console[methodName] !== undefined) {\\r\\n            return bindMethod(console, methodName);\\r\\n        } else if (console.log !== undefined) {\\r\\n            return bindMethod(console, \\'log\\');\\r\\n        } else {\\r\\n            return noop;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // These private functions always need `this` to be set properly\\r\\n\\r\\n    function replaceLoggingMethods(level, loggerName) {\\r\\n        /*jshint validthis:true */\\r\\n        for (var i = 0; i < logMethods.length; i++) {\\r\\n            var methodName = logMethods[i];\\r\\n            this[methodName] = (i < level) ?\\r\\n                noop :\\r\\n                this.methodFactory(methodName, level, loggerName);\\r\\n        }\\r\\n\\r\\n        // Define log.log as an alias for log.debug\\r\\n        this.log = this.debug;\\r\\n    }\\r\\n\\r\\n    // In old IE versions, the console isn\\'t present until you first open it.\\r\\n    // We build realMethod() replacements here that regenerate logging methods\\r\\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\\r\\n        return function () {\\r\\n            if (typeof console !== undefinedType) {\\r\\n                replaceLoggingMethods.call(this, level, loggerName);\\r\\n                this[methodName].apply(this, arguments);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    // By default, we use closely bound real methods wherever possible, and\\r\\n    // otherwise we wait for a console to appear, and then try again.\\r\\n    function defaultMethodFactory(methodName, level, loggerName) {\\r\\n        /*jshint validthis:true */\\r\\n        return realMethod(methodName) ||\\r\\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\\r\\n    }\\r\\n\\r\\n    function Logger(name, defaultLevel, factory) {\\r\\n      var self = this;\\r\\n      var currentLevel;\\r\\n      var storageKey = \"loglevel\";\\r\\n      if (name) {\\r\\n        storageKey += \":\" + name;\\r\\n      }\\r\\n\\r\\n      function persistLevelIfPossible(levelNum) {\\r\\n          var levelName = (logMethods[levelNum] || \\'silent\\').toUpperCase();\\r\\n\\r\\n          if (typeof window === undefinedType) return;\\r\\n\\r\\n          // Use localStorage if available\\r\\n          try {\\r\\n              window.localStorage[storageKey] = levelName;\\r\\n              return;\\r\\n          } catch (ignore) {}\\r\\n\\r\\n          // Use session cookie as fallback\\r\\n          try {\\r\\n              window.document.cookie =\\r\\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\\r\\n          } catch (ignore) {}\\r\\n      }\\r\\n\\r\\n      function getPersistedLevel() {\\r\\n          var storedLevel;\\r\\n\\r\\n          if (typeof window === undefinedType) return;\\r\\n\\r\\n          try {\\r\\n              storedLevel = window.localStorage[storageKey];\\r\\n          } catch (ignore) {}\\r\\n\\r\\n          // Fallback to cookies if local storage gives us nothing\\r\\n          if (typeof storedLevel === undefinedType) {\\r\\n              try {\\r\\n                  var cookie = window.document.cookie;\\r\\n                  var location = cookie.indexOf(\\r\\n                      encodeURIComponent(storageKey) + \"=\");\\r\\n                  if (location !== -1) {\\r\\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\\r\\n                  }\\r\\n              } catch (ignore) {}\\r\\n          }\\r\\n\\r\\n          // If the stored level is not valid, treat it as if nothing was stored.\\r\\n          if (self.levels[storedLevel] === undefined) {\\r\\n              storedLevel = undefined;\\r\\n          }\\r\\n\\r\\n          return storedLevel;\\r\\n      }\\r\\n\\r\\n      /*\\r\\n       *\\r\\n       * Public logger API - see https://github.com/pimterry/loglevel for details\\r\\n       *\\r\\n       */\\r\\n\\r\\n      self.name = name;\\r\\n\\r\\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\\r\\n          \"ERROR\": 4, \"SILENT\": 5};\\r\\n\\r\\n      self.methodFactory = factory || defaultMethodFactory;\\r\\n\\r\\n      self.getLevel = function () {\\r\\n          return currentLevel;\\r\\n      };\\r\\n\\r\\n      self.setLevel = function (level, persist) {\\r\\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\\r\\n              level = self.levels[level.toUpperCase()];\\r\\n          }\\r\\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\\r\\n              currentLevel = level;\\r\\n              if (persist !== false) {  // defaults to true\\r\\n                  persistLevelIfPossible(level);\\r\\n              }\\r\\n              replaceLoggingMethods.call(self, level, name);\\r\\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\\r\\n                  return \"No console available for logging\";\\r\\n              }\\r\\n          } else {\\r\\n              throw \"log.setLevel() called with invalid level: \" + level;\\r\\n          }\\r\\n      };\\r\\n\\r\\n      self.setDefaultLevel = function (level) {\\r\\n          if (!getPersistedLevel()) {\\r\\n              self.setLevel(level, false);\\r\\n          }\\r\\n      };\\r\\n\\r\\n      self.enableAll = function(persist) {\\r\\n          self.setLevel(self.levels.TRACE, persist);\\r\\n      };\\r\\n\\r\\n      self.disableAll = function(persist) {\\r\\n          self.setLevel(self.levels.SILENT, persist);\\r\\n      };\\r\\n\\r\\n      // Initialize with the right level\\r\\n      var initialLevel = getPersistedLevel();\\r\\n      if (initialLevel == null) {\\r\\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\\r\\n      }\\r\\n      self.setLevel(initialLevel, false);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     *\\r\\n     * Top-level API\\r\\n     *\\r\\n     */\\r\\n\\r\\n    var defaultLogger = new Logger();\\r\\n\\r\\n    var _loggersByName = {};\\r\\n    defaultLogger.getLogger = function getLogger(name) {\\r\\n        if (typeof name !== \"string\" || name === \"\") {\\r\\n          throw new TypeError(\"You must supply a name when creating a logger.\");\\r\\n        }\\r\\n\\r\\n        var logger = _loggersByName[name];\\r\\n        if (!logger) {\\r\\n          logger = _loggersByName[name] = new Logger(\\r\\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\\r\\n        }\\r\\n        return logger;\\r\\n    };\\r\\n\\r\\n    // Grab the current global log variable in case of overwrite\\r\\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\\r\\n    defaultLogger.noConflict = function() {\\r\\n        if (typeof window !== undefinedType &&\\r\\n               window.log === defaultLogger) {\\r\\n            window.log = _log;\\r\\n        }\\r\\n\\r\\n        return defaultLogger;\\r\\n    };\\r\\n\\r\\n    defaultLogger.getLoggers = function getLoggers() {\\r\\n        return _loggersByName;\\r\\n    };\\r\\n\\r\\n    return defaultLogger;\\r\\n}));\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzVjN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUIsS0FBSyxNQUFNLEVBSU47QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXHJcbipcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxyXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xyXG5cclxuICAgIHZhciBsb2dNZXRob2RzID0gW1xyXG4gICAgICAgIFwidHJhY2VcIixcclxuICAgICAgICBcImRlYnVnXCIsXHJcbiAgICAgICAgXCJpbmZvXCIsXHJcbiAgICAgICAgXCJ3YXJuXCIsXHJcbiAgICAgICAgXCJlcnJvclwiXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcclxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxyXG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXHJcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xyXG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xyXG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cclxuICAgICAgICAgICAgICAgIG5vb3AgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcclxuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxyXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcclxuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcclxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xyXG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXHJcbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgY3VycmVudExldmVsO1xyXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cclxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcclxuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXHJcbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xyXG4gICAgICAgKlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XHJcblxyXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xyXG5cclxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xyXG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xyXG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xyXG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XHJcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXHJcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcclxuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XHJcbiAgICAgIH1cclxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFRvcC1sZXZlbCBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcclxuXHJcbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcclxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XHJcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcclxuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcclxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcclxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcclxuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXHJcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcclxuICAgIH07XHJcblxyXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcclxuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xyXG59KSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///41\\n')},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nmodule.exports = function () {\\r\\n\\treturn /[\\\\u001b\\\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcz85ZWVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2QkFBNkIsWUFBWSxJQUFJLElBQUksTUFBTSxJQUFJO0FBQzNEIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///42\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar ansiRegex = __webpack_require__(42)();\\r\\n\\r\\nmodule.exports = function (str) {\\r\\n\\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcz83NjcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsRUFBWTs7QUFFcEM7QUFDQTtBQUNBIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///43\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n\\r\\n\\r\\nvar stringifyPrimitive = function(v) {\\r\\n  switch (typeof v) {\\r\\n    case 'string':\\r\\n      return v;\\r\\n\\r\\n    case 'boolean':\\r\\n      return v ? 'true' : 'false';\\r\\n\\r\\n    case 'number':\\r\\n      return isFinite(v) ? v : '';\\r\\n\\r\\n    default:\\r\\n      return '';\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = function(obj, sep, eq, name) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n  if (obj === null) {\\r\\n    obj = undefined;\\r\\n  }\\r\\n\\r\\n  if (typeof obj === 'object') {\\r\\n    return map(objectKeys(obj), function(k) {\\r\\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\\r\\n      if (isArray(obj[k])) {\\r\\n        return map(obj[k], function(v) {\\r\\n          return ks + encodeURIComponent(stringifyPrimitive(v));\\r\\n        }).join(sep);\\r\\n      } else {\\r\\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\\r\\n      }\\r\\n    }).join(sep);\\r\\n\\r\\n  }\\r\\n\\r\\n  if (!name) return '';\\r\\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\\r\\n         encodeURIComponent(stringifyPrimitive(obj));\\r\\n};\\r\\n\\r\\nvar isArray = Array.isArray || function (xs) {\\r\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\r\\n};\\r\\n\\r\\nfunction map (xs, f) {\\r\\n  if (xs.map) return xs.map(f);\\r\\n  var res = [];\\r\\n  for (var i = 0; i < xs.length; i++) {\\r\\n    res.push(f(xs[i], i));\\r\\n  }\\r\\n  return res;\\r\\n}\\r\\n\\r\\nvar objectKeys = Object.keys || function (obj) {\\r\\n  var res = [];\\r\\n  for (var key in obj) {\\r\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\\r\\n  }\\r\\n  return res;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcz9lMDk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xyXG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIHJldHVybiB2O1xyXG5cclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnJztcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xyXG4gIHNlcCA9IHNlcCB8fCAnJic7XHJcbiAgZXEgPSBlcSB8fCAnPSc7XHJcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgb2JqID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xyXG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xyXG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xyXG4gICAgICAgIH0pLmpvaW4oc2VwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xyXG4gICAgICB9XHJcbiAgICB9KS5qb2luKHNlcCk7XHJcblxyXG4gIH1cclxuXHJcbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xyXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xyXG59O1xyXG5cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWFwICh4cywgZikge1xyXG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///44\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n\\r\\n\\r\\n// If obj.hasOwnProperty has been overridden, then calling\\r\\n// obj.hasOwnProperty(prop) will break.\\r\\n// See: https://github.com/joyent/node/issues/1707\\r\\nfunction hasOwnProperty(obj, prop) {\\r\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\r\\n}\\r\\n\\r\\nmodule.exports = function(qs, sep, eq, options) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n  var obj = {};\\r\\n\\r\\n  if (typeof qs !== 'string' || qs.length === 0) {\\r\\n    return obj;\\r\\n  }\\r\\n\\r\\n  var regexp = /\\\\+/g;\\r\\n  qs = qs.split(sep);\\r\\n\\r\\n  var maxKeys = 1000;\\r\\n  if (options && typeof options.maxKeys === 'number') {\\r\\n    maxKeys = options.maxKeys;\\r\\n  }\\r\\n\\r\\n  var len = qs.length;\\r\\n  // maxKeys <= 0 means that we should not limit keys count\\r\\n  if (maxKeys > 0 && len > maxKeys) {\\r\\n    len = maxKeys;\\r\\n  }\\r\\n\\r\\n  for (var i = 0; i < len; ++i) {\\r\\n    var x = qs[i].replace(regexp, '%20'),\\r\\n        idx = x.indexOf(eq),\\r\\n        kstr, vstr, k, v;\\r\\n\\r\\n    if (idx >= 0) {\\r\\n      kstr = x.substr(0, idx);\\r\\n      vstr = x.substr(idx + 1);\\r\\n    } else {\\r\\n      kstr = x;\\r\\n      vstr = '';\\r\\n    }\\r\\n\\r\\n    k = decodeURIComponent(kstr);\\r\\n    v = decodeURIComponent(vstr);\\r\\n\\r\\n    if (!hasOwnProperty(obj, k)) {\\r\\n      obj[k] = v;\\r\\n    } else if (isArray(obj[k])) {\\r\\n      obj[k].push(v);\\r\\n    } else {\\r\\n      obj[k] = [obj[k], v];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return obj;\\r\\n};\\r\\n\\r\\nvar isArray = Array.isArray || function (xs) {\\r\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcz85MWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXHJcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxyXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcclxuICBzZXAgPSBzZXAgfHwgJyYnO1xyXG4gIGVxID0gZXEgfHwgJz0nO1xyXG4gIHZhciBvYmogPSB7fTtcclxuXHJcbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcclxuICBxcyA9IHFzLnNwbGl0KHNlcCk7XHJcblxyXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcclxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xyXG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcclxuICB9XHJcblxyXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XHJcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XHJcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcclxuICAgIGxlbiA9IG1heEtleXM7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXHJcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcclxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xyXG5cclxuICAgIGlmIChpZHggPj0gMCkge1xyXG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcclxuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAga3N0ciA9IHg7XHJcbiAgICAgIHZzdHIgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xyXG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcclxuXHJcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcclxuICAgICAgb2JqW2tdID0gdjtcclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XHJcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///45\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\n\\r\\nexports.decode = exports.parse = __webpack_require__(45);\\r\\nexports.encode = exports.stringify = __webpack_require__(44);\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzP2IzODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLG1CQUFPLENBQUMsRUFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQyxFQUFVIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcclxuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///46\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\n\\r\\nmodule.exports = {\\r\\n  isString: function(arg) {\\r\\n    return typeof(arg) === 'string';\\r\\n  },\\r\\n  isObject: function(arg) {\\r\\n    return typeof(arg) === 'object' && arg !== null;\\r\\n  },\\r\\n  isNull: function(arg) {\\r\\n    return arg === null;\\r\\n  },\\r\\n  isNullOrUndefined: function(arg) {\\r\\n    return arg == null;\\r\\n  }\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanM/MzVlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcclxuICB9LFxyXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xyXG4gIH0sXHJcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiBhcmcgPT09IG51bGw7XHJcbiAgfSxcclxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gYXJnID09IG51bGw7XHJcbiAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///47\\n\")},function(module,exports){eval('module.exports = function(module) {\\r\\n\\tif (!module.webpackPolyfill) {\\r\\n\\t\\tmodule.deprecate = function() {};\\r\\n\\t\\tmodule.paths = [];\\r\\n\\t\\t// module.parent = undefined by default\\r\\n\\t\\tif (!module.children) module.children = [];\\r\\n\\t\\tObject.defineProperty(module, \"loaded\", {\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tget: function() {\\r\\n\\t\\t\\t\\treturn module.l;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tObject.defineProperty(module, \"id\", {\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tget: function() {\\r\\n\\t\\t\\t\\treturn module.i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tmodule.webpackPolyfill = 1;\\r\\n\\t}\\r\\n\\treturn module;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///48\\n')},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\\r\\n;(function(root) {\\r\\n\\r\\n\\t/** Detect free variables */\\r\\n\\tvar freeExports = typeof exports == 'object' && exports &&\\r\\n\\t\\t!exports.nodeType && exports;\\r\\n\\tvar freeModule = typeof module == 'object' && module &&\\r\\n\\t\\t!module.nodeType && module;\\r\\n\\tvar freeGlobal = typeof global == 'object' && global;\\r\\n\\tif (\\r\\n\\t\\tfreeGlobal.global === freeGlobal ||\\r\\n\\t\\tfreeGlobal.window === freeGlobal ||\\r\\n\\t\\tfreeGlobal.self === freeGlobal\\r\\n\\t) {\\r\\n\\t\\troot = freeGlobal;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * The `punycode` object.\\r\\n\\t * @name punycode\\r\\n\\t * @type Object\\r\\n\\t */\\r\\n\\tvar punycode,\\r\\n\\r\\n\\t/** Highest positive signed 32-bit float value */\\r\\n\\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\\r\\n\\r\\n\\t/** Bootstring parameters */\\r\\n\\tbase = 36,\\r\\n\\ttMin = 1,\\r\\n\\ttMax = 26,\\r\\n\\tskew = 38,\\r\\n\\tdamp = 700,\\r\\n\\tinitialBias = 72,\\r\\n\\tinitialN = 128, // 0x80\\r\\n\\tdelimiter = '-', // '\\\\x2D'\\r\\n\\r\\n\\t/** Regular expressions */\\r\\n\\tregexPunycode = /^xn--/,\\r\\n\\tregexNonASCII = /[^\\\\x20-\\\\x7E]/, // unprintable ASCII chars + non-ASCII chars\\r\\n\\tregexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g, // RFC 3490 separators\\r\\n\\r\\n\\t/** Error messages */\\r\\n\\terrors = {\\r\\n\\t\\t'overflow': 'Overflow: input needs wider integers to process',\\r\\n\\t\\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\r\\n\\t\\t'invalid-input': 'Invalid input'\\r\\n\\t},\\r\\n\\r\\n\\t/** Convenience shortcuts */\\r\\n\\tbaseMinusTMin = base - tMin,\\r\\n\\tfloor = Math.floor,\\r\\n\\tstringFromCharCode = String.fromCharCode,\\r\\n\\r\\n\\t/** Temporary variable */\\r\\n\\tkey;\\r\\n\\r\\n\\t/*--------------------------------------------------------------------------*/\\r\\n\\r\\n\\t/**\\r\\n\\t * A generic error utility function.\\r\\n\\t * @private\\r\\n\\t * @param {String} type The error type.\\r\\n\\t * @returns {Error} Throws a `RangeError` with the applicable error message.\\r\\n\\t */\\r\\n\\tfunction error(type) {\\r\\n\\t\\tthrow new RangeError(errors[type]);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * A generic `Array#map` utility function.\\r\\n\\t * @private\\r\\n\\t * @param {Array} array The array to iterate over.\\r\\n\\t * @param {Function} callback The function that gets called for every array\\r\\n\\t * item.\\r\\n\\t * @returns {Array} A new array of values returned by the callback function.\\r\\n\\t */\\r\\n\\tfunction map(array, fn) {\\r\\n\\t\\tvar length = array.length;\\r\\n\\t\\tvar result = [];\\r\\n\\t\\twhile (length--) {\\r\\n\\t\\t\\tresult[length] = fn(array[length]);\\r\\n\\t\\t}\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * A simple `Array#map`-like wrapper to work with domain name strings or email\\r\\n\\t * addresses.\\r\\n\\t * @private\\r\\n\\t * @param {String} domain The domain name or email address.\\r\\n\\t * @param {Function} callback The function that gets called for every\\r\\n\\t * character.\\r\\n\\t * @returns {Array} A new string of characters returned by the callback\\r\\n\\t * function.\\r\\n\\t */\\r\\n\\tfunction mapDomain(string, fn) {\\r\\n\\t\\tvar parts = string.split('@');\\r\\n\\t\\tvar result = '';\\r\\n\\t\\tif (parts.length > 1) {\\r\\n\\t\\t\\t// In email addresses, only the domain name should be punycoded. Leave\\r\\n\\t\\t\\t// the local part (i.e. everything up to `@`) intact.\\r\\n\\t\\t\\tresult = parts[0] + '@';\\r\\n\\t\\t\\tstring = parts[1];\\r\\n\\t\\t}\\r\\n\\t\\t// Avoid `split(regex)` for IE8 compatibility. See #17.\\r\\n\\t\\tstring = string.replace(regexSeparators, '\\\\x2E');\\r\\n\\t\\tvar labels = string.split('.');\\r\\n\\t\\tvar encoded = map(labels, fn).join('.');\\r\\n\\t\\treturn result + encoded;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Creates an array containing the numeric code points of each Unicode\\r\\n\\t * character in the string. While JavaScript uses UCS-2 internally,\\r\\n\\t * this function will convert a pair of surrogate halves (each of which\\r\\n\\t * UCS-2 exposes as separate characters) into a single code point,\\r\\n\\t * matching UTF-16.\\r\\n\\t * @see `punycode.ucs2.encode`\\r\\n\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\r\\n\\t * @memberOf punycode.ucs2\\r\\n\\t * @name decode\\r\\n\\t * @param {String} string The Unicode input string (UCS-2).\\r\\n\\t * @returns {Array} The new array of code points.\\r\\n\\t */\\r\\n\\tfunction ucs2decode(string) {\\r\\n\\t\\tvar output = [],\\r\\n\\t\\t    counter = 0,\\r\\n\\t\\t    length = string.length,\\r\\n\\t\\t    value,\\r\\n\\t\\t    extra;\\r\\n\\t\\twhile (counter < length) {\\r\\n\\t\\t\\tvalue = string.charCodeAt(counter++);\\r\\n\\t\\t\\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\r\\n\\t\\t\\t\\t// high surrogate, and there is a next character\\r\\n\\t\\t\\t\\textra = string.charCodeAt(counter++);\\r\\n\\t\\t\\t\\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\\r\\n\\t\\t\\t\\t\\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t// unmatched surrogate; only append this code unit, in case the next\\r\\n\\t\\t\\t\\t\\t// code unit is the high surrogate of a surrogate pair\\r\\n\\t\\t\\t\\t\\toutput.push(value);\\r\\n\\t\\t\\t\\t\\tcounter--;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\toutput.push(value);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn output;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Creates a string based on an array of numeric code points.\\r\\n\\t * @see `punycode.ucs2.decode`\\r\\n\\t * @memberOf punycode.ucs2\\r\\n\\t * @name encode\\r\\n\\t * @param {Array} codePoints The array of numeric code points.\\r\\n\\t * @returns {String} The new Unicode string (UCS-2).\\r\\n\\t */\\r\\n\\tfunction ucs2encode(array) {\\r\\n\\t\\treturn map(array, function(value) {\\r\\n\\t\\t\\tvar output = '';\\r\\n\\t\\t\\tif (value > 0xFFFF) {\\r\\n\\t\\t\\t\\tvalue -= 0x10000;\\r\\n\\t\\t\\t\\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\r\\n\\t\\t\\t\\tvalue = 0xDC00 | value & 0x3FF;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\toutput += stringFromCharCode(value);\\r\\n\\t\\t\\treturn output;\\r\\n\\t\\t}).join('');\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a basic code point into a digit/integer.\\r\\n\\t * @see `digitToBasic()`\\r\\n\\t * @private\\r\\n\\t * @param {Number} codePoint The basic numeric code point value.\\r\\n\\t * @returns {Number} The numeric value of a basic code point (for use in\\r\\n\\t * representing integers) in the range `0` to `base - 1`, or `base` if\\r\\n\\t * the code point does not represent a value.\\r\\n\\t */\\r\\n\\tfunction basicToDigit(codePoint) {\\r\\n\\t\\tif (codePoint - 48 < 10) {\\r\\n\\t\\t\\treturn codePoint - 22;\\r\\n\\t\\t}\\r\\n\\t\\tif (codePoint - 65 < 26) {\\r\\n\\t\\t\\treturn codePoint - 65;\\r\\n\\t\\t}\\r\\n\\t\\tif (codePoint - 97 < 26) {\\r\\n\\t\\t\\treturn codePoint - 97;\\r\\n\\t\\t}\\r\\n\\t\\treturn base;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a digit/integer into a basic code point.\\r\\n\\t * @see `basicToDigit()`\\r\\n\\t * @private\\r\\n\\t * @param {Number} digit The numeric value of a basic code point.\\r\\n\\t * @returns {Number} The basic code point whose value (when used for\\r\\n\\t * representing integers) is `digit`, which needs to be in the range\\r\\n\\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\r\\n\\t * used; else, the lowercase form is used. The behavior is undefined\\r\\n\\t * if `flag` is non-zero and `digit` has no uppercase form.\\r\\n\\t */\\r\\n\\tfunction digitToBasic(digit, flag) {\\r\\n\\t\\t//  0..25 map to ASCII a..z or A..Z\\r\\n\\t\\t// 26..35 map to ASCII 0..9\\r\\n\\t\\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Bias adaptation function as per section 3.4 of RFC 3492.\\r\\n\\t * https://tools.ietf.org/html/rfc3492#section-3.4\\r\\n\\t * @private\\r\\n\\t */\\r\\n\\tfunction adapt(delta, numPoints, firstTime) {\\r\\n\\t\\tvar k = 0;\\r\\n\\t\\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\\r\\n\\t\\tdelta += floor(delta / numPoints);\\r\\n\\t\\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\\r\\n\\t\\t\\tdelta = floor(delta / baseMinusTMin);\\r\\n\\t\\t}\\r\\n\\t\\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\r\\n\\t * symbols.\\r\\n\\t * @memberOf punycode\\r\\n\\t * @param {String} input The Punycode string of ASCII-only symbols.\\r\\n\\t * @returns {String} The resulting string of Unicode symbols.\\r\\n\\t */\\r\\n\\tfunction decode(input) {\\r\\n\\t\\t// Don't use UCS-2\\r\\n\\t\\tvar output = [],\\r\\n\\t\\t    inputLength = input.length,\\r\\n\\t\\t    out,\\r\\n\\t\\t    i = 0,\\r\\n\\t\\t    n = initialN,\\r\\n\\t\\t    bias = initialBias,\\r\\n\\t\\t    basic,\\r\\n\\t\\t    j,\\r\\n\\t\\t    index,\\r\\n\\t\\t    oldi,\\r\\n\\t\\t    w,\\r\\n\\t\\t    k,\\r\\n\\t\\t    digit,\\r\\n\\t\\t    t,\\r\\n\\t\\t    /** Cached calculation results */\\r\\n\\t\\t    baseMinusT;\\r\\n\\r\\n\\t\\t// Handle the basic code points: let `basic` be the number of input code\\r\\n\\t\\t// points before the last delimiter, or `0` if there is none, then copy\\r\\n\\t\\t// the first basic code points to the output.\\r\\n\\r\\n\\t\\tbasic = input.lastIndexOf(delimiter);\\r\\n\\t\\tif (basic < 0) {\\r\\n\\t\\t\\tbasic = 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (j = 0; j < basic; ++j) {\\r\\n\\t\\t\\t// if it's not a basic code point\\r\\n\\t\\t\\tif (input.charCodeAt(j) >= 0x80) {\\r\\n\\t\\t\\t\\terror('not-basic');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\toutput.push(input.charCodeAt(j));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Main decoding loop: start just after the last delimiter if any basic code\\r\\n\\t\\t// points were copied; start at the beginning otherwise.\\r\\n\\r\\n\\t\\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\\r\\n\\r\\n\\t\\t\\t// `index` is the index of the next character to be consumed.\\r\\n\\t\\t\\t// Decode a generalized variable-length integer into `delta`,\\r\\n\\t\\t\\t// which gets added to `i`. The overflow checking is easier\\r\\n\\t\\t\\t// if we increase `i` as we go, then subtract off its starting\\r\\n\\t\\t\\t// value at the end to obtain `delta`.\\r\\n\\t\\t\\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\\r\\n\\r\\n\\t\\t\\t\\tif (index >= inputLength) {\\r\\n\\t\\t\\t\\t\\terror('invalid-input');\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tdigit = basicToDigit(input.charCodeAt(index++));\\r\\n\\r\\n\\t\\t\\t\\tif (digit >= base || digit > floor((maxInt - i) / w)) {\\r\\n\\t\\t\\t\\t\\terror('overflow');\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ti += digit * w;\\r\\n\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\r\\n\\r\\n\\t\\t\\t\\tif (digit < t) {\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbaseMinusT = base - t;\\r\\n\\t\\t\\t\\tif (w > floor(maxInt / baseMinusT)) {\\r\\n\\t\\t\\t\\t\\terror('overflow');\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tw *= baseMinusT;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tout = output.length + 1;\\r\\n\\t\\t\\tbias = adapt(i - oldi, out, oldi == 0);\\r\\n\\r\\n\\t\\t\\t// `i` was supposed to wrap around from `out` to `0`,\\r\\n\\t\\t\\t// incrementing `n` each time, so we'll fix that now:\\r\\n\\t\\t\\tif (floor(i / out) > maxInt - n) {\\r\\n\\t\\t\\t\\terror('overflow');\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tn += floor(i / out);\\r\\n\\t\\t\\ti %= out;\\r\\n\\r\\n\\t\\t\\t// Insert `n` at position `i` of the output\\r\\n\\t\\t\\toutput.splice(i++, 0, n);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ucs2encode(output);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\\r\\n\\t * Punycode string of ASCII-only symbols.\\r\\n\\t * @memberOf punycode\\r\\n\\t * @param {String} input The string of Unicode symbols.\\r\\n\\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\\r\\n\\t */\\r\\n\\tfunction encode(input) {\\r\\n\\t\\tvar n,\\r\\n\\t\\t    delta,\\r\\n\\t\\t    handledCPCount,\\r\\n\\t\\t    basicLength,\\r\\n\\t\\t    bias,\\r\\n\\t\\t    j,\\r\\n\\t\\t    m,\\r\\n\\t\\t    q,\\r\\n\\t\\t    k,\\r\\n\\t\\t    t,\\r\\n\\t\\t    currentValue,\\r\\n\\t\\t    output = [],\\r\\n\\t\\t    /** `inputLength` will hold the number of code points in `input`. */\\r\\n\\t\\t    inputLength,\\r\\n\\t\\t    /** Cached calculation results */\\r\\n\\t\\t    handledCPCountPlusOne,\\r\\n\\t\\t    baseMinusT,\\r\\n\\t\\t    qMinusT;\\r\\n\\r\\n\\t\\t// Convert the input in UCS-2 to Unicode\\r\\n\\t\\tinput = ucs2decode(input);\\r\\n\\r\\n\\t\\t// Cache the length\\r\\n\\t\\tinputLength = input.length;\\r\\n\\r\\n\\t\\t// Initialize the state\\r\\n\\t\\tn = initialN;\\r\\n\\t\\tdelta = 0;\\r\\n\\t\\tbias = initialBias;\\r\\n\\r\\n\\t\\t// Handle the basic code points\\r\\n\\t\\tfor (j = 0; j < inputLength; ++j) {\\r\\n\\t\\t\\tcurrentValue = input[j];\\r\\n\\t\\t\\tif (currentValue < 0x80) {\\r\\n\\t\\t\\t\\toutput.push(stringFromCharCode(currentValue));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\thandledCPCount = basicLength = output.length;\\r\\n\\r\\n\\t\\t// `handledCPCount` is the number of code points that have been handled;\\r\\n\\t\\t// `basicLength` is the number of basic code points.\\r\\n\\r\\n\\t\\t// Finish the basic string - if it is not empty - with a delimiter\\r\\n\\t\\tif (basicLength) {\\r\\n\\t\\t\\toutput.push(delimiter);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Main encoding loop:\\r\\n\\t\\twhile (handledCPCount < inputLength) {\\r\\n\\r\\n\\t\\t\\t// All non-basic code points < n have been handled already. Find the next\\r\\n\\t\\t\\t// larger one:\\r\\n\\t\\t\\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\\r\\n\\t\\t\\t\\tcurrentValue = input[j];\\r\\n\\t\\t\\t\\tif (currentValue >= n && currentValue < m) {\\r\\n\\t\\t\\t\\t\\tm = currentValue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\r\\n\\t\\t\\t// but guard against overflow\\r\\n\\t\\t\\thandledCPCountPlusOne = handledCPCount + 1;\\r\\n\\t\\t\\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\r\\n\\t\\t\\t\\terror('overflow');\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdelta += (m - n) * handledCPCountPlusOne;\\r\\n\\t\\t\\tn = m;\\r\\n\\r\\n\\t\\t\\tfor (j = 0; j < inputLength; ++j) {\\r\\n\\t\\t\\t\\tcurrentValue = input[j];\\r\\n\\r\\n\\t\\t\\t\\tif (currentValue < n && ++delta > maxInt) {\\r\\n\\t\\t\\t\\t\\terror('overflow');\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (currentValue == n) {\\r\\n\\t\\t\\t\\t\\t// Represent delta as a generalized variable-length integer\\r\\n\\t\\t\\t\\t\\tfor (q = delta, k = base; /* no condition */; k += base) {\\r\\n\\t\\t\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\r\\n\\t\\t\\t\\t\\t\\tif (q < t) {\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tqMinusT = q - t;\\r\\n\\t\\t\\t\\t\\t\\tbaseMinusT = base - t;\\r\\n\\t\\t\\t\\t\\t\\toutput.push(\\r\\n\\t\\t\\t\\t\\t\\t\\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\t\\tq = floor(qMinusT / baseMinusT);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\\r\\n\\t\\t\\t\\t\\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\r\\n\\t\\t\\t\\t\\tdelta = 0;\\r\\n\\t\\t\\t\\t\\t++handledCPCount;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t++delta;\\r\\n\\t\\t\\t++n;\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\treturn output.join('');\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a Punycode string representing a domain name or an email address\\r\\n\\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\r\\n\\t * it doesn't matter if you call it on a string that has already been\\r\\n\\t * converted to Unicode.\\r\\n\\t * @memberOf punycode\\r\\n\\t * @param {String} input The Punycoded domain name or email address to\\r\\n\\t * convert to Unicode.\\r\\n\\t * @returns {String} The Unicode representation of the given Punycode\\r\\n\\t * string.\\r\\n\\t */\\r\\n\\tfunction toUnicode(input) {\\r\\n\\t\\treturn mapDomain(input, function(string) {\\r\\n\\t\\t\\treturn regexPunycode.test(string)\\r\\n\\t\\t\\t\\t? decode(string.slice(4).toLowerCase())\\r\\n\\t\\t\\t\\t: string;\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Converts a Unicode string representing a domain name or an email address to\\r\\n\\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\\r\\n\\t * i.e. it doesn't matter if you call it with a domain that's already in\\r\\n\\t * ASCII.\\r\\n\\t * @memberOf punycode\\r\\n\\t * @param {String} input The domain name or email address to convert, as a\\r\\n\\t * Unicode string.\\r\\n\\t * @returns {String} The Punycode representation of the given domain name or\\r\\n\\t * email address.\\r\\n\\t */\\r\\n\\tfunction toASCII(input) {\\r\\n\\t\\treturn mapDomain(input, function(string) {\\r\\n\\t\\t\\treturn regexNonASCII.test(string)\\r\\n\\t\\t\\t\\t? 'xn--' + encode(string)\\r\\n\\t\\t\\t\\t: string;\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/*--------------------------------------------------------------------------*/\\r\\n\\r\\n\\t/** Define the public API */\\r\\n\\tpunycode = {\\r\\n\\t\\t/**\\r\\n\\t\\t * A string representing the current Punycode.js version number.\\r\\n\\t\\t * @memberOf punycode\\r\\n\\t\\t * @type String\\r\\n\\t\\t */\\r\\n\\t\\t'version': '1.4.1',\\r\\n\\t\\t/**\\r\\n\\t\\t * An object of methods to convert from JavaScript's internal character\\r\\n\\t\\t * representation (UCS-2) to Unicode code points, and back.\\r\\n\\t\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\r\\n\\t\\t * @memberOf punycode\\r\\n\\t\\t * @type Object\\r\\n\\t\\t */\\r\\n\\t\\t'ucs2': {\\r\\n\\t\\t\\t'decode': ucs2decode,\\r\\n\\t\\t\\t'encode': ucs2encode\\r\\n\\t\\t},\\r\\n\\t\\t'decode': decode,\\r\\n\\t\\t'encode': encode,\\r\\n\\t\\t'toASCII': toASCII,\\r\\n\\t\\t'toUnicode': toUnicode\\r\\n\\t};\\r\\n\\r\\n\\t/** Expose `punycode` */\\r\\n\\t// Some AMD build optimizers, like r.js, check for specific condition patterns\\r\\n\\t// like the following:\\r\\n\\tif (\\r\\n\\t\\ttrue\\r\\n\\t) {\\r\\n\\t\\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\\r\\n\\t\\t\\treturn punycode;\\r\\n\\t\\t}).call(exports, __webpack_require__, exports, module),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\r\\n\\t} else {}\\r\\n\\r\\n}(this));\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(48)(module), __webpack_require__(4)))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzPzE5ODUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFtQjtBQUNyQjtBQUNBLEdBQUc7QUFBQSxvR0FBQztBQUNKLEVBQUUsTUFBTSxFQWFOOztBQUVGLENBQUMiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xyXG47KGZ1bmN0aW9uKHJvb3QpIHtcclxuXHJcblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xyXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcclxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XHJcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxyXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XHJcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcclxuXHRpZiAoXHJcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxyXG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcclxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxyXG5cdCkge1xyXG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXHJcblx0ICogQG5hbWUgcHVueWNvZGVcclxuXHQgKiBAdHlwZSBPYmplY3RcclxuXHQgKi9cclxuXHR2YXIgcHVueWNvZGUsXHJcblxyXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cclxuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXHJcblxyXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cclxuXHRiYXNlID0gMzYsXHJcblx0dE1pbiA9IDEsXHJcblx0dE1heCA9IDI2LFxyXG5cdHNrZXcgPSAzOCxcclxuXHRkYW1wID0gNzAwLFxyXG5cdGluaXRpYWxCaWFzID0gNzIsXHJcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcclxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcclxuXHJcblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cclxuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcclxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcclxuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXHJcblxyXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xyXG5cdGVycm9ycyA9IHtcclxuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXHJcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxyXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcclxuXHR9LFxyXG5cclxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXHJcblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxyXG5cdGZsb29yID0gTWF0aC5mbG9vcixcclxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxyXG5cclxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXHJcblx0a2V5O1xyXG5cclxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0LyoqXHJcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cclxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcclxuXHQgKiBpdGVtLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XHJcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XHJcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXHJcblx0ICogYWRkcmVzc2VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcclxuXHQgKiBjaGFyYWN0ZXIuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcclxuXHQgKiBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xyXG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XHJcblx0XHR2YXIgcmVzdWx0ID0gJyc7XHJcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXHJcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXHJcblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xyXG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcclxuXHRcdH1cclxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cclxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XHJcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XHJcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XHJcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcclxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXHJcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcclxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcclxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXHJcblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXHJcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcclxuXHQgKiBAbmFtZSBkZWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xyXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxyXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxyXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXHJcblx0XHQgICAgdmFsdWUsXHJcblx0XHQgICAgZXh0cmE7XHJcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xyXG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XHJcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcclxuXHRcdFx0XHRcdGNvdW50ZXItLTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxyXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXHJcblx0ICogQG5hbWUgZW5jb2RlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xyXG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xyXG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcclxuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xyXG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xyXG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcclxuXHRcdFx0fVxyXG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcclxuXHRcdFx0cmV0dXJuIG91dHB1dDtcclxuXHRcdH0pLmpvaW4oJycpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxyXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxyXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcclxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XHJcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XHJcblx0XHR9XHJcblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XHJcblx0XHR9XHJcblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xyXG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYmFzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cclxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXHJcblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxyXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xyXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXHJcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcclxuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXHJcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcclxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxyXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcclxuXHRcdHZhciBrID0gMDtcclxuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XHJcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XHJcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xyXG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXHJcblx0ICogc3ltYm9scy5cclxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xyXG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXHJcblx0XHR2YXIgb3V0cHV0ID0gW10sXHJcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXHJcblx0XHQgICAgb3V0LFxyXG5cdFx0ICAgIGkgPSAwLFxyXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcclxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXHJcblx0XHQgICAgYmFzaWMsXHJcblx0XHQgICAgaixcclxuXHRcdCAgICBpbmRleCxcclxuXHRcdCAgICBvbGRpLFxyXG5cdFx0ICAgIHcsXHJcblx0XHQgICAgayxcclxuXHRcdCAgICBkaWdpdCxcclxuXHRcdCAgICB0LFxyXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xyXG5cdFx0ICAgIGJhc2VNaW51c1Q7XHJcblxyXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXHJcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxyXG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXHJcblxyXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xyXG5cdFx0aWYgKGJhc2ljIDwgMCkge1xyXG5cdFx0XHRiYXNpYyA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcclxuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XHJcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcclxuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxyXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cclxuXHJcblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xyXG5cclxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxyXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXHJcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXHJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXHJcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXHJcblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcclxuXHJcblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XHJcblxyXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcclxuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XHJcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XHJcblxyXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xyXG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcclxuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XHJcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xyXG5cclxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcclxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcclxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xyXG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xyXG5cdFx0XHRpICU9IG91dDtcclxuXHJcblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcclxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcclxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XHJcblx0XHR2YXIgbixcclxuXHRcdCAgICBkZWx0YSxcclxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcclxuXHRcdCAgICBiYXNpY0xlbmd0aCxcclxuXHRcdCAgICBiaWFzLFxyXG5cdFx0ICAgIGosXHJcblx0XHQgICAgbSxcclxuXHRcdCAgICBxLFxyXG5cdFx0ICAgIGssXHJcblx0XHQgICAgdCxcclxuXHRcdCAgICBjdXJyZW50VmFsdWUsXHJcblx0XHQgICAgb3V0cHV0ID0gW10sXHJcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cclxuXHRcdCAgICBpbnB1dExlbmd0aCxcclxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cclxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXHJcblx0XHQgICAgYmFzZU1pbnVzVCxcclxuXHRcdCAgICBxTWludXNUO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcclxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxyXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcclxuXHRcdG4gPSBpbml0aWFsTjtcclxuXHRcdGRlbHRhID0gMDtcclxuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcclxuXHJcblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXHJcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcclxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcclxuXHJcblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcclxuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cclxuXHJcblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xyXG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcclxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XHJcblxyXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XHJcblx0XHRcdC8vIGxhcmdlciBvbmU6XHJcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XHJcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XHJcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcclxuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXHJcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XHJcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcclxuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcclxuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcclxuXHRcdFx0biA9IG07XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xyXG5cclxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XHJcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xyXG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcclxuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XHJcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcclxuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xyXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcclxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xyXG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcclxuXHRcdFx0XHRcdGRlbHRhID0gMDtcclxuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQrK2RlbHRhO1xyXG5cdFx0XHQrK247XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcclxuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXHJcblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXHJcblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xyXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcclxuXHQgKiBzdHJpbmcuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XHJcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXHJcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXHJcblx0XHRcdFx0OiBzdHJpbmc7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xyXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxyXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxyXG5cdCAqIEFTQ0lJLlxyXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXHJcblx0ICogVW5pY29kZSBzdHJpbmcuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxyXG5cdCAqIGVtYWlsIGFkZHJlc3MuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xyXG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XHJcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxyXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcclxuXHRcdFx0XHQ6IHN0cmluZztcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cclxuXHRwdW55Y29kZSA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxyXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0XHQgKiBAdHlwZSBTdHJpbmdcclxuXHRcdCAqL1xyXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cclxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxyXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqL1xyXG5cdFx0J3VjczInOiB7XHJcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxyXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxyXG5cdFx0fSxcclxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXHJcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxyXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxyXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxyXG5cdH07XHJcblxyXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xyXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xyXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcclxuXHRpZiAoXHJcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcclxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXHJcblx0XHRkZWZpbmUuYW1kXHJcblx0KSB7XHJcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBwdW55Y29kZTtcclxuXHRcdH0pO1xyXG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xyXG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XHJcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcclxuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxyXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xyXG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXHJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XHJcblx0fVxyXG5cclxufSh0aGlzKSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///49\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n\\r\\n\\r\\nvar punycode = __webpack_require__(49);\\r\\nvar util = __webpack_require__(47);\\r\\n\\r\\nexports.parse = urlParse;\\r\\nexports.resolve = urlResolve;\\r\\nexports.resolveObject = urlResolveObject;\\r\\nexports.format = urlFormat;\\r\\n\\r\\nexports.Url = Url;\\r\\n\\r\\nfunction Url() {\\r\\n  this.protocol = null;\\r\\n  this.slashes = null;\\r\\n  this.auth = null;\\r\\n  this.host = null;\\r\\n  this.port = null;\\r\\n  this.hostname = null;\\r\\n  this.hash = null;\\r\\n  this.search = null;\\r\\n  this.query = null;\\r\\n  this.pathname = null;\\r\\n  this.path = null;\\r\\n  this.href = null;\\r\\n}\\r\\n\\r\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\r\\n\\r\\n// define these here so at least they only have to be\\r\\n// compiled once on the first module load.\\r\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\r\\n    portPattern = /:[0-9]*$/,\\r\\n\\r\\n    // Special case for a simple path URL\\r\\n    simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\r\\n\\r\\n    // RFC 2396: characters reserved for delimiting URLs.\\r\\n    // We actually just auto-escape these.\\r\\n    delims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'],\\r\\n\\r\\n    // RFC 2396: characters not allowed for various reasons.\\r\\n    unwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims),\\r\\n\\r\\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\r\\n    autoEscape = ['\\\\''].concat(unwise),\\r\\n    // Characters that are never ever allowed in a hostname.\\r\\n    // Note that any invalid chars are also handled, but these\\r\\n    // are the ones that are *expected* to be seen, so we fast-path\\r\\n    // them.\\r\\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\\r\\n    hostEndingChars = ['/', '?', '#'],\\r\\n    hostnameMaxLen = 255,\\r\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\r\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\r\\n    // protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\r\\n    unsafeProtocol = {\\r\\n      'javascript': true,\\r\\n      'javascript:': true\\r\\n    },\\r\\n    // protocols that never have a hostname.\\r\\n    hostlessProtocol = {\\r\\n      'javascript': true,\\r\\n      'javascript:': true\\r\\n    },\\r\\n    // protocols that always contain a // bit.\\r\\n    slashedProtocol = {\\r\\n      'http': true,\\r\\n      'https': true,\\r\\n      'ftp': true,\\r\\n      'gopher': true,\\r\\n      'file': true,\\r\\n      'http:': true,\\r\\n      'https:': true,\\r\\n      'ftp:': true,\\r\\n      'gopher:': true,\\r\\n      'file:': true\\r\\n    },\\r\\n    querystring = __webpack_require__(46);\\r\\n\\r\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\r\\n  if (url && util.isObject(url) && url instanceof Url) return url;\\r\\n\\r\\n  var u = new Url;\\r\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\r\\n  return u;\\r\\n}\\r\\n\\r\\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\\r\\n  if (!util.isString(url)) {\\r\\n    throw new TypeError(\\\"Parameter 'url' must be a string, not \\\" + typeof url);\\r\\n  }\\r\\n\\r\\n  // Copy chrome, IE, opera backslash-handling behavior.\\r\\n  // Back slashes before the query string get converted to forward slashes\\r\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\r\\n  var queryIndex = url.indexOf('?'),\\r\\n      splitter =\\r\\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\\r\\n      uSplit = url.split(splitter),\\r\\n      slashRegex = /\\\\\\\\/g;\\r\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\r\\n  url = uSplit.join(splitter);\\r\\n\\r\\n  var rest = url;\\r\\n\\r\\n  // trim before proceeding.\\r\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\r\\n  rest = rest.trim();\\r\\n\\r\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\r\\n    // Try fast path regexp\\r\\n    var simplePath = simplePathPattern.exec(rest);\\r\\n    if (simplePath) {\\r\\n      this.path = rest;\\r\\n      this.href = rest;\\r\\n      this.pathname = simplePath[1];\\r\\n      if (simplePath[2]) {\\r\\n        this.search = simplePath[2];\\r\\n        if (parseQueryString) {\\r\\n          this.query = querystring.parse(this.search.substr(1));\\r\\n        } else {\\r\\n          this.query = this.search.substr(1);\\r\\n        }\\r\\n      } else if (parseQueryString) {\\r\\n        this.search = '';\\r\\n        this.query = {};\\r\\n      }\\r\\n      return this;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var proto = protocolPattern.exec(rest);\\r\\n  if (proto) {\\r\\n    proto = proto[0];\\r\\n    var lowerProto = proto.toLowerCase();\\r\\n    this.protocol = lowerProto;\\r\\n    rest = rest.substr(proto.length);\\r\\n  }\\r\\n\\r\\n  // figure out if it's got a host\\r\\n  // user@server is *always* interpreted as a hostname, and url\\r\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\r\\n  // how the browser resolves relative URLs.\\r\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\r\\n    var slashes = rest.substr(0, 2) === '//';\\r\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\r\\n      rest = rest.substr(2);\\r\\n      this.slashes = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (!hostlessProtocol[proto] &&\\r\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\r\\n\\r\\n    // there's a hostname.\\r\\n    // the first instance of /, ?, ;, or # ends the host.\\r\\n    //\\r\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\r\\n    // to the left of the last @ sign, unless some host-ending character\\r\\n    // comes *before* the @-sign.\\r\\n    // URLs are obnoxious.\\r\\n    //\\r\\n    // ex:\\r\\n    // http://a@b@c/ => user:a@b host:c\\r\\n    // http://a@b?@c => user:a host:c path:/?@c\\r\\n\\r\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\r\\n    // Review our test case against browsers more comprehensively.\\r\\n\\r\\n    // find the first instance of any hostEndingChars\\r\\n    var hostEnd = -1;\\r\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\r\\n      var hec = rest.indexOf(hostEndingChars[i]);\\r\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\r\\n        hostEnd = hec;\\r\\n    }\\r\\n\\r\\n    // at this point, either we have an explicit point where the\\r\\n    // auth portion cannot go past, or the last @ char is the decider.\\r\\n    var auth, atSign;\\r\\n    if (hostEnd === -1) {\\r\\n      // atSign can be anywhere.\\r\\n      atSign = rest.lastIndexOf('@');\\r\\n    } else {\\r\\n      // atSign must be in auth portion.\\r\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\r\\n      atSign = rest.lastIndexOf('@', hostEnd);\\r\\n    }\\r\\n\\r\\n    // Now we have a portion which is definitely the auth.\\r\\n    // Pull that off.\\r\\n    if (atSign !== -1) {\\r\\n      auth = rest.slice(0, atSign);\\r\\n      rest = rest.slice(atSign + 1);\\r\\n      this.auth = decodeURIComponent(auth);\\r\\n    }\\r\\n\\r\\n    // the host is the remaining to the left of the first non-host char\\r\\n    hostEnd = -1;\\r\\n    for (var i = 0; i < nonHostChars.length; i++) {\\r\\n      var hec = rest.indexOf(nonHostChars[i]);\\r\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\r\\n        hostEnd = hec;\\r\\n    }\\r\\n    // if we still have not hit it, then the entire thing is a host.\\r\\n    if (hostEnd === -1)\\r\\n      hostEnd = rest.length;\\r\\n\\r\\n    this.host = rest.slice(0, hostEnd);\\r\\n    rest = rest.slice(hostEnd);\\r\\n\\r\\n    // pull out port.\\r\\n    this.parseHost();\\r\\n\\r\\n    // we've indicated that there is a hostname,\\r\\n    // so even if it's empty, it has to be present.\\r\\n    this.hostname = this.hostname || '';\\r\\n\\r\\n    // if hostname begins with [ and ends with ]\\r\\n    // assume that it's an IPv6 address.\\r\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\r\\n        this.hostname[this.hostname.length - 1] === ']';\\r\\n\\r\\n    // validate a little.\\r\\n    if (!ipv6Hostname) {\\r\\n      var hostparts = this.hostname.split(/\\\\./);\\r\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\r\\n        var part = hostparts[i];\\r\\n        if (!part) continue;\\r\\n        if (!part.match(hostnamePartPattern)) {\\r\\n          var newpart = '';\\r\\n          for (var j = 0, k = part.length; j < k; j++) {\\r\\n            if (part.charCodeAt(j) > 127) {\\r\\n              // we replace non-ASCII char with a temporary placeholder\\r\\n              // we need this to make sure size of hostname is not\\r\\n              // broken by replacing non-ASCII by nothing\\r\\n              newpart += 'x';\\r\\n            } else {\\r\\n              newpart += part[j];\\r\\n            }\\r\\n          }\\r\\n          // we test again with ASCII char only\\r\\n          if (!newpart.match(hostnamePartPattern)) {\\r\\n            var validParts = hostparts.slice(0, i);\\r\\n            var notHost = hostparts.slice(i + 1);\\r\\n            var bit = part.match(hostnamePartStart);\\r\\n            if (bit) {\\r\\n              validParts.push(bit[1]);\\r\\n              notHost.unshift(bit[2]);\\r\\n            }\\r\\n            if (notHost.length) {\\r\\n              rest = '/' + notHost.join('.') + rest;\\r\\n            }\\r\\n            this.hostname = validParts.join('.');\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (this.hostname.length > hostnameMaxLen) {\\r\\n      this.hostname = '';\\r\\n    } else {\\r\\n      // hostnames are always lower case.\\r\\n      this.hostname = this.hostname.toLowerCase();\\r\\n    }\\r\\n\\r\\n    if (!ipv6Hostname) {\\r\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\r\\n      // It only converts parts of the domain name that\\r\\n      // have non-ASCII characters, i.e. it doesn't matter if\\r\\n      // you call it with a domain that already is ASCII-only.\\r\\n      this.hostname = punycode.toASCII(this.hostname);\\r\\n    }\\r\\n\\r\\n    var p = this.port ? ':' + this.port : '';\\r\\n    var h = this.hostname || '';\\r\\n    this.host = h + p;\\r\\n    this.href += this.host;\\r\\n\\r\\n    // strip [ and ] from the hostname\\r\\n    // the host field still retains them, though\\r\\n    if (ipv6Hostname) {\\r\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\r\\n      if (rest[0] !== '/') {\\r\\n        rest = '/' + rest;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // now rest is set to the post-host stuff.\\r\\n  // chop off any delim chars.\\r\\n  if (!unsafeProtocol[lowerProto]) {\\r\\n\\r\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\r\\n    // escaped, even if encodeURIComponent doesn't think they\\r\\n    // need to be.\\r\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\r\\n      var ae = autoEscape[i];\\r\\n      if (rest.indexOf(ae) === -1)\\r\\n        continue;\\r\\n      var esc = encodeURIComponent(ae);\\r\\n      if (esc === ae) {\\r\\n        esc = escape(ae);\\r\\n      }\\r\\n      rest = rest.split(ae).join(esc);\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  // chop off from the tail first.\\r\\n  var hash = rest.indexOf('#');\\r\\n  if (hash !== -1) {\\r\\n    // got a fragment string.\\r\\n    this.hash = rest.substr(hash);\\r\\n    rest = rest.slice(0, hash);\\r\\n  }\\r\\n  var qm = rest.indexOf('?');\\r\\n  if (qm !== -1) {\\r\\n    this.search = rest.substr(qm);\\r\\n    this.query = rest.substr(qm + 1);\\r\\n    if (parseQueryString) {\\r\\n      this.query = querystring.parse(this.query);\\r\\n    }\\r\\n    rest = rest.slice(0, qm);\\r\\n  } else if (parseQueryString) {\\r\\n    // no query string, but parseQueryString still requested\\r\\n    this.search = '';\\r\\n    this.query = {};\\r\\n  }\\r\\n  if (rest) this.pathname = rest;\\r\\n  if (slashedProtocol[lowerProto] &&\\r\\n      this.hostname && !this.pathname) {\\r\\n    this.pathname = '/';\\r\\n  }\\r\\n\\r\\n  //to support http.request\\r\\n  if (this.pathname || this.search) {\\r\\n    var p = this.pathname || '';\\r\\n    var s = this.search || '';\\r\\n    this.path = p + s;\\r\\n  }\\r\\n\\r\\n  // finally, reconstruct the href based on what has been validated.\\r\\n  this.href = this.format();\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// format a parsed object into a url string\\r\\nfunction urlFormat(obj) {\\r\\n  // ensure it's an object, and not a string url.\\r\\n  // If it's an obj, this is a no-op.\\r\\n  // this way, you can call url_format() on strings\\r\\n  // to clean up potentially wonky urls.\\r\\n  if (util.isString(obj)) obj = urlParse(obj);\\r\\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\r\\n  return obj.format();\\r\\n}\\r\\n\\r\\nUrl.prototype.format = function() {\\r\\n  var auth = this.auth || '';\\r\\n  if (auth) {\\r\\n    auth = encodeURIComponent(auth);\\r\\n    auth = auth.replace(/%3A/i, ':');\\r\\n    auth += '@';\\r\\n  }\\r\\n\\r\\n  var protocol = this.protocol || '',\\r\\n      pathname = this.pathname || '',\\r\\n      hash = this.hash || '',\\r\\n      host = false,\\r\\n      query = '';\\r\\n\\r\\n  if (this.host) {\\r\\n    host = auth + this.host;\\r\\n  } else if (this.hostname) {\\r\\n    host = auth + (this.hostname.indexOf(':') === -1 ?\\r\\n        this.hostname :\\r\\n        '[' + this.hostname + ']');\\r\\n    if (this.port) {\\r\\n      host += ':' + this.port;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.query &&\\r\\n      util.isObject(this.query) &&\\r\\n      Object.keys(this.query).length) {\\r\\n    query = querystring.stringify(this.query);\\r\\n  }\\r\\n\\r\\n  var search = this.search || (query && ('?' + query)) || '';\\r\\n\\r\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\r\\n\\r\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\r\\n  // unless they had them to begin with.\\r\\n  if (this.slashes ||\\r\\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\\r\\n    host = '//' + (host || '');\\r\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\r\\n  } else if (!host) {\\r\\n    host = '';\\r\\n  }\\r\\n\\r\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\r\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\r\\n\\r\\n  pathname = pathname.replace(/[?#]/g, function(match) {\\r\\n    return encodeURIComponent(match);\\r\\n  });\\r\\n  search = search.replace('#', '%23');\\r\\n\\r\\n  return protocol + host + pathname + search + hash;\\r\\n};\\r\\n\\r\\nfunction urlResolve(source, relative) {\\r\\n  return urlParse(source, false, true).resolve(relative);\\r\\n}\\r\\n\\r\\nUrl.prototype.resolve = function(relative) {\\r\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\r\\n};\\r\\n\\r\\nfunction urlResolveObject(source, relative) {\\r\\n  if (!source) return relative;\\r\\n  return urlParse(source, false, true).resolveObject(relative);\\r\\n}\\r\\n\\r\\nUrl.prototype.resolveObject = function(relative) {\\r\\n  if (util.isString(relative)) {\\r\\n    var rel = new Url();\\r\\n    rel.parse(relative, false, true);\\r\\n    relative = rel;\\r\\n  }\\r\\n\\r\\n  var result = new Url();\\r\\n  var tkeys = Object.keys(this);\\r\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\r\\n    var tkey = tkeys[tk];\\r\\n    result[tkey] = this[tkey];\\r\\n  }\\r\\n\\r\\n  // hash is always overridden, no matter what.\\r\\n  // even href=\\\"\\\" will remove it.\\r\\n  result.hash = relative.hash;\\r\\n\\r\\n  // if the relative url is empty, then there's nothing left to do here.\\r\\n  if (relative.href === '') {\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  // hrefs like //foo/bar always cut to the protocol.\\r\\n  if (relative.slashes && !relative.protocol) {\\r\\n    // take everything except the protocol from relative\\r\\n    var rkeys = Object.keys(relative);\\r\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\r\\n      var rkey = rkeys[rk];\\r\\n      if (rkey !== 'protocol')\\r\\n        result[rkey] = relative[rkey];\\r\\n    }\\r\\n\\r\\n    //urlParse appends trailing / to urls like http://www.example.com\\r\\n    if (slashedProtocol[result.protocol] &&\\r\\n        result.hostname && !result.pathname) {\\r\\n      result.path = result.pathname = '/';\\r\\n    }\\r\\n\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\r\\n    // if it's a known url protocol, then changing\\r\\n    // the protocol does weird things\\r\\n    // first, if it's not file:, then we MUST have a host,\\r\\n    // and if there was a path\\r\\n    // to begin with, then we MUST have a path.\\r\\n    // if it is file:, then the host is dropped,\\r\\n    // because that's known to be hostless.\\r\\n    // anything else is assumed to be absolute.\\r\\n    if (!slashedProtocol[relative.protocol]) {\\r\\n      var keys = Object.keys(relative);\\r\\n      for (var v = 0; v < keys.length; v++) {\\r\\n        var k = keys[v];\\r\\n        result[k] = relative[k];\\r\\n      }\\r\\n      result.href = result.format();\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    result.protocol = relative.protocol;\\r\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\r\\n      var relPath = (relative.pathname || '').split('/');\\r\\n      while (relPath.length && !(relative.host = relPath.shift()));\\r\\n      if (!relative.host) relative.host = '';\\r\\n      if (!relative.hostname) relative.hostname = '';\\r\\n      if (relPath[0] !== '') relPath.unshift('');\\r\\n      if (relPath.length < 2) relPath.unshift('');\\r\\n      result.pathname = relPath.join('/');\\r\\n    } else {\\r\\n      result.pathname = relative.pathname;\\r\\n    }\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    result.host = relative.host || '';\\r\\n    result.auth = relative.auth;\\r\\n    result.hostname = relative.hostname || relative.host;\\r\\n    result.port = relative.port;\\r\\n    // to support http.request\\r\\n    if (result.pathname || result.search) {\\r\\n      var p = result.pathname || '';\\r\\n      var s = result.search || '';\\r\\n      result.path = p + s;\\r\\n    }\\r\\n    result.slashes = result.slashes || relative.slashes;\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\\r\\n      isRelAbs = (\\r\\n          relative.host ||\\r\\n          relative.pathname && relative.pathname.charAt(0) === '/'\\r\\n      ),\\r\\n      mustEndAbs = (isRelAbs || isSourceAbs ||\\r\\n                    (result.host && relative.pathname)),\\r\\n      removeAllDots = mustEndAbs,\\r\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\r\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\r\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\r\\n\\r\\n  // if the url is a non-slashed url, then relative\\r\\n  // links like ../.. should be able\\r\\n  // to crawl up to the hostname, as well.  This is strange.\\r\\n  // result.protocol has already been set by now.\\r\\n  // Later on, put the first path part into the host field.\\r\\n  if (psychotic) {\\r\\n    result.hostname = '';\\r\\n    result.port = null;\\r\\n    if (result.host) {\\r\\n      if (srcPath[0] === '') srcPath[0] = result.host;\\r\\n      else srcPath.unshift(result.host);\\r\\n    }\\r\\n    result.host = '';\\r\\n    if (relative.protocol) {\\r\\n      relative.hostname = null;\\r\\n      relative.port = null;\\r\\n      if (relative.host) {\\r\\n        if (relPath[0] === '') relPath[0] = relative.host;\\r\\n        else relPath.unshift(relative.host);\\r\\n      }\\r\\n      relative.host = null;\\r\\n    }\\r\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\r\\n  }\\r\\n\\r\\n  if (isRelAbs) {\\r\\n    // it's absolute.\\r\\n    result.host = (relative.host || relative.host === '') ?\\r\\n                  relative.host : result.host;\\r\\n    result.hostname = (relative.hostname || relative.hostname === '') ?\\r\\n                      relative.hostname : result.hostname;\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    srcPath = relPath;\\r\\n    // fall through to the dot-handling below.\\r\\n  } else if (relPath.length) {\\r\\n    // it's relative\\r\\n    // throw away the existing file, and take the new path instead.\\r\\n    if (!srcPath) srcPath = [];\\r\\n    srcPath.pop();\\r\\n    srcPath = srcPath.concat(relPath);\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n  } else if (!util.isNullOrUndefined(relative.search)) {\\r\\n    // just pull out the search.\\r\\n    // like href='?foo'.\\r\\n    // Put this after the other two cases because it simplifies the booleans\\r\\n    if (psychotic) {\\r\\n      result.hostname = result.host = srcPath.shift();\\r\\n      //occationaly the auth can get stuck only in host\\r\\n      //this especially happens in cases like\\r\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\r\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\\r\\n                       result.host.split('@') : false;\\r\\n      if (authInHost) {\\r\\n        result.auth = authInHost.shift();\\r\\n        result.host = result.hostname = authInHost.shift();\\r\\n      }\\r\\n    }\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    //to support http.request\\r\\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\r\\n      result.path = (result.pathname ? result.pathname : '') +\\r\\n                    (result.search ? result.search : '');\\r\\n    }\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  if (!srcPath.length) {\\r\\n    // no path at all.  easy.\\r\\n    // we've already handled the other stuff above.\\r\\n    result.pathname = null;\\r\\n    //to support http.request\\r\\n    if (result.search) {\\r\\n      result.path = '/' + result.search;\\r\\n    } else {\\r\\n      result.path = null;\\r\\n    }\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\r\\n  // however, if it ends in anything else non-slashy,\\r\\n  // then it must NOT get a trailing slash.\\r\\n  var last = srcPath.slice(-1)[0];\\r\\n  var hasTrailingSlash = (\\r\\n      (result.host || relative.host || srcPath.length > 1) &&\\r\\n      (last === '.' || last === '..') || last === '');\\r\\n\\r\\n  // strip single dots, resolve double dots to parent dir\\r\\n  // if the path tries to go above the root, `up` ends up > 0\\r\\n  var up = 0;\\r\\n  for (var i = srcPath.length; i >= 0; i--) {\\r\\n    last = srcPath[i];\\r\\n    if (last === '.') {\\r\\n      srcPath.splice(i, 1);\\r\\n    } else if (last === '..') {\\r\\n      srcPath.splice(i, 1);\\r\\n      up++;\\r\\n    } else if (up) {\\r\\n      srcPath.splice(i, 1);\\r\\n      up--;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // if the path is allowed to go above the root, restore leading ..s\\r\\n  if (!mustEndAbs && !removeAllDots) {\\r\\n    for (; up--; up) {\\r\\n      srcPath.unshift('..');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (mustEndAbs && srcPath[0] !== '' &&\\r\\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\r\\n    srcPath.unshift('');\\r\\n  }\\r\\n\\r\\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\\r\\n    srcPath.push('');\\r\\n  }\\r\\n\\r\\n  var isAbsolute = srcPath[0] === '' ||\\r\\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\\r\\n\\r\\n  // put the host back\\r\\n  if (psychotic) {\\r\\n    result.hostname = result.host = isAbsolute ? '' :\\r\\n                                    srcPath.length ? srcPath.shift() : '';\\r\\n    //occationaly the auth can get stuck only in host\\r\\n    //this especially happens in cases like\\r\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\r\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\\r\\n                     result.host.split('@') : false;\\r\\n    if (authInHost) {\\r\\n      result.auth = authInHost.shift();\\r\\n      result.host = result.hostname = authInHost.shift();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\\r\\n\\r\\n  if (mustEndAbs && !isAbsolute) {\\r\\n    srcPath.unshift('');\\r\\n  }\\r\\n\\r\\n  if (!srcPath.length) {\\r\\n    result.pathname = null;\\r\\n    result.path = null;\\r\\n  } else {\\r\\n    result.pathname = srcPath.join('/');\\r\\n  }\\r\\n\\r\\n  //to support request.http\\r\\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\r\\n    result.path = (result.pathname ? result.pathname : '') +\\r\\n                  (result.search ? result.search : '');\\r\\n  }\\r\\n  result.auth = relative.auth || result.auth;\\r\\n  result.slashes = result.slashes || relative.slashes;\\r\\n  result.href = result.format();\\r\\n  return result;\\r\\n};\\r\\n\\r\\nUrl.prototype.parseHost = function() {\\r\\n  var host = this.host;\\r\\n  var port = portPattern.exec(host);\\r\\n  if (port) {\\r\\n    port = port[0];\\r\\n    if (port !== ':') {\\r\\n      this.port = port.substr(1);\\r\\n    }\\r\\n    host = host.substr(0, host.length - port.length);\\r\\n  }\\r\\n  if (host) this.hostname = host;\\r\\n};\\r\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz8wYjE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLEVBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLEVBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBSzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRCwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLG1CQUFPLENBQUMsRUFBYTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcblxyXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XHJcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XHJcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XHJcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xyXG5cclxuZXhwb3J0cy5VcmwgPSBVcmw7XHJcblxyXG5mdW5jdGlvbiBVcmwoKSB7XHJcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XHJcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcclxuICB0aGlzLmF1dGggPSBudWxsO1xyXG4gIHRoaXMuaG9zdCA9IG51bGw7XHJcbiAgdGhpcy5wb3J0ID0gbnVsbDtcclxuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcclxuICB0aGlzLmhhc2ggPSBudWxsO1xyXG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcclxuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcclxuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcclxuICB0aGlzLnBhdGggPSBudWxsO1xyXG4gIHRoaXMuaHJlZiA9IG51bGw7XHJcbn1cclxuXHJcbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxyXG5cclxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcclxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXHJcbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxyXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxyXG5cclxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcclxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcclxuXHJcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxyXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cclxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxyXG5cclxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXHJcbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXHJcblxyXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxyXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXHJcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxyXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxyXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXHJcbiAgICAvLyB0aGVtLlxyXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXHJcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXHJcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcclxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXHJcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcclxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxyXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XHJcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxyXG4gICAgfSxcclxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cclxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XHJcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxyXG4gICAgfSxcclxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxyXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xyXG4gICAgICAnaHR0cCc6IHRydWUsXHJcbiAgICAgICdodHRwcyc6IHRydWUsXHJcbiAgICAgICdmdHAnOiB0cnVlLFxyXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcclxuICAgICAgJ2ZpbGUnOiB0cnVlLFxyXG4gICAgICAnaHR0cDonOiB0cnVlLFxyXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcclxuICAgICAgJ2Z0cDonOiB0cnVlLFxyXG4gICAgICAnZ29waGVyOic6IHRydWUsXHJcbiAgICAgICdmaWxlOic6IHRydWVcclxuICAgIH0sXHJcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XHJcblxyXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XHJcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xyXG5cclxuICB2YXIgdSA9IG5ldyBVcmw7XHJcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcclxuICByZXR1cm4gdTtcclxufVxyXG5cclxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcclxuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcclxuICB9XHJcblxyXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxyXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xyXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XHJcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxyXG4gICAgICBzcGxpdHRlciA9XHJcbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxyXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxyXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcclxuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xyXG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcclxuXHJcbiAgdmFyIHJlc3QgPSB1cmw7XHJcblxyXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXHJcbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxyXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcclxuXHJcbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcclxuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXHJcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XHJcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xyXG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xyXG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xyXG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcclxuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XHJcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcclxuICBpZiAocHJvdG8pIHtcclxuICAgIHByb3RvID0gcHJvdG9bMF07XHJcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcclxuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcclxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXHJcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xyXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxyXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xyXG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcclxuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XHJcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcclxuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcclxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcclxuXHJcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXHJcbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxyXG4gICAgLy9cclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcclxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXHJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxyXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxyXG4gICAgLy9cclxuICAgIC8vIGV4OlxyXG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcclxuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcclxuXHJcbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXHJcbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxyXG5cclxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcclxuICAgIHZhciBob3N0RW5kID0gLTE7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XHJcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcclxuICAgICAgICBob3N0RW5kID0gaGVjO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxyXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXHJcbiAgICB2YXIgYXV0aCwgYXRTaWduO1xyXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XHJcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXHJcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cclxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcclxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxyXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cclxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XHJcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XHJcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xyXG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxyXG4gICAgaG9zdEVuZCA9IC0xO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xyXG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXHJcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcclxuICAgIH1cclxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cclxuICAgIGlmIChob3N0RW5kID09PSAtMSlcclxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xyXG5cclxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XHJcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcclxuXHJcbiAgICAvLyBwdWxsIG91dCBwb3J0LlxyXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcclxuXHJcbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxyXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cclxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xyXG5cclxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXHJcbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cclxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcclxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cclxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XHJcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XHJcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcclxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcclxuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcclxuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XHJcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xyXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxyXG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xyXG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKGJpdCkge1xyXG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xyXG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xyXG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxyXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XHJcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxyXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XHJcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcclxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cclxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcclxuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcclxuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xyXG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcclxuXHJcbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXHJcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxyXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xyXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcclxuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xyXG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cclxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXHJcbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xyXG5cclxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcclxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxyXG4gICAgLy8gbmVlZCB0byBiZS5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcclxuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcclxuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcclxuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cclxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xyXG4gIGlmIChoYXNoICE9PSAtMSkge1xyXG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxyXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XHJcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcclxuICB9XHJcbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XHJcbiAgaWYgKHFtICE9PSAtMSkge1xyXG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XHJcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcclxuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcclxuICAgIH1cclxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcclxuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXHJcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xyXG4gICAgdGhpcy5xdWVyeSA9IHt9O1xyXG4gIH1cclxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XHJcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxyXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XHJcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xyXG4gIH1cclxuXHJcbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XHJcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XHJcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xyXG4gICAgdGhpcy5wYXRoID0gcCArIHM7XHJcbiAgfVxyXG5cclxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cclxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xyXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XHJcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cclxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxyXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcclxuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxyXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XHJcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcclxuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xyXG59XHJcblxyXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xyXG4gIGlmIChhdXRoKSB7XHJcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xyXG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XHJcbiAgICBhdXRoICs9ICdAJztcclxuICB9XHJcblxyXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXHJcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcclxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcclxuICAgICAgaG9zdCA9IGZhbHNlLFxyXG4gICAgICBxdWVyeSA9ICcnO1xyXG5cclxuICBpZiAodGhpcy5ob3N0KSB7XHJcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcclxuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcclxuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XHJcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XHJcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XHJcbiAgICBpZiAodGhpcy5wb3J0KSB7XHJcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMucXVlcnkgJiZcclxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxyXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcclxuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcclxuXHJcbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xyXG5cclxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cclxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxyXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcclxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xyXG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XHJcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XHJcbiAgfSBlbHNlIGlmICghaG9zdCkge1xyXG4gICAgaG9zdCA9ICcnO1xyXG4gIH1cclxuXHJcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XHJcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcclxuXHJcbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcclxuICB9KTtcclxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcclxuXHJcbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xyXG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcclxufVxyXG5cclxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcclxuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XHJcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcclxuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XHJcbn1cclxuXHJcblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XHJcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XHJcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xyXG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICByZWxhdGl2ZSA9IHJlbDtcclxuICB9XHJcblxyXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XHJcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XHJcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xyXG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XHJcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xyXG4gIH1cclxuXHJcbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXHJcbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXHJcbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xyXG5cclxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXHJcbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XHJcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cclxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcclxuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcclxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcclxuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcclxuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XHJcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxyXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXHJcbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcclxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xyXG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xyXG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xyXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXHJcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcclxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXHJcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXHJcbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxyXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXHJcbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXHJcbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcclxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XHJcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xyXG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcclxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcclxuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcclxuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XHJcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcclxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XHJcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XHJcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcclxuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcclxuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcclxuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcclxuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XHJcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XHJcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XHJcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xyXG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XHJcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XHJcbiAgICB9XHJcbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XHJcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXHJcbiAgICAgIGlzUmVsQWJzID0gKFxyXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxyXG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcclxuICAgICAgKSxcclxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxyXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcclxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcclxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXHJcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XHJcblxyXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcclxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXHJcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxyXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXHJcbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXHJcbiAgaWYgKHBzeWNob3RpYykge1xyXG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XHJcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XHJcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcclxuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XHJcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XHJcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcclxuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xyXG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcclxuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcclxuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xyXG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcclxuICB9XHJcblxyXG4gIGlmIChpc1JlbEFicykge1xyXG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cclxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cclxuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xyXG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XHJcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XHJcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcclxuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxyXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcclxuICAgIC8vIGl0J3MgcmVsYXRpdmVcclxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxyXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XHJcbiAgICBzcmNQYXRoLnBvcCgpO1xyXG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xyXG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcclxuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xyXG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxyXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cclxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xyXG4gICAgaWYgKHBzeWNob3RpYykge1xyXG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcclxuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxyXG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcclxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cclxuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XHJcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XHJcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XHJcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcclxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcclxuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XHJcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXHJcbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxyXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcclxuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcclxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XHJcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxyXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxyXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXHJcbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcclxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcclxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxyXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcclxuXHJcbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXHJcbiAgdmFyIHVwID0gMDtcclxuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcclxuICAgIGlmIChsYXN0ID09PSAnLicpIHtcclxuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XHJcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcclxuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIHVwKys7XHJcbiAgICB9IGVsc2UgaWYgKHVwKSB7XHJcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xyXG4gICAgICB1cC0tO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xyXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xyXG4gICAgZm9yICg7IHVwLS07IHVwKSB7XHJcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXHJcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xyXG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XHJcbiAgICBzcmNQYXRoLnB1c2goJycpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxyXG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcclxuXHJcbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcclxuICBpZiAocHN5Y2hvdGljKSB7XHJcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XHJcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XHJcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXHJcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xyXG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XHJcbiAgICBpZiAoYXV0aEluSG9zdCkge1xyXG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xyXG5cclxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xyXG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcclxuICB9XHJcblxyXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcclxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XHJcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xyXG4gIH1cclxuXHJcbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxyXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcclxuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcclxuICB9XHJcbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xyXG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcclxuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcclxuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XHJcbiAgaWYgKHBvcnQpIHtcclxuICAgIHBvcnQgPSBwb3J0WzBdO1xyXG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xyXG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcclxuICAgIH1cclxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcclxuICB9XHJcbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///50\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(__resourceQuery) {\\r\\n\\r\\n/* global __resourceQuery WorkerGlobalScope self */\\r\\n/* eslint prefer-destructuring: off */\\r\\n\\r\\nvar url = __webpack_require__(50);\\r\\nvar stripAnsi = __webpack_require__(43);\\r\\nvar log = __webpack_require__(41).getLogger('webpack-dev-server');\\r\\nvar socket = __webpack_require__(40);\\r\\nvar overlay = __webpack_require__(38);\\r\\n\\r\\nfunction getCurrentScriptSource() {\\r\\n  // `document.currentScript` is the most accurate way to find the current script,\\r\\n  // but is not supported in all browsers.\\r\\n  if (document.currentScript) {\\r\\n    return document.currentScript.getAttribute('src');\\r\\n  }\\r\\n  // Fall back to getting all scripts in the document.\\r\\n  var scriptElements = document.scripts || [];\\r\\n  var currentScript = scriptElements[scriptElements.length - 1];\\r\\n  if (currentScript) {\\r\\n    return currentScript.getAttribute('src');\\r\\n  }\\r\\n  // Fail as there was no script to use.\\r\\n  throw new Error('[WDS] Failed to get current script source.');\\r\\n}\\r\\n\\r\\nvar urlParts = void 0;\\r\\nvar hotReload = true;\\r\\nif (typeof window !== 'undefined') {\\r\\n  var qs = window.location.search.toLowerCase();\\r\\n  hotReload = qs.indexOf('hotreload=false') === -1;\\r\\n}\\r\\nif (true) {\\r\\n  // If this bundle is inlined, use the resource query to get the correct url.\\r\\n  urlParts = url.parse(__resourceQuery.substr(1));\\r\\n} else { var scriptHost; }\\r\\n\\r\\nif (!urlParts.port || urlParts.port === '0') {\\r\\n  urlParts.port = self.location.port;\\r\\n}\\r\\n\\r\\nvar _hot = false;\\r\\nvar initial = true;\\r\\nvar currentHash = '';\\r\\nvar useWarningOverlay = false;\\r\\nvar useErrorOverlay = false;\\r\\nvar useProgress = false;\\r\\n\\r\\nvar INFO = 'info';\\r\\nvar WARNING = 'warning';\\r\\nvar ERROR = 'error';\\r\\nvar NONE = 'none';\\r\\n\\r\\n// Set the default log level\\r\\nlog.setDefaultLevel(INFO);\\r\\n\\r\\n// Send messages to the outside, so plugins can consume it.\\r\\nfunction sendMsg(type, data) {\\r\\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\\r\\n    self.postMessage({\\r\\n      type: 'webpack' + type,\\r\\n      data: data\\r\\n    }, '*');\\r\\n  }\\r\\n}\\r\\n\\r\\nvar onSocketMsg = {\\r\\n  hot: function hot() {\\r\\n    _hot = true;\\r\\n    log.info('[WDS] Hot Module Replacement enabled.');\\r\\n  },\\r\\n  invalid: function invalid() {\\r\\n    log.info('[WDS] App updated. Recompiling...');\\r\\n    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\\r\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\r\\n    sendMsg('Invalid');\\r\\n  },\\r\\n  hash: function hash(_hash) {\\r\\n    currentHash = _hash;\\r\\n  },\\r\\n\\r\\n  'still-ok': function stillOk() {\\r\\n    log.info('[WDS] Nothing changed.');\\r\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\r\\n    sendMsg('StillOk');\\r\\n  },\\r\\n  'log-level': function logLevel(level) {\\r\\n    var hotCtx = __webpack_require__(33);\\r\\n    if (hotCtx.keys().indexOf('./log') !== -1) {\\r\\n      hotCtx('./log').setLogLevel(level);\\r\\n    }\\r\\n    switch (level) {\\r\\n      case INFO:\\r\\n      case ERROR:\\r\\n        log.setLevel(level);\\r\\n        break;\\r\\n      case WARNING:\\r\\n        // loglevel's warning name is different from webpack's\\r\\n        log.setLevel('warn');\\r\\n        break;\\r\\n      case NONE:\\r\\n        log.disableAll();\\r\\n        break;\\r\\n      default:\\r\\n        log.error('[WDS] Unknown clientLogLevel \\\\'' + level + '\\\\'');\\r\\n    }\\r\\n  },\\r\\n  overlay: function overlay(value) {\\r\\n    if (typeof document !== 'undefined') {\\r\\n      if (typeof value === 'boolean') {\\r\\n        useWarningOverlay = false;\\r\\n        useErrorOverlay = value;\\r\\n      } else if (value) {\\r\\n        useWarningOverlay = value.warnings;\\r\\n        useErrorOverlay = value.errors;\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n  progress: function progress(_progress) {\\r\\n    if (typeof document !== 'undefined') {\\r\\n      useProgress = _progress;\\r\\n    }\\r\\n  },\\r\\n\\r\\n  'progress-update': function progressUpdate(data) {\\r\\n    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');\\r\\n    sendMsg('Progress', data);\\r\\n  },\\r\\n  ok: function ok() {\\r\\n    sendMsg('Ok');\\r\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\r\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\r\\n    reloadApp();\\r\\n  },\\r\\n\\r\\n  'content-changed': function contentChanged() {\\r\\n    log.info('[WDS] Content base changed. Reloading...');\\r\\n    self.location.reload();\\r\\n  },\\r\\n  warnings: function warnings(_warnings) {\\r\\n    log.warn('[WDS] Warnings while compiling.');\\r\\n    var strippedWarnings = _warnings.map(function (warning) {\\r\\n      return stripAnsi(warning);\\r\\n    });\\r\\n    sendMsg('Warnings', strippedWarnings);\\r\\n    for (var i = 0; i < strippedWarnings.length; i++) {\\r\\n      log.warn(strippedWarnings[i]);\\r\\n    }\\r\\n    if (useWarningOverlay) overlay.showMessage(_warnings);\\r\\n\\r\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\r\\n    reloadApp();\\r\\n  },\\r\\n  errors: function errors(_errors) {\\r\\n    log.error('[WDS] Errors while compiling. Reload prevented.');\\r\\n    var strippedErrors = _errors.map(function (error) {\\r\\n      return stripAnsi(error);\\r\\n    });\\r\\n    sendMsg('Errors', strippedErrors);\\r\\n    for (var i = 0; i < strippedErrors.length; i++) {\\r\\n      log.error(strippedErrors[i]);\\r\\n    }\\r\\n    if (useErrorOverlay) overlay.showMessage(_errors);\\r\\n    initial = false;\\r\\n  },\\r\\n  error: function error(_error) {\\r\\n    log.error(_error);\\r\\n  },\\r\\n  close: function close() {\\r\\n    log.error('[WDS] Disconnected!');\\r\\n    sendMsg('Close');\\r\\n  }\\r\\n};\\r\\n\\r\\nvar hostname = urlParts.hostname;\\r\\nvar protocol = urlParts.protocol;\\r\\n\\r\\n// check ipv4 and ipv6 `all hostname`\\r\\nif (hostname === '0.0.0.0' || hostname === '::') {\\r\\n  // why do we need this check?\\r\\n  // hostname n/a for file protocol (example, when using electron, ionic)\\r\\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\\r\\n  // eslint-disable-next-line no-bitwise\\r\\n  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {\\r\\n    hostname = self.location.hostname;\\r\\n  }\\r\\n}\\r\\n\\r\\n// `hostname` can be empty when the script path is relative. In that case, specifying\\r\\n// a protocol would result in an invalid URL.\\r\\n// When https is used in the app, secure websockets are always necessary\\r\\n// because the browser doesn't accept non-secure websockets.\\r\\nif (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\\r\\n  protocol = self.location.protocol;\\r\\n}\\r\\n\\r\\nvar socketUrl = url.format({\\r\\n  protocol: protocol,\\r\\n  auth: urlParts.auth,\\r\\n  hostname: hostname,\\r\\n  port: urlParts.port,\\r\\n  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\\r\\n});\\r\\n\\r\\nsocket(socketUrl, onSocketMsg);\\r\\n\\r\\nvar isUnloading = false;\\r\\nself.addEventListener('beforeunload', function () {\\r\\n  isUnloading = true;\\r\\n});\\r\\n\\r\\nfunction reloadApp() {\\r\\n  if (isUnloading || !hotReload) {\\r\\n    return;\\r\\n  }\\r\\n  if (_hot) {\\r\\n    log.info('[WDS] App hot update...');\\r\\n    // eslint-disable-next-line global-require\\r\\n    var hotEmitter = __webpack_require__(14);\\r\\n    hotEmitter.emit('webpackHotUpdate', currentHash);\\r\\n    if (typeof self !== 'undefined' && self.window) {\\r\\n      // broadcast update to window\\r\\n      self.postMessage('webpackHotUpdate' + currentHash, '*');\\r\\n    }\\r\\n  } else {\\r\\n    var rootWindow = self;\\r\\n    // use parent window for reload (in case we're in an iframe with no valid src)\\r\\n    var intervalId = self.setInterval(function () {\\r\\n      if (rootWindow.location.protocol !== 'about:') {\\r\\n        // reload immediately if protocol is valid\\r\\n        applyReload(rootWindow, intervalId);\\r\\n      } else {\\r\\n        rootWindow = rootWindow.parent;\\r\\n        if (rootWindow.parent === rootWindow) {\\r\\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\\r\\n          applyReload(rootWindow, intervalId);\\r\\n        }\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function applyReload(rootWindow, intervalId) {\\r\\n    clearInterval(intervalId);\\r\\n    log.info('[WDS] App updated. Reloading...');\\r\\n    rootWindow.location.reload();\\r\\n  }\\r\\n}\\n/* WEBPACK VAR INJECTION */}.call(this, \\\"?http://localhost:8080\\\"))\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50PzgxZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsdURBQWE7O0FBRWI7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsRUFBSztBQUN2QixnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFZO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxFQUFVO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxFQUFVO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxFQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFzRDtBQUMxRDtBQUNBO0FBQ0EsQ0FBQyxNQUFNLG1CQU1OOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHVCQUFrRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cclxuLyogZXNsaW50IHByZWZlci1kZXN0cnVjdHVyaW5nOiBvZmYgKi9cclxuXHJcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcclxudmFyIHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcclxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcclxudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XHJcbnZhciBvdmVybGF5ID0gcmVxdWlyZSgnLi9vdmVybGF5Jyk7XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xyXG4gIC8vIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0YCBpcyB0aGUgbW9zdCBhY2N1cmF0ZSB3YXkgdG8gZmluZCB0aGUgY3VycmVudCBzY3JpcHQsXHJcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxyXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xyXG4gIH1cclxuICAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcclxuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xyXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XHJcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xyXG4gIH1cclxuICAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxyXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XHJcbn1cclxuXHJcbnZhciB1cmxQYXJ0cyA9IHZvaWQgMDtcclxudmFyIGhvdFJlbG9hZCA9IHRydWU7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHZhciBxcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gudG9Mb3dlckNhc2UoKTtcclxuICBob3RSZWxvYWQgPSBxcy5pbmRleE9mKCdob3RyZWxvYWQ9ZmFsc2UnKSA9PT0gLTE7XHJcbn1cclxuaWYgKHR5cGVvZiBfX3Jlc291cmNlUXVlcnkgPT09ICdzdHJpbmcnICYmIF9fcmVzb3VyY2VRdWVyeSkge1xyXG4gIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cclxuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShfX3Jlc291cmNlUXVlcnkuc3Vic3RyKDEpKTtcclxufSBlbHNlIHtcclxuICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxyXG4gIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxyXG4gIHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgJycpO1xyXG4gIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XHJcbn1cclxuXHJcbmlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcclxuICB1cmxQYXJ0cy5wb3J0ID0gc2VsZi5sb2NhdGlvbi5wb3J0O1xyXG59XHJcblxyXG52YXIgX2hvdCA9IGZhbHNlO1xyXG52YXIgaW5pdGlhbCA9IHRydWU7XHJcbnZhciBjdXJyZW50SGFzaCA9ICcnO1xyXG52YXIgdXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcclxudmFyIHVzZUVycm9yT3ZlcmxheSA9IGZhbHNlO1xyXG52YXIgdXNlUHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbnZhciBJTkZPID0gJ2luZm8nO1xyXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcclxudmFyIEVSUk9SID0gJ2Vycm9yJztcclxudmFyIE5PTkUgPSAnbm9uZSc7XHJcblxyXG4vLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XHJcblxyXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxyXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcclxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcclxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICB0eXBlOiAnd2VicGFjaycgKyB0eXBlLFxyXG4gICAgICBkYXRhOiBkYXRhXHJcbiAgICB9LCAnKicpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIG9uU29ja2V0TXNnID0ge1xyXG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xyXG4gICAgX2hvdCA9IHRydWU7XHJcbiAgICBsb2cuaW5mbygnW1dEU10gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLicpO1xyXG4gIH0sXHJcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcclxuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTtcclxuICAgIC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxyXG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5IHx8IHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5jbGVhcigpO1xyXG4gICAgc2VuZE1zZygnSW52YWxpZCcpO1xyXG4gIH0sXHJcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xyXG4gICAgY3VycmVudEhhc2ggPSBfaGFzaDtcclxuICB9LFxyXG5cclxuICAnc3RpbGwtb2snOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xyXG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcclxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcclxuICAgIHNlbmRNc2coJ1N0aWxsT2snKTtcclxuICB9LFxyXG4gICdsb2ctbGV2ZWwnOiBmdW5jdGlvbiBsb2dMZXZlbChsZXZlbCkge1xyXG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XHJcbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xyXG4gICAgICBob3RDdHgoJy4vbG9nJykuc2V0TG9nTGV2ZWwobGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChsZXZlbCkge1xyXG4gICAgICBjYXNlIElORk86XHJcbiAgICAgIGNhc2UgRVJST1I6XHJcbiAgICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBXQVJOSU5HOlxyXG4gICAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xyXG4gICAgICAgIGxvZy5zZXRMZXZlbCgnd2FybicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIE5PTkU6XHJcbiAgICAgICAgbG9nLmRpc2FibGVBbGwoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBsb2cuZXJyb3IoJ1tXRFNdIFVua25vd24gY2xpZW50TG9nTGV2ZWwgXFwnJyArIGxldmVsICsgJ1xcJycpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcclxuICAgICAgICB1c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XHJcbiAgICAgICAgdXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB1c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xyXG4gICAgaWYgKHVzZVByb2dyZXNzKSBsb2cuaW5mbygnW1dEU10gJyArIGRhdGEucGVyY2VudCArICclIC0gJyArIGRhdGEubXNnICsgJy4nKTtcclxuICAgIHNlbmRNc2coJ1Byb2dyZXNzJywgZGF0YSk7XHJcbiAgfSxcclxuICBvazogZnVuY3Rpb24gb2soKSB7XHJcbiAgICBzZW5kTXNnKCdPaycpO1xyXG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5IHx8IHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5jbGVhcigpO1xyXG4gICAgaWYgKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxyXG4gICAgcmVsb2FkQXBwKCk7XHJcbiAgfSxcclxuXHJcbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xyXG4gICAgbG9nLmluZm8oJ1tXRFNdIENvbnRlbnQgYmFzZSBjaGFuZ2VkLiBSZWxvYWRpbmcuLi4nKTtcclxuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgfSxcclxuICB3YXJuaW5nczogZnVuY3Rpb24gd2FybmluZ3MoX3dhcm5pbmdzKSB7XHJcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xyXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XHJcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZyk7XHJcbiAgICB9KTtcclxuICAgIHNlbmRNc2coJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkpIG92ZXJsYXkuc2hvd01lc3NhZ2UoX3dhcm5pbmdzKTtcclxuXHJcbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXHJcbiAgICByZWxvYWRBcHAoKTtcclxuICB9LFxyXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcclxuICAgIGxvZy5lcnJvcignW1dEU10gRXJyb3JzIHdoaWxlIGNvbXBpbGluZy4gUmVsb2FkIHByZXZlbnRlZC4nKTtcclxuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcclxuICAgIH0pO1xyXG4gICAgc2VuZE1zZygnRXJyb3JzJywgc3RyaXBwZWRFcnJvcnMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcclxuICAgIGluaXRpYWwgPSBmYWxzZTtcclxuICB9LFxyXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcclxuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xyXG4gIH0sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XHJcbiAgICBzZW5kTXNnKCdDbG9zZScpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xyXG52YXIgcHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbDtcclxuXHJcbi8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcclxuaWYgKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpIHtcclxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xyXG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXHJcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gIGlmIChzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XHJcbiAgICBob3N0bmFtZSA9IHNlbGYubG9jYXRpb24uaG9zdG5hbWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXHJcbi8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxyXG4vLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcclxuLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXHJcbmlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcclxuICBwcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XHJcbn1cclxuXHJcbnZhciBzb2NrZXRVcmwgPSB1cmwuZm9ybWF0KHtcclxuICBwcm90b2NvbDogcHJvdG9jb2wsXHJcbiAgYXV0aDogdXJsUGFydHMuYXV0aCxcclxuICBob3N0bmFtZTogaG9zdG5hbWUsXHJcbiAgcG9ydDogdXJsUGFydHMucG9ydCxcclxuICBwYXRobmFtZTogdXJsUGFydHMucGF0aCA9PSBudWxsIHx8IHVybFBhcnRzLnBhdGggPT09ICcvJyA/ICcvc29ja2pzLW5vZGUnIDogdXJsUGFydHMucGF0aFxyXG59KTtcclxuXHJcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TXNnKTtcclxuXHJcbnZhciBpc1VubG9hZGluZyA9IGZhbHNlO1xyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICBpc1VubG9hZGluZyA9IHRydWU7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gcmVsb2FkQXBwKCkge1xyXG4gIGlmIChpc1VubG9hZGluZyB8fCAhaG90UmVsb2FkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChfaG90KSB7XHJcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxyXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XHJcbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XHJcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XHJcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoJ3dlYnBhY2tIb3RVcGRhdGUnICsgY3VycmVudEhhc2gsICcqJyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciByb290V2luZG93ID0gc2VsZjtcclxuICAgIC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxyXG4gICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XHJcbiAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXHJcbiAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xyXG4gICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xyXG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xyXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XHJcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xyXG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICB9XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///51\\n\")},function(c,n,g){g(51),g(31),c.exports=g(54)},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + \"logo.png?82b9c7a5a3f405032b1db71a25f67021\";\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2xvZ28ucG5nPzA0ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImxvZ28ucG5nPzgyYjljN2E1YTNmNDA1MDMyYjFkYjcxYTI1ZjY3MDIxXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///53\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n\\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm.js\\nvar vue_esm = __webpack_require__(1);\\n\\n// CONCATENATED MODULE: ./node_modules/vue-router/dist/vue-router.esm.js\\n/*!\\r\\n  * vue-router v3.0.2\\r\\n  * (c) 2018 Evan You\\r\\n  * @license MIT\\r\\n  */\\r\\n/*  */\\r\\n\\r\\nfunction assert (condition, message) {\\r\\n  if (!condition) {\\r\\n    throw new Error((\\\"[vue-router] \\\" + message))\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction warn (condition, message) {\\r\\n  if (false) {}\\r\\n}\\r\\n\\r\\nfunction isError (err) {\\r\\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\\r\\n}\\r\\n\\r\\nfunction extend (a, b) {\\r\\n  for (var key in b) {\\r\\n    a[key] = b[key];\\r\\n  }\\r\\n  return a\\r\\n}\\r\\n\\r\\nvar View = {\\r\\n  name: 'RouterView',\\r\\n  functional: true,\\r\\n  props: {\\r\\n    name: {\\r\\n      type: String,\\r\\n      default: 'default'\\r\\n    }\\r\\n  },\\r\\n  render: function render (_, ref) {\\r\\n    var props = ref.props;\\r\\n    var children = ref.children;\\r\\n    var parent = ref.parent;\\r\\n    var data = ref.data;\\r\\n\\r\\n    // used by devtools to display a router-view badge\\r\\n    data.routerView = true;\\r\\n\\r\\n    // directly use parent context's createElement() function\\r\\n    // so that components rendered by router-view can resolve named slots\\r\\n    var h = parent.$createElement;\\r\\n    var name = props.name;\\r\\n    var route = parent.$route;\\r\\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\\r\\n\\r\\n    // determine current view depth, also check to see if the tree\\r\\n    // has been toggled inactive but kept-alive.\\r\\n    var depth = 0;\\r\\n    var inactive = false;\\r\\n    while (parent && parent._routerRoot !== parent) {\\r\\n      if (parent.$vnode && parent.$vnode.data.routerView) {\\r\\n        depth++;\\r\\n      }\\r\\n      if (parent._inactive) {\\r\\n        inactive = true;\\r\\n      }\\r\\n      parent = parent.$parent;\\r\\n    }\\r\\n    data.routerViewDepth = depth;\\r\\n\\r\\n    // render previous view if the tree is inactive and kept-alive\\r\\n    if (inactive) {\\r\\n      return h(cache[name], data, children)\\r\\n    }\\r\\n\\r\\n    var matched = route.matched[depth];\\r\\n    // render empty node if no matched route\\r\\n    if (!matched) {\\r\\n      cache[name] = null;\\r\\n      return h()\\r\\n    }\\r\\n\\r\\n    var component = cache[name] = matched.components[name];\\r\\n\\r\\n    // attach instance registration hook\\r\\n    // this will be called in the instance's injected lifecycle hooks\\r\\n    data.registerRouteInstance = function (vm, val) {\\r\\n      // val could be undefined for unregistration\\r\\n      var current = matched.instances[name];\\r\\n      if (\\r\\n        (val && current !== vm) ||\\r\\n        (!val && current === vm)\\r\\n      ) {\\r\\n        matched.instances[name] = val;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // also register instance in prepatch hook\\r\\n    // in case the same component instance is reused across different routes\\r\\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\\r\\n      matched.instances[name] = vnode.componentInstance;\\r\\n    };\\r\\n\\r\\n    // resolve props\\r\\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\\r\\n    if (propsToPass) {\\r\\n      // clone to prevent mutation\\r\\n      propsToPass = data.props = extend({}, propsToPass);\\r\\n      // pass non-declared props as attrs\\r\\n      var attrs = data.attrs = data.attrs || {};\\r\\n      for (var key in propsToPass) {\\r\\n        if (!component.props || !(key in component.props)) {\\r\\n          attrs[key] = propsToPass[key];\\r\\n          delete propsToPass[key];\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return h(component, data, children)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction resolveProps (route, config) {\\r\\n  switch (typeof config) {\\r\\n    case 'undefined':\\r\\n      return\\r\\n    case 'object':\\r\\n      return config\\r\\n    case 'function':\\r\\n      return config(route)\\r\\n    case 'boolean':\\r\\n      return config ? route.params : undefined\\r\\n    default:\\r\\n      if (false) {}\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar encodeReserveRE = /[!'()*]/g;\\r\\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\\r\\nvar commaRE = /%2C/g;\\r\\n\\r\\n// fixed encodeURIComponent which is more conformant to RFC3986:\\r\\n// - escapes [!'()*]\\r\\n// - preserve commas\\r\\nvar encode = function (str) { return encodeURIComponent(str)\\r\\n  .replace(encodeReserveRE, encodeReserveReplacer)\\r\\n  .replace(commaRE, ','); };\\r\\n\\r\\nvar decode = decodeURIComponent;\\r\\n\\r\\nfunction resolveQuery (\\r\\n  query,\\r\\n  extraQuery,\\r\\n  _parseQuery\\r\\n) {\\r\\n  if ( extraQuery === void 0 ) extraQuery = {};\\r\\n\\r\\n  var parse = _parseQuery || parseQuery;\\r\\n  var parsedQuery;\\r\\n  try {\\r\\n    parsedQuery = parse(query || '');\\r\\n  } catch (e) {\\r\\n    \\\"production\\\" !== 'production' && warn(false, e.message);\\r\\n    parsedQuery = {};\\r\\n  }\\r\\n  for (var key in extraQuery) {\\r\\n    parsedQuery[key] = extraQuery[key];\\r\\n  }\\r\\n  return parsedQuery\\r\\n}\\r\\n\\r\\nfunction parseQuery (query) {\\r\\n  var res = {};\\r\\n\\r\\n  query = query.trim().replace(/^(\\\\?|#|&)/, '');\\r\\n\\r\\n  if (!query) {\\r\\n    return res\\r\\n  }\\r\\n\\r\\n  query.split('&').forEach(function (param) {\\r\\n    var parts = param.replace(/\\\\+/g, ' ').split('=');\\r\\n    var key = decode(parts.shift());\\r\\n    var val = parts.length > 0\\r\\n      ? decode(parts.join('='))\\r\\n      : null;\\r\\n\\r\\n    if (res[key] === undefined) {\\r\\n      res[key] = val;\\r\\n    } else if (Array.isArray(res[key])) {\\r\\n      res[key].push(val);\\r\\n    } else {\\r\\n      res[key] = [res[key], val];\\r\\n    }\\r\\n  });\\r\\n\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction stringifyQuery (obj) {\\r\\n  var res = obj ? Object.keys(obj).map(function (key) {\\r\\n    var val = obj[key];\\r\\n\\r\\n    if (val === undefined) {\\r\\n      return ''\\r\\n    }\\r\\n\\r\\n    if (val === null) {\\r\\n      return encode(key)\\r\\n    }\\r\\n\\r\\n    if (Array.isArray(val)) {\\r\\n      var result = [];\\r\\n      val.forEach(function (val2) {\\r\\n        if (val2 === undefined) {\\r\\n          return\\r\\n        }\\r\\n        if (val2 === null) {\\r\\n          result.push(encode(key));\\r\\n        } else {\\r\\n          result.push(encode(key) + '=' + encode(val2));\\r\\n        }\\r\\n      });\\r\\n      return result.join('&')\\r\\n    }\\r\\n\\r\\n    return encode(key) + '=' + encode(val)\\r\\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\\r\\n  return res ? (\\\"?\\\" + res) : ''\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar trailingSlashRE = /\\\\/?$/;\\r\\n\\r\\nfunction createRoute (\\r\\n  record,\\r\\n  location,\\r\\n  redirectedFrom,\\r\\n  router\\r\\n) {\\r\\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\\r\\n\\r\\n  var query = location.query || {};\\r\\n  try {\\r\\n    query = clone(query);\\r\\n  } catch (e) {}\\r\\n\\r\\n  var route = {\\r\\n    name: location.name || (record && record.name),\\r\\n    meta: (record && record.meta) || {},\\r\\n    path: location.path || '/',\\r\\n    hash: location.hash || '',\\r\\n    query: query,\\r\\n    params: location.params || {},\\r\\n    fullPath: getFullPath(location, stringifyQuery$$1),\\r\\n    matched: record ? formatMatch(record) : []\\r\\n  };\\r\\n  if (redirectedFrom) {\\r\\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\\r\\n  }\\r\\n  return Object.freeze(route)\\r\\n}\\r\\n\\r\\nfunction clone (value) {\\r\\n  if (Array.isArray(value)) {\\r\\n    return value.map(clone)\\r\\n  } else if (value && typeof value === 'object') {\\r\\n    var res = {};\\r\\n    for (var key in value) {\\r\\n      res[key] = clone(value[key]);\\r\\n    }\\r\\n    return res\\r\\n  } else {\\r\\n    return value\\r\\n  }\\r\\n}\\r\\n\\r\\n// the starting route that represents the initial state\\r\\nvar START = createRoute(null, {\\r\\n  path: '/'\\r\\n});\\r\\n\\r\\nfunction formatMatch (record) {\\r\\n  var res = [];\\r\\n  while (record) {\\r\\n    res.unshift(record);\\r\\n    record = record.parent;\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction getFullPath (\\r\\n  ref,\\r\\n  _stringifyQuery\\r\\n) {\\r\\n  var path = ref.path;\\r\\n  var query = ref.query; if ( query === void 0 ) query = {};\\r\\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\\r\\n\\r\\n  var stringify = _stringifyQuery || stringifyQuery;\\r\\n  return (path || '/') + stringify(query) + hash\\r\\n}\\r\\n\\r\\nfunction isSameRoute (a, b) {\\r\\n  if (b === START) {\\r\\n    return a === b\\r\\n  } else if (!b) {\\r\\n    return false\\r\\n  } else if (a.path && b.path) {\\r\\n    return (\\r\\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\\r\\n      a.hash === b.hash &&\\r\\n      isObjectEqual(a.query, b.query)\\r\\n    )\\r\\n  } else if (a.name && b.name) {\\r\\n    return (\\r\\n      a.name === b.name &&\\r\\n      a.hash === b.hash &&\\r\\n      isObjectEqual(a.query, b.query) &&\\r\\n      isObjectEqual(a.params, b.params)\\r\\n    )\\r\\n  } else {\\r\\n    return false\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isObjectEqual (a, b) {\\r\\n  if ( a === void 0 ) a = {};\\r\\n  if ( b === void 0 ) b = {};\\r\\n\\r\\n  // handle null value #1566\\r\\n  if (!a || !b) { return a === b }\\r\\n  var aKeys = Object.keys(a);\\r\\n  var bKeys = Object.keys(b);\\r\\n  if (aKeys.length !== bKeys.length) {\\r\\n    return false\\r\\n  }\\r\\n  return aKeys.every(function (key) {\\r\\n    var aVal = a[key];\\r\\n    var bVal = b[key];\\r\\n    // check nested equality\\r\\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\\r\\n      return isObjectEqual(aVal, bVal)\\r\\n    }\\r\\n    return String(aVal) === String(bVal)\\r\\n  })\\r\\n}\\r\\n\\r\\nfunction isIncludedRoute (current, target) {\\r\\n  return (\\r\\n    current.path.replace(trailingSlashRE, '/').indexOf(\\r\\n      target.path.replace(trailingSlashRE, '/')\\r\\n    ) === 0 &&\\r\\n    (!target.hash || current.hash === target.hash) &&\\r\\n    queryIncludes(current.query, target.query)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction queryIncludes (current, target) {\\r\\n  for (var key in target) {\\r\\n    if (!(key in current)) {\\r\\n      return false\\r\\n    }\\r\\n  }\\r\\n  return true\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n// work around weird flow bug\\r\\nvar toTypes = [String, Object];\\r\\nvar eventTypes = [String, Array];\\r\\n\\r\\nvar Link = {\\r\\n  name: 'RouterLink',\\r\\n  props: {\\r\\n    to: {\\r\\n      type: toTypes,\\r\\n      required: true\\r\\n    },\\r\\n    tag: {\\r\\n      type: String,\\r\\n      default: 'a'\\r\\n    },\\r\\n    exact: Boolean,\\r\\n    append: Boolean,\\r\\n    replace: Boolean,\\r\\n    activeClass: String,\\r\\n    exactActiveClass: String,\\r\\n    event: {\\r\\n      type: eventTypes,\\r\\n      default: 'click'\\r\\n    }\\r\\n  },\\r\\n  render: function render (h) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var router = this.$router;\\r\\n    var current = this.$route;\\r\\n    var ref = router.resolve(this.to, current, this.append);\\r\\n    var location = ref.location;\\r\\n    var route = ref.route;\\r\\n    var href = ref.href;\\r\\n\\r\\n    var classes = {};\\r\\n    var globalActiveClass = router.options.linkActiveClass;\\r\\n    var globalExactActiveClass = router.options.linkExactActiveClass;\\r\\n    // Support global empty active class\\r\\n    var activeClassFallback = globalActiveClass == null\\r\\n      ? 'router-link-active'\\r\\n      : globalActiveClass;\\r\\n    var exactActiveClassFallback = globalExactActiveClass == null\\r\\n      ? 'router-link-exact-active'\\r\\n      : globalExactActiveClass;\\r\\n    var activeClass = this.activeClass == null\\r\\n      ? activeClassFallback\\r\\n      : this.activeClass;\\r\\n    var exactActiveClass = this.exactActiveClass == null\\r\\n      ? exactActiveClassFallback\\r\\n      : this.exactActiveClass;\\r\\n    var compareTarget = location.path\\r\\n      ? createRoute(null, location, null, router)\\r\\n      : route;\\r\\n\\r\\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\\r\\n    classes[activeClass] = this.exact\\r\\n      ? classes[exactActiveClass]\\r\\n      : isIncludedRoute(current, compareTarget);\\r\\n\\r\\n    var handler = function (e) {\\r\\n      if (guardEvent(e)) {\\r\\n        if (this$1.replace) {\\r\\n          router.replace(location);\\r\\n        } else {\\r\\n          router.push(location);\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n\\r\\n    var on = { click: guardEvent };\\r\\n    if (Array.isArray(this.event)) {\\r\\n      this.event.forEach(function (e) { on[e] = handler; });\\r\\n    } else {\\r\\n      on[this.event] = handler;\\r\\n    }\\r\\n\\r\\n    var data = {\\r\\n      class: classes\\r\\n    };\\r\\n\\r\\n    if (this.tag === 'a') {\\r\\n      data.on = on;\\r\\n      data.attrs = { href: href };\\r\\n    } else {\\r\\n      // find the first <a> child and apply listener and href\\r\\n      var a = findAnchor(this.$slots.default);\\r\\n      if (a) {\\r\\n        // in case the <a> is a static node\\r\\n        a.isStatic = false;\\r\\n        var aData = a.data = extend({}, a.data);\\r\\n        aData.on = on;\\r\\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\\r\\n        aAttrs.href = href;\\r\\n      } else {\\r\\n        // doesn't have <a> child, apply listener to self\\r\\n        data.on = on;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return h(this.tag, data, this.$slots.default)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction guardEvent (e) {\\r\\n  // don't redirect with control keys\\r\\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\\r\\n  // don't redirect when preventDefault called\\r\\n  if (e.defaultPrevented) { return }\\r\\n  // don't redirect on right click\\r\\n  if (e.button !== undefined && e.button !== 0) { return }\\r\\n  // don't redirect if `target=\\\"_blank\\\"`\\r\\n  if (e.currentTarget && e.currentTarget.getAttribute) {\\r\\n    var target = e.currentTarget.getAttribute('target');\\r\\n    if (/\\\\b_blank\\\\b/i.test(target)) { return }\\r\\n  }\\r\\n  // this may be a Weex event which doesn't have this method\\r\\n  if (e.preventDefault) {\\r\\n    e.preventDefault();\\r\\n  }\\r\\n  return true\\r\\n}\\r\\n\\r\\nfunction findAnchor (children) {\\r\\n  if (children) {\\r\\n    var child;\\r\\n    for (var i = 0; i < children.length; i++) {\\r\\n      child = children[i];\\r\\n      if (child.tag === 'a') {\\r\\n        return child\\r\\n      }\\r\\n      if (child.children && (child = findAnchor(child.children))) {\\r\\n        return child\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvar _Vue;\\r\\n\\r\\nfunction install (Vue) {\\r\\n  if (install.installed && _Vue === Vue) { return }\\r\\n  install.installed = true;\\r\\n\\r\\n  _Vue = Vue;\\r\\n\\r\\n  var isDef = function (v) { return v !== undefined; };\\r\\n\\r\\n  var registerInstance = function (vm, callVal) {\\r\\n    var i = vm.$options._parentVnode;\\r\\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\\r\\n      i(vm, callVal);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Vue.mixin({\\r\\n    beforeCreate: function beforeCreate () {\\r\\n      if (isDef(this.$options.router)) {\\r\\n        this._routerRoot = this;\\r\\n        this._router = this.$options.router;\\r\\n        this._router.init(this);\\r\\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\\r\\n      } else {\\r\\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\\r\\n      }\\r\\n      registerInstance(this, this);\\r\\n    },\\r\\n    destroyed: function destroyed () {\\r\\n      registerInstance(this);\\r\\n    }\\r\\n  });\\r\\n\\r\\n  Object.defineProperty(Vue.prototype, '$router', {\\r\\n    get: function get () { return this._routerRoot._router }\\r\\n  });\\r\\n\\r\\n  Object.defineProperty(Vue.prototype, '$route', {\\r\\n    get: function get () { return this._routerRoot._route }\\r\\n  });\\r\\n\\r\\n  Vue.component('RouterView', View);\\r\\n  Vue.component('RouterLink', Link);\\r\\n\\r\\n  var strats = Vue.config.optionMergeStrategies;\\r\\n  // use the same hook merging strategy for route hooks\\r\\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar inBrowser = typeof window !== 'undefined';\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction resolvePath (\\r\\n  relative,\\r\\n  base,\\r\\n  append\\r\\n) {\\r\\n  var firstChar = relative.charAt(0);\\r\\n  if (firstChar === '/') {\\r\\n    return relative\\r\\n  }\\r\\n\\r\\n  if (firstChar === '?' || firstChar === '#') {\\r\\n    return base + relative\\r\\n  }\\r\\n\\r\\n  var stack = base.split('/');\\r\\n\\r\\n  // remove trailing segment if:\\r\\n  // - not appending\\r\\n  // - appending to trailing slash (last segment is empty)\\r\\n  if (!append || !stack[stack.length - 1]) {\\r\\n    stack.pop();\\r\\n  }\\r\\n\\r\\n  // resolve relative path\\r\\n  var segments = relative.replace(/^\\\\//, '').split('/');\\r\\n  for (var i = 0; i < segments.length; i++) {\\r\\n    var segment = segments[i];\\r\\n    if (segment === '..') {\\r\\n      stack.pop();\\r\\n    } else if (segment !== '.') {\\r\\n      stack.push(segment);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // ensure leading slash\\r\\n  if (stack[0] !== '') {\\r\\n    stack.unshift('');\\r\\n  }\\r\\n\\r\\n  return stack.join('/')\\r\\n}\\r\\n\\r\\nfunction parsePath (path) {\\r\\n  var hash = '';\\r\\n  var query = '';\\r\\n\\r\\n  var hashIndex = path.indexOf('#');\\r\\n  if (hashIndex >= 0) {\\r\\n    hash = path.slice(hashIndex);\\r\\n    path = path.slice(0, hashIndex);\\r\\n  }\\r\\n\\r\\n  var queryIndex = path.indexOf('?');\\r\\n  if (queryIndex >= 0) {\\r\\n    query = path.slice(queryIndex + 1);\\r\\n    path = path.slice(0, queryIndex);\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    path: path,\\r\\n    query: query,\\r\\n    hash: hash\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction cleanPath (path) {\\r\\n  return path.replace(/\\\\/\\\\//g, '/')\\r\\n}\\r\\n\\r\\nvar isarray = Array.isArray || function (arr) {\\r\\n  return Object.prototype.toString.call(arr) == '[object Array]';\\r\\n};\\r\\n\\r\\n/**\\r\\n * Expose `pathToRegexp`.\\r\\n */\\r\\nvar pathToRegexp_1 = pathToRegexp;\\r\\nvar parse_1 = parse;\\r\\nvar compile_1 = compile;\\r\\nvar tokensToFunction_1 = tokensToFunction;\\r\\nvar tokensToRegExp_1 = tokensToRegExp;\\r\\n\\r\\n/**\\r\\n * The main path matching regexp utility.\\r\\n *\\r\\n * @type {RegExp}\\r\\n */\\r\\nvar PATH_REGEXP = new RegExp([\\r\\n  // Match escaped characters that would otherwise appear in future matches.\\r\\n  // This allows the user to escape special characters that won't transform.\\r\\n  '(\\\\\\\\\\\\\\\\.)',\\r\\n  // Match Express-style parameters and un-named parameters with a prefix\\r\\n  // and optional suffixes. Matches appear as:\\r\\n  //\\r\\n  // \\\"/:test(\\\\\\\\d+)?\\\" => [\\\"/\\\", \\\"test\\\", \\\"\\\\d+\\\", undefined, \\\"?\\\", undefined]\\r\\n  // \\\"/route(\\\\\\\\d+)\\\"  => [undefined, undefined, undefined, \\\"\\\\d+\\\", undefined, undefined]\\r\\n  // \\\"/*\\\"            => [\\\"/\\\", undefined, undefined, undefined, undefined, \\\"*\\\"]\\r\\n  '([\\\\\\\\/.])?(?:(?:\\\\\\\\:(\\\\\\\\w+)(?:\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()])+)\\\\\\\\))?|\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()])+)\\\\\\\\))([+*?])?|(\\\\\\\\*))'\\r\\n].join('|'), 'g');\\r\\n\\r\\n/**\\r\\n * Parse a string for the raw tokens.\\r\\n *\\r\\n * @param  {string}  str\\r\\n * @param  {Object=} options\\r\\n * @return {!Array}\\r\\n */\\r\\nfunction parse (str, options) {\\r\\n  var tokens = [];\\r\\n  var key = 0;\\r\\n  var index = 0;\\r\\n  var path = '';\\r\\n  var defaultDelimiter = options && options.delimiter || '/';\\r\\n  var res;\\r\\n\\r\\n  while ((res = PATH_REGEXP.exec(str)) != null) {\\r\\n    var m = res[0];\\r\\n    var escaped = res[1];\\r\\n    var offset = res.index;\\r\\n    path += str.slice(index, offset);\\r\\n    index = offset + m.length;\\r\\n\\r\\n    // Ignore already escaped sequences.\\r\\n    if (escaped) {\\r\\n      path += escaped[1];\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    var next = str[index];\\r\\n    var prefix = res[2];\\r\\n    var name = res[3];\\r\\n    var capture = res[4];\\r\\n    var group = res[5];\\r\\n    var modifier = res[6];\\r\\n    var asterisk = res[7];\\r\\n\\r\\n    // Push the current path onto the tokens.\\r\\n    if (path) {\\r\\n      tokens.push(path);\\r\\n      path = '';\\r\\n    }\\r\\n\\r\\n    var partial = prefix != null && next != null && next !== prefix;\\r\\n    var repeat = modifier === '+' || modifier === '*';\\r\\n    var optional = modifier === '?' || modifier === '*';\\r\\n    var delimiter = res[2] || defaultDelimiter;\\r\\n    var pattern = capture || group;\\r\\n\\r\\n    tokens.push({\\r\\n      name: name || key++,\\r\\n      prefix: prefix || '',\\r\\n      delimiter: delimiter,\\r\\n      optional: optional,\\r\\n      repeat: repeat,\\r\\n      partial: partial,\\r\\n      asterisk: !!asterisk,\\r\\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // Match any characters still remaining.\\r\\n  if (index < str.length) {\\r\\n    path += str.substr(index);\\r\\n  }\\r\\n\\r\\n  // If the path exists, push it onto the end.\\r\\n  if (path) {\\r\\n    tokens.push(path);\\r\\n  }\\r\\n\\r\\n  return tokens\\r\\n}\\r\\n\\r\\n/**\\r\\n * Compile a string to a template function for the path.\\r\\n *\\r\\n * @param  {string}             str\\r\\n * @param  {Object=}            options\\r\\n * @return {!function(Object=, Object=)}\\r\\n */\\r\\nfunction compile (str, options) {\\r\\n  return tokensToFunction(parse(str, options))\\r\\n}\\r\\n\\r\\n/**\\r\\n * Prettier encoding of URI path segments.\\r\\n *\\r\\n * @param  {string}\\r\\n * @return {string}\\r\\n */\\r\\nfunction encodeURIComponentPretty (str) {\\r\\n  return encodeURI(str).replace(/[\\\\/?#]/g, function (c) {\\r\\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\\r\\n *\\r\\n * @param  {string}\\r\\n * @return {string}\\r\\n */\\r\\nfunction encodeAsterisk (str) {\\r\\n  return encodeURI(str).replace(/[?#]/g, function (c) {\\r\\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * Expose a method for transforming tokens into the path function.\\r\\n */\\r\\nfunction tokensToFunction (tokens) {\\r\\n  // Compile all the tokens into regexps.\\r\\n  var matches = new Array(tokens.length);\\r\\n\\r\\n  // Compile all the patterns before compilation.\\r\\n  for (var i = 0; i < tokens.length; i++) {\\r\\n    if (typeof tokens[i] === 'object') {\\r\\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return function (obj, opts) {\\r\\n    var path = '';\\r\\n    var data = obj || {};\\r\\n    var options = opts || {};\\r\\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\\r\\n\\r\\n    for (var i = 0; i < tokens.length; i++) {\\r\\n      var token = tokens[i];\\r\\n\\r\\n      if (typeof token === 'string') {\\r\\n        path += token;\\r\\n\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      var value = data[token.name];\\r\\n      var segment;\\r\\n\\r\\n      if (value == null) {\\r\\n        if (token.optional) {\\r\\n          // Prepend partial segment prefixes.\\r\\n          if (token.partial) {\\r\\n            path += token.prefix;\\r\\n          }\\r\\n\\r\\n          continue\\r\\n        } else {\\r\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to be defined')\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (isarray(value)) {\\r\\n        if (!token.repeat) {\\r\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to not repeat, but received `' + JSON.stringify(value) + '`')\\r\\n        }\\r\\n\\r\\n        if (value.length === 0) {\\r\\n          if (token.optional) {\\r\\n            continue\\r\\n          } else {\\r\\n            throw new TypeError('Expected \\\"' + token.name + '\\\" to not be empty')\\r\\n          }\\r\\n        }\\r\\n\\r\\n        for (var j = 0; j < value.length; j++) {\\r\\n          segment = encode(value[j]);\\r\\n\\r\\n          if (!matches[i].test(segment)) {\\r\\n            throw new TypeError('Expected all \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received `' + JSON.stringify(segment) + '`')\\r\\n          }\\r\\n\\r\\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\\r\\n        }\\r\\n\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\\r\\n\\r\\n      if (!matches[i].test(segment)) {\\r\\n        throw new TypeError('Expected \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received \\\"' + segment + '\\\"')\\r\\n      }\\r\\n\\r\\n      path += token.prefix + segment;\\r\\n    }\\r\\n\\r\\n    return path\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Escape a regular expression string.\\r\\n *\\r\\n * @param  {string} str\\r\\n * @return {string}\\r\\n */\\r\\nfunction escapeString (str) {\\r\\n  return str.replace(/([.+*?=^!:${}()[\\\\]|\\\\/\\\\\\\\])/g, '\\\\\\\\$1')\\r\\n}\\r\\n\\r\\n/**\\r\\n * Escape the capturing group by escaping special characters and meaning.\\r\\n *\\r\\n * @param  {string} group\\r\\n * @return {string}\\r\\n */\\r\\nfunction escapeGroup (group) {\\r\\n  return group.replace(/([=!:$\\\\/()])/g, '\\\\\\\\$1')\\r\\n}\\r\\n\\r\\n/**\\r\\n * Attach the keys as a property of the regexp.\\r\\n *\\r\\n * @param  {!RegExp} re\\r\\n * @param  {Array}   keys\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction attachKeys (re, keys) {\\r\\n  re.keys = keys;\\r\\n  return re\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get the flags for a regexp from the options.\\r\\n *\\r\\n * @param  {Object} options\\r\\n * @return {string}\\r\\n */\\r\\nfunction flags (options) {\\r\\n  return options.sensitive ? '' : 'i'\\r\\n}\\r\\n\\r\\n/**\\r\\n * Pull out keys from a regexp.\\r\\n *\\r\\n * @param  {!RegExp} path\\r\\n * @param  {!Array}  keys\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction regexpToRegexp (path, keys) {\\r\\n  // Use a negative lookahead to match only capturing groups.\\r\\n  var groups = path.source.match(/\\\\((?!\\\\?)/g);\\r\\n\\r\\n  if (groups) {\\r\\n    for (var i = 0; i < groups.length; i++) {\\r\\n      keys.push({\\r\\n        name: i,\\r\\n        prefix: null,\\r\\n        delimiter: null,\\r\\n        optional: false,\\r\\n        repeat: false,\\r\\n        partial: false,\\r\\n        asterisk: false,\\r\\n        pattern: null\\r\\n      });\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return attachKeys(path, keys)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Transform an array into a regexp.\\r\\n *\\r\\n * @param  {!Array}  path\\r\\n * @param  {Array}   keys\\r\\n * @param  {!Object} options\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction arrayToRegexp (path, keys, options) {\\r\\n  var parts = [];\\r\\n\\r\\n  for (var i = 0; i < path.length; i++) {\\r\\n    parts.push(pathToRegexp(path[i], keys, options).source);\\r\\n  }\\r\\n\\r\\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\\r\\n\\r\\n  return attachKeys(regexp, keys)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Create a path regexp from string input.\\r\\n *\\r\\n * @param  {string}  path\\r\\n * @param  {!Array}  keys\\r\\n * @param  {!Object} options\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction stringToRegexp (path, keys, options) {\\r\\n  return tokensToRegExp(parse(path, options), keys, options)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Expose a function for taking tokens and returning a RegExp.\\r\\n *\\r\\n * @param  {!Array}          tokens\\r\\n * @param  {(Array|Object)=} keys\\r\\n * @param  {Object=}         options\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction tokensToRegExp (tokens, keys, options) {\\r\\n  if (!isarray(keys)) {\\r\\n    options = /** @type {!Object} */ (keys || options);\\r\\n    keys = [];\\r\\n  }\\r\\n\\r\\n  options = options || {};\\r\\n\\r\\n  var strict = options.strict;\\r\\n  var end = options.end !== false;\\r\\n  var route = '';\\r\\n\\r\\n  // Iterate over the tokens and create our regexp string.\\r\\n  for (var i = 0; i < tokens.length; i++) {\\r\\n    var token = tokens[i];\\r\\n\\r\\n    if (typeof token === 'string') {\\r\\n      route += escapeString(token);\\r\\n    } else {\\r\\n      var prefix = escapeString(token.prefix);\\r\\n      var capture = '(?:' + token.pattern + ')';\\r\\n\\r\\n      keys.push(token);\\r\\n\\r\\n      if (token.repeat) {\\r\\n        capture += '(?:' + prefix + capture + ')*';\\r\\n      }\\r\\n\\r\\n      if (token.optional) {\\r\\n        if (!token.partial) {\\r\\n          capture = '(?:' + prefix + '(' + capture + '))?';\\r\\n        } else {\\r\\n          capture = prefix + '(' + capture + ')?';\\r\\n        }\\r\\n      } else {\\r\\n        capture = prefix + '(' + capture + ')';\\r\\n      }\\r\\n\\r\\n      route += capture;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var delimiter = escapeString(options.delimiter || '/');\\r\\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\\r\\n\\r\\n  // In non-strict mode we allow a slash at the end of match. If the path to\\r\\n  // match already ends with a slash, we remove it for consistency. The slash\\r\\n  // is valid at the end of a path match, not in the middle. This is important\\r\\n  // in non-ending mode, where \\\"/test/\\\" shouldn't match \\\"/test//route\\\".\\r\\n  if (!strict) {\\r\\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\\r\\n  }\\r\\n\\r\\n  if (end) {\\r\\n    route += '$';\\r\\n  } else {\\r\\n    // In non-ending mode, we need the capturing groups to match as much as\\r\\n    // possible by using a positive lookahead to the end or next path segment.\\r\\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\\r\\n  }\\r\\n\\r\\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Normalize the given path string, returning a regular expression.\\r\\n *\\r\\n * An empty array can be passed in for the keys, which will hold the\\r\\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\\r\\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\\r\\n *\\r\\n * @param  {(string|RegExp|Array)} path\\r\\n * @param  {(Array|Object)=}       keys\\r\\n * @param  {Object=}               options\\r\\n * @return {!RegExp}\\r\\n */\\r\\nfunction pathToRegexp (path, keys, options) {\\r\\n  if (!isarray(keys)) {\\r\\n    options = /** @type {!Object} */ (keys || options);\\r\\n    keys = [];\\r\\n  }\\r\\n\\r\\n  options = options || {};\\r\\n\\r\\n  if (path instanceof RegExp) {\\r\\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\\r\\n  }\\r\\n\\r\\n  if (isarray(path)) {\\r\\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\\r\\n  }\\r\\n\\r\\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\\r\\n}\\r\\npathToRegexp_1.parse = parse_1;\\r\\npathToRegexp_1.compile = compile_1;\\r\\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\\r\\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\\r\\n\\r\\n/*  */\\r\\n\\r\\n// $flow-disable-line\\r\\nvar regexpCompileCache = Object.create(null);\\r\\n\\r\\nfunction fillParams (\\r\\n  path,\\r\\n  params,\\r\\n  routeMsg\\r\\n) {\\r\\n  try {\\r\\n    var filler =\\r\\n      regexpCompileCache[path] ||\\r\\n      (regexpCompileCache[path] = pathToRegexp_1.compile(path));\\r\\n    return filler(params || {}, { pretty: true })\\r\\n  } catch (e) {\\r\\n    if (false) {}\\r\\n    return ''\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction createRouteMap (\\r\\n  routes,\\r\\n  oldPathList,\\r\\n  oldPathMap,\\r\\n  oldNameMap\\r\\n) {\\r\\n  // the path list is used to control path matching priority\\r\\n  var pathList = oldPathList || [];\\r\\n  // $flow-disable-line\\r\\n  var pathMap = oldPathMap || Object.create(null);\\r\\n  // $flow-disable-line\\r\\n  var nameMap = oldNameMap || Object.create(null);\\r\\n\\r\\n  routes.forEach(function (route) {\\r\\n    addRouteRecord(pathList, pathMap, nameMap, route);\\r\\n  });\\r\\n\\r\\n  // ensure wildcard routes are always at the end\\r\\n  for (var i = 0, l = pathList.length; i < l; i++) {\\r\\n    if (pathList[i] === '*') {\\r\\n      pathList.push(pathList.splice(i, 1)[0]);\\r\\n      l--;\\r\\n      i--;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    pathList: pathList,\\r\\n    pathMap: pathMap,\\r\\n    nameMap: nameMap\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction addRouteRecord (\\r\\n  pathList,\\r\\n  pathMap,\\r\\n  nameMap,\\r\\n  route,\\r\\n  parent,\\r\\n  matchAs\\r\\n) {\\r\\n  var path = route.path;\\r\\n  var name = route.name;\\r\\n  if (false) {}\\r\\n\\r\\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\\r\\n  var normalizedPath = normalizePath(\\r\\n    path,\\r\\n    parent,\\r\\n    pathToRegexpOptions.strict\\r\\n  );\\r\\n\\r\\n  if (typeof route.caseSensitive === 'boolean') {\\r\\n    pathToRegexpOptions.sensitive = route.caseSensitive;\\r\\n  }\\r\\n\\r\\n  var record = {\\r\\n    path: normalizedPath,\\r\\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\\r\\n    components: route.components || { default: route.component },\\r\\n    instances: {},\\r\\n    name: name,\\r\\n    parent: parent,\\r\\n    matchAs: matchAs,\\r\\n    redirect: route.redirect,\\r\\n    beforeEnter: route.beforeEnter,\\r\\n    meta: route.meta || {},\\r\\n    props: route.props == null\\r\\n      ? {}\\r\\n      : route.components\\r\\n        ? route.props\\r\\n        : { default: route.props }\\r\\n  };\\r\\n\\r\\n  if (route.children) {\\r\\n    // Warn if route is named, does not redirect and has a default child route.\\r\\n    // If users navigate to this route by name, the default child will\\r\\n    // not be rendered (GH Issue #629)\\r\\n    if (false) {}\\r\\n    route.children.forEach(function (child) {\\r\\n      var childMatchAs = matchAs\\r\\n        ? cleanPath((matchAs + \\\"/\\\" + (child.path)))\\r\\n        : undefined;\\r\\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  if (route.alias !== undefined) {\\r\\n    var aliases = Array.isArray(route.alias)\\r\\n      ? route.alias\\r\\n      : [route.alias];\\r\\n\\r\\n    aliases.forEach(function (alias) {\\r\\n      var aliasRoute = {\\r\\n        path: alias,\\r\\n        children: route.children\\r\\n      };\\r\\n      addRouteRecord(\\r\\n        pathList,\\r\\n        pathMap,\\r\\n        nameMap,\\r\\n        aliasRoute,\\r\\n        parent,\\r\\n        record.path || '/' // matchAs\\r\\n      );\\r\\n    });\\r\\n  }\\r\\n\\r\\n  if (!pathMap[record.path]) {\\r\\n    pathList.push(record.path);\\r\\n    pathMap[record.path] = record;\\r\\n  }\\r\\n\\r\\n  if (name) {\\r\\n    if (!nameMap[name]) {\\r\\n      nameMap[name] = record;\\r\\n    } else if (false) {}\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction compileRouteRegex (path, pathToRegexpOptions) {\\r\\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\\r\\n  if (false) { var keys; }\\r\\n  return regex\\r\\n}\\r\\n\\r\\nfunction normalizePath (path, parent, strict) {\\r\\n  if (!strict) { path = path.replace(/\\\\/$/, ''); }\\r\\n  if (path[0] === '/') { return path }\\r\\n  if (parent == null) { return path }\\r\\n  return cleanPath(((parent.path) + \\\"/\\\" + path))\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction normalizeLocation (\\r\\n  raw,\\r\\n  current,\\r\\n  append,\\r\\n  router\\r\\n) {\\r\\n  var next = typeof raw === 'string' ? { path: raw } : raw;\\r\\n  // named target\\r\\n  if (next.name || next._normalized) {\\r\\n    return next\\r\\n  }\\r\\n\\r\\n  // relative params\\r\\n  if (!next.path && next.params && current) {\\r\\n    next = extend({}, next);\\r\\n    next._normalized = true;\\r\\n    var params = extend(extend({}, current.params), next.params);\\r\\n    if (current.name) {\\r\\n      next.name = current.name;\\r\\n      next.params = params;\\r\\n    } else if (current.matched.length) {\\r\\n      var rawPath = current.matched[current.matched.length - 1].path;\\r\\n      next.path = fillParams(rawPath, params, (\\\"path \\\" + (current.path)));\\r\\n    } else if (false) {}\\r\\n    return next\\r\\n  }\\r\\n\\r\\n  var parsedPath = parsePath(next.path || '');\\r\\n  var basePath = (current && current.path) || '/';\\r\\n  var path = parsedPath.path\\r\\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\\r\\n    : basePath;\\r\\n\\r\\n  var query = resolveQuery(\\r\\n    parsedPath.query,\\r\\n    next.query,\\r\\n    router && router.options.parseQuery\\r\\n  );\\r\\n\\r\\n  var hash = next.hash || parsedPath.hash;\\r\\n  if (hash && hash.charAt(0) !== '#') {\\r\\n    hash = \\\"#\\\" + hash;\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    _normalized: true,\\r\\n    path: path,\\r\\n    query: query,\\r\\n    hash: hash\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nfunction createMatcher (\\r\\n  routes,\\r\\n  router\\r\\n) {\\r\\n  var ref = createRouteMap(routes);\\r\\n  var pathList = ref.pathList;\\r\\n  var pathMap = ref.pathMap;\\r\\n  var nameMap = ref.nameMap;\\r\\n\\r\\n  function addRoutes (routes) {\\r\\n    createRouteMap(routes, pathList, pathMap, nameMap);\\r\\n  }\\r\\n\\r\\n  function match (\\r\\n    raw,\\r\\n    currentRoute,\\r\\n    redirectedFrom\\r\\n  ) {\\r\\n    var location = normalizeLocation(raw, currentRoute, false, router);\\r\\n    var name = location.name;\\r\\n\\r\\n    if (name) {\\r\\n      var record = nameMap[name];\\r\\n      if (false) {}\\r\\n      if (!record) { return _createRoute(null, location) }\\r\\n      var paramNames = record.regex.keys\\r\\n        .filter(function (key) { return !key.optional; })\\r\\n        .map(function (key) { return key.name; });\\r\\n\\r\\n      if (typeof location.params !== 'object') {\\r\\n        location.params = {};\\r\\n      }\\r\\n\\r\\n      if (currentRoute && typeof currentRoute.params === 'object') {\\r\\n        for (var key in currentRoute.params) {\\r\\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\\r\\n            location.params[key] = currentRoute.params[key];\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (record) {\\r\\n        location.path = fillParams(record.path, location.params, (\\\"named route \\\\\\\"\\\" + name + \\\"\\\\\\\"\\\"));\\r\\n        return _createRoute(record, location, redirectedFrom)\\r\\n      }\\r\\n    } else if (location.path) {\\r\\n      location.params = {};\\r\\n      for (var i = 0; i < pathList.length; i++) {\\r\\n        var path = pathList[i];\\r\\n        var record$1 = pathMap[path];\\r\\n        if (matchRoute(record$1.regex, location.path, location.params)) {\\r\\n          return _createRoute(record$1, location, redirectedFrom)\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    // no match\\r\\n    return _createRoute(null, location)\\r\\n  }\\r\\n\\r\\n  function redirect (\\r\\n    record,\\r\\n    location\\r\\n  ) {\\r\\n    var originalRedirect = record.redirect;\\r\\n    var redirect = typeof originalRedirect === 'function'\\r\\n      ? originalRedirect(createRoute(record, location, null, router))\\r\\n      : originalRedirect;\\r\\n\\r\\n    if (typeof redirect === 'string') {\\r\\n      redirect = { path: redirect };\\r\\n    }\\r\\n\\r\\n    if (!redirect || typeof redirect !== 'object') {\\r\\n      if (false) {}\\r\\n      return _createRoute(null, location)\\r\\n    }\\r\\n\\r\\n    var re = redirect;\\r\\n    var name = re.name;\\r\\n    var path = re.path;\\r\\n    var query = location.query;\\r\\n    var hash = location.hash;\\r\\n    var params = location.params;\\r\\n    query = re.hasOwnProperty('query') ? re.query : query;\\r\\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\\r\\n    params = re.hasOwnProperty('params') ? re.params : params;\\r\\n\\r\\n    if (name) {\\r\\n      // resolved named direct\\r\\n      var targetRecord = nameMap[name];\\r\\n      if (false) {}\\r\\n      return match({\\r\\n        _normalized: true,\\r\\n        name: name,\\r\\n        query: query,\\r\\n        hash: hash,\\r\\n        params: params\\r\\n      }, undefined, location)\\r\\n    } else if (path) {\\r\\n      // 1. resolve relative redirect\\r\\n      var rawPath = resolveRecordPath(path, record);\\r\\n      // 2. resolve params\\r\\n      var resolvedPath = fillParams(rawPath, params, (\\\"redirect route with path \\\\\\\"\\\" + rawPath + \\\"\\\\\\\"\\\"));\\r\\n      // 3. rematch with existing query and hash\\r\\n      return match({\\r\\n        _normalized: true,\\r\\n        path: resolvedPath,\\r\\n        query: query,\\r\\n        hash: hash\\r\\n      }, undefined, location)\\r\\n    } else {\\r\\n      if (false) {}\\r\\n      return _createRoute(null, location)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function alias (\\r\\n    record,\\r\\n    location,\\r\\n    matchAs\\r\\n  ) {\\r\\n    var aliasedPath = fillParams(matchAs, location.params, (\\\"aliased route with path \\\\\\\"\\\" + matchAs + \\\"\\\\\\\"\\\"));\\r\\n    var aliasedMatch = match({\\r\\n      _normalized: true,\\r\\n      path: aliasedPath\\r\\n    });\\r\\n    if (aliasedMatch) {\\r\\n      var matched = aliasedMatch.matched;\\r\\n      var aliasedRecord = matched[matched.length - 1];\\r\\n      location.params = aliasedMatch.params;\\r\\n      return _createRoute(aliasedRecord, location)\\r\\n    }\\r\\n    return _createRoute(null, location)\\r\\n  }\\r\\n\\r\\n  function _createRoute (\\r\\n    record,\\r\\n    location,\\r\\n    redirectedFrom\\r\\n  ) {\\r\\n    if (record && record.redirect) {\\r\\n      return redirect(record, redirectedFrom || location)\\r\\n    }\\r\\n    if (record && record.matchAs) {\\r\\n      return alias(record, location, record.matchAs)\\r\\n    }\\r\\n    return createRoute(record, location, redirectedFrom, router)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    match: match,\\r\\n    addRoutes: addRoutes\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction matchRoute (\\r\\n  regex,\\r\\n  path,\\r\\n  params\\r\\n) {\\r\\n  var m = path.match(regex);\\r\\n\\r\\n  if (!m) {\\r\\n    return false\\r\\n  } else if (!params) {\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  for (var i = 1, len = m.length; i < len; ++i) {\\r\\n    var key = regex.keys[i - 1];\\r\\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\\r\\n    if (key) {\\r\\n      // Fix #1994: using * with props: true generates a param named 0\\r\\n      params[key.name || 'pathMatch'] = val;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return true\\r\\n}\\r\\n\\r\\nfunction resolveRecordPath (path, record) {\\r\\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar positionStore = Object.create(null);\\r\\n\\r\\nfunction setupScroll () {\\r\\n  // Fix for #1585 for Firefox\\r\\n  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\\r\\n  window.history.replaceState({ key: getStateKey() }, '', window.location.href.replace(window.location.origin, ''));\\r\\n  window.addEventListener('popstate', function (e) {\\r\\n    saveScrollPosition();\\r\\n    if (e.state && e.state.key) {\\r\\n      setStateKey(e.state.key);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\nfunction handleScroll (\\r\\n  router,\\r\\n  to,\\r\\n  from,\\r\\n  isPop\\r\\n) {\\r\\n  if (!router.app) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  var behavior = router.options.scrollBehavior;\\r\\n  if (!behavior) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  if (false) {}\\r\\n\\r\\n  // wait until re-render finishes before scrolling\\r\\n  router.app.$nextTick(function () {\\r\\n    var position = getScrollPosition();\\r\\n    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);\\r\\n\\r\\n    if (!shouldScroll) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    if (typeof shouldScroll.then === 'function') {\\r\\n      shouldScroll.then(function (shouldScroll) {\\r\\n        scrollToPosition((shouldScroll), position);\\r\\n      }).catch(function (err) {\\r\\n        if (false) {}\\r\\n      });\\r\\n    } else {\\r\\n      scrollToPosition(shouldScroll, position);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\nfunction saveScrollPosition () {\\r\\n  var key = getStateKey();\\r\\n  if (key) {\\r\\n    positionStore[key] = {\\r\\n      x: window.pageXOffset,\\r\\n      y: window.pageYOffset\\r\\n    };\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getScrollPosition () {\\r\\n  var key = getStateKey();\\r\\n  if (key) {\\r\\n    return positionStore[key]\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getElementPosition (el, offset) {\\r\\n  var docEl = document.documentElement;\\r\\n  var docRect = docEl.getBoundingClientRect();\\r\\n  var elRect = el.getBoundingClientRect();\\r\\n  return {\\r\\n    x: elRect.left - docRect.left - offset.x,\\r\\n    y: elRect.top - docRect.top - offset.y\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isValidPosition (obj) {\\r\\n  return isNumber(obj.x) || isNumber(obj.y)\\r\\n}\\r\\n\\r\\nfunction normalizePosition (obj) {\\r\\n  return {\\r\\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\\r\\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction normalizeOffset (obj) {\\r\\n  return {\\r\\n    x: isNumber(obj.x) ? obj.x : 0,\\r\\n    y: isNumber(obj.y) ? obj.y : 0\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isNumber (v) {\\r\\n  return typeof v === 'number'\\r\\n}\\r\\n\\r\\nfunction scrollToPosition (shouldScroll, position) {\\r\\n  var isObject = typeof shouldScroll === 'object';\\r\\n  if (isObject && typeof shouldScroll.selector === 'string') {\\r\\n    var el = document.querySelector(shouldScroll.selector);\\r\\n    if (el) {\\r\\n      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\\r\\n      offset = normalizeOffset(offset);\\r\\n      position = getElementPosition(el, offset);\\r\\n    } else if (isValidPosition(shouldScroll)) {\\r\\n      position = normalizePosition(shouldScroll);\\r\\n    }\\r\\n  } else if (isObject && isValidPosition(shouldScroll)) {\\r\\n    position = normalizePosition(shouldScroll);\\r\\n  }\\r\\n\\r\\n  if (position) {\\r\\n    window.scrollTo(position.x, position.y);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar supportsPushState = inBrowser && (function () {\\r\\n  var ua = window.navigator.userAgent;\\r\\n\\r\\n  if (\\r\\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\\r\\n    ua.indexOf('Mobile Safari') !== -1 &&\\r\\n    ua.indexOf('Chrome') === -1 &&\\r\\n    ua.indexOf('Windows Phone') === -1\\r\\n  ) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  return window.history && 'pushState' in window.history\\r\\n})();\\r\\n\\r\\n// use User Timing api (if present) for more accurate key precision\\r\\nvar Time = inBrowser && window.performance && window.performance.now\\r\\n  ? window.performance\\r\\n  : Date;\\r\\n\\r\\nvar _key = genKey();\\r\\n\\r\\nfunction genKey () {\\r\\n  return Time.now().toFixed(3)\\r\\n}\\r\\n\\r\\nfunction getStateKey () {\\r\\n  return _key\\r\\n}\\r\\n\\r\\nfunction setStateKey (key) {\\r\\n  _key = key;\\r\\n}\\r\\n\\r\\nfunction pushState (url, replace) {\\r\\n  saveScrollPosition();\\r\\n  // try...catch the pushState call to get around Safari\\r\\n  // DOM Exception 18 where it limits to 100 pushState calls\\r\\n  var history = window.history;\\r\\n  try {\\r\\n    if (replace) {\\r\\n      history.replaceState({ key: _key }, '', url);\\r\\n    } else {\\r\\n      _key = genKey();\\r\\n      history.pushState({ key: _key }, '', url);\\r\\n    }\\r\\n  } catch (e) {\\r\\n    window.location[replace ? 'replace' : 'assign'](url);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction replaceState (url) {\\r\\n  pushState(url, true);\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction runQueue (queue, fn, cb) {\\r\\n  var step = function (index) {\\r\\n    if (index >= queue.length) {\\r\\n      cb();\\r\\n    } else {\\r\\n      if (queue[index]) {\\r\\n        fn(queue[index], function () {\\r\\n          step(index + 1);\\r\\n        });\\r\\n      } else {\\r\\n        step(index + 1);\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n  step(0);\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nfunction resolveAsyncComponents (matched) {\\r\\n  return function (to, from, next) {\\r\\n    var hasAsync = false;\\r\\n    var pending = 0;\\r\\n    var error = null;\\r\\n\\r\\n    flatMapComponents(matched, function (def, _, match, key) {\\r\\n      // if it's a function and doesn't have cid attached,\\r\\n      // assume it's an async component resolve function.\\r\\n      // we are not using Vue's default async resolving mechanism because\\r\\n      // we want to halt the navigation until the incoming component has been\\r\\n      // resolved.\\r\\n      if (typeof def === 'function' && def.cid === undefined) {\\r\\n        hasAsync = true;\\r\\n        pending++;\\r\\n\\r\\n        var resolve = once(function (resolvedDef) {\\r\\n          if (isESModule(resolvedDef)) {\\r\\n            resolvedDef = resolvedDef.default;\\r\\n          }\\r\\n          // save resolved on async factory in case it's used elsewhere\\r\\n          def.resolved = typeof resolvedDef === 'function'\\r\\n            ? resolvedDef\\r\\n            : _Vue.extend(resolvedDef);\\r\\n          match.components[key] = resolvedDef;\\r\\n          pending--;\\r\\n          if (pending <= 0) {\\r\\n            next();\\r\\n          }\\r\\n        });\\r\\n\\r\\n        var reject = once(function (reason) {\\r\\n          var msg = \\\"Failed to resolve async component \\\" + key + \\\": \\\" + reason;\\r\\n          \\\"production\\\" !== 'production' && warn(false, msg);\\r\\n          if (!error) {\\r\\n            error = isError(reason)\\r\\n              ? reason\\r\\n              : new Error(msg);\\r\\n            next(error);\\r\\n          }\\r\\n        });\\r\\n\\r\\n        var res;\\r\\n        try {\\r\\n          res = def(resolve, reject);\\r\\n        } catch (e) {\\r\\n          reject(e);\\r\\n        }\\r\\n        if (res) {\\r\\n          if (typeof res.then === 'function') {\\r\\n            res.then(resolve, reject);\\r\\n          } else {\\r\\n            // new syntax in Vue 2.3\\r\\n            var comp = res.component;\\r\\n            if (comp && typeof comp.then === 'function') {\\r\\n              comp.then(resolve, reject);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    });\\r\\n\\r\\n    if (!hasAsync) { next(); }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction flatMapComponents (\\r\\n  matched,\\r\\n  fn\\r\\n) {\\r\\n  return flatten(matched.map(function (m) {\\r\\n    return Object.keys(m.components).map(function (key) { return fn(\\r\\n      m.components[key],\\r\\n      m.instances[key],\\r\\n      m, key\\r\\n    ); })\\r\\n  }))\\r\\n}\\r\\n\\r\\nfunction flatten (arr) {\\r\\n  return Array.prototype.concat.apply([], arr)\\r\\n}\\r\\n\\r\\nvar hasSymbol =\\r\\n  typeof Symbol === 'function' &&\\r\\n  typeof Symbol.toStringTag === 'symbol';\\r\\n\\r\\nfunction isESModule (obj) {\\r\\n  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\\r\\n}\\r\\n\\r\\n// in Webpack 2, require.ensure now also returns a Promise\\r\\n// so the resolve/reject functions may get called an extra time\\r\\n// if the user uses an arrow function shorthand that happens to\\r\\n// return that Promise.\\r\\nfunction once (fn) {\\r\\n  var called = false;\\r\\n  return function () {\\r\\n    var args = [], len = arguments.length;\\r\\n    while ( len-- ) args[ len ] = arguments[ len ];\\r\\n\\r\\n    if (called) { return }\\r\\n    called = true;\\r\\n    return fn.apply(this, args)\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar History = function History (router, base) {\\r\\n  this.router = router;\\r\\n  this.base = normalizeBase(base);\\r\\n  // start with a route object that stands for \\\"nowhere\\\"\\r\\n  this.current = START;\\r\\n  this.pending = null;\\r\\n  this.ready = false;\\r\\n  this.readyCbs = [];\\r\\n  this.readyErrorCbs = [];\\r\\n  this.errorCbs = [];\\r\\n};\\r\\n\\r\\nHistory.prototype.listen = function listen (cb) {\\r\\n  this.cb = cb;\\r\\n};\\r\\n\\r\\nHistory.prototype.onReady = function onReady (cb, errorCb) {\\r\\n  if (this.ready) {\\r\\n    cb();\\r\\n  } else {\\r\\n    this.readyCbs.push(cb);\\r\\n    if (errorCb) {\\r\\n      this.readyErrorCbs.push(errorCb);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nHistory.prototype.onError = function onError (errorCb) {\\r\\n  this.errorCbs.push(errorCb);\\r\\n};\\r\\n\\r\\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n  var route = this.router.match(location, this.current);\\r\\n  this.confirmTransition(route, function () {\\r\\n    this$1.updateRoute(route);\\r\\n    onComplete && onComplete(route);\\r\\n    this$1.ensureURL();\\r\\n\\r\\n    // fire ready cbs once\\r\\n    if (!this$1.ready) {\\r\\n      this$1.ready = true;\\r\\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\\r\\n    }\\r\\n  }, function (err) {\\r\\n    if (onAbort) {\\r\\n      onAbort(err);\\r\\n    }\\r\\n    if (err && !this$1.ready) {\\r\\n      this$1.ready = true;\\r\\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n  var current = this.current;\\r\\n  var abort = function (err) {\\r\\n    if (isError(err)) {\\r\\n      if (this$1.errorCbs.length) {\\r\\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\\r\\n      } else {\\r\\n        warn(false, 'uncaught error during route navigation:');\\r\\n        console.error(err);\\r\\n      }\\r\\n    }\\r\\n    onAbort && onAbort(err);\\r\\n  };\\r\\n  if (\\r\\n    isSameRoute(route, current) &&\\r\\n    // in the case the route map has been dynamically appended to\\r\\n    route.matched.length === current.matched.length\\r\\n  ) {\\r\\n    this.ensureURL();\\r\\n    return abort()\\r\\n  }\\r\\n\\r\\n  var ref = resolveQueue(this.current.matched, route.matched);\\r\\n    var updated = ref.updated;\\r\\n    var deactivated = ref.deactivated;\\r\\n    var activated = ref.activated;\\r\\n\\r\\n  var queue = [].concat(\\r\\n    // in-component leave guards\\r\\n    extractLeaveGuards(deactivated),\\r\\n    // global before hooks\\r\\n    this.router.beforeHooks,\\r\\n    // in-component update hooks\\r\\n    extractUpdateHooks(updated),\\r\\n    // in-config enter guards\\r\\n    activated.map(function (m) { return m.beforeEnter; }),\\r\\n    // async components\\r\\n    resolveAsyncComponents(activated)\\r\\n  );\\r\\n\\r\\n  this.pending = route;\\r\\n  var iterator = function (hook, next) {\\r\\n    if (this$1.pending !== route) {\\r\\n      return abort()\\r\\n    }\\r\\n    try {\\r\\n      hook(route, current, function (to) {\\r\\n        if (to === false || isError(to)) {\\r\\n          // next(false) -> abort navigation, ensure current URL\\r\\n          this$1.ensureURL(true);\\r\\n          abort(to);\\r\\n        } else if (\\r\\n          typeof to === 'string' ||\\r\\n          (typeof to === 'object' && (\\r\\n            typeof to.path === 'string' ||\\r\\n            typeof to.name === 'string'\\r\\n          ))\\r\\n        ) {\\r\\n          // next('/') or next({ path: '/' }) -> redirect\\r\\n          abort();\\r\\n          if (typeof to === 'object' && to.replace) {\\r\\n            this$1.replace(to);\\r\\n          } else {\\r\\n            this$1.push(to);\\r\\n          }\\r\\n        } else {\\r\\n          // confirm transition and pass on the value\\r\\n          next(to);\\r\\n        }\\r\\n      });\\r\\n    } catch (e) {\\r\\n      abort(e);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  runQueue(queue, iterator, function () {\\r\\n    var postEnterCbs = [];\\r\\n    var isValid = function () { return this$1.current === route; };\\r\\n    // wait until async components are resolved before\\r\\n    // extracting in-component enter guards\\r\\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\\r\\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\\r\\n    runQueue(queue, iterator, function () {\\r\\n      if (this$1.pending !== route) {\\r\\n        return abort()\\r\\n      }\\r\\n      this$1.pending = null;\\r\\n      onComplete(route);\\r\\n      if (this$1.router.app) {\\r\\n        this$1.router.app.$nextTick(function () {\\r\\n          postEnterCbs.forEach(function (cb) { cb(); });\\r\\n        });\\r\\n      }\\r\\n    });\\r\\n  });\\r\\n};\\r\\n\\r\\nHistory.prototype.updateRoute = function updateRoute (route) {\\r\\n  var prev = this.current;\\r\\n  this.current = route;\\r\\n  this.cb && this.cb(route);\\r\\n  this.router.afterHooks.forEach(function (hook) {\\r\\n    hook && hook(route, prev);\\r\\n  });\\r\\n};\\r\\n\\r\\nfunction normalizeBase (base) {\\r\\n  if (!base) {\\r\\n    if (inBrowser) {\\r\\n      // respect <base> tag\\r\\n      var baseEl = document.querySelector('base');\\r\\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\\r\\n      // strip full URL origin\\r\\n      base = base.replace(/^https?:\\\\/\\\\/[^\\\\/]+/, '');\\r\\n    } else {\\r\\n      base = '/';\\r\\n    }\\r\\n  }\\r\\n  // make sure there's the starting slash\\r\\n  if (base.charAt(0) !== '/') {\\r\\n    base = '/' + base;\\r\\n  }\\r\\n  // remove trailing slash\\r\\n  return base.replace(/\\\\/$/, '')\\r\\n}\\r\\n\\r\\nfunction resolveQueue (\\r\\n  current,\\r\\n  next\\r\\n) {\\r\\n  var i;\\r\\n  var max = Math.max(current.length, next.length);\\r\\n  for (i = 0; i < max; i++) {\\r\\n    if (current[i] !== next[i]) {\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n  return {\\r\\n    updated: next.slice(0, i),\\r\\n    activated: next.slice(i),\\r\\n    deactivated: current.slice(i)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction extractGuards (\\r\\n  records,\\r\\n  name,\\r\\n  bind,\\r\\n  reverse\\r\\n) {\\r\\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\\r\\n    var guard = extractGuard(def, name);\\r\\n    if (guard) {\\r\\n      return Array.isArray(guard)\\r\\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\\r\\n        : bind(guard, instance, match, key)\\r\\n    }\\r\\n  });\\r\\n  return flatten(reverse ? guards.reverse() : guards)\\r\\n}\\r\\n\\r\\nfunction extractGuard (\\r\\n  def,\\r\\n  key\\r\\n) {\\r\\n  if (typeof def !== 'function') {\\r\\n    // extend now so that global mixins are applied.\\r\\n    def = _Vue.extend(def);\\r\\n  }\\r\\n  return def.options[key]\\r\\n}\\r\\n\\r\\nfunction extractLeaveGuards (deactivated) {\\r\\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\\r\\n}\\r\\n\\r\\nfunction extractUpdateHooks (updated) {\\r\\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\\r\\n}\\r\\n\\r\\nfunction bindGuard (guard, instance) {\\r\\n  if (instance) {\\r\\n    return function boundRouteGuard () {\\r\\n      return guard.apply(instance, arguments)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction extractEnterGuards (\\r\\n  activated,\\r\\n  cbs,\\r\\n  isValid\\r\\n) {\\r\\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\\r\\n    return bindEnterGuard(guard, match, key, cbs, isValid)\\r\\n  })\\r\\n}\\r\\n\\r\\nfunction bindEnterGuard (\\r\\n  guard,\\r\\n  match,\\r\\n  key,\\r\\n  cbs,\\r\\n  isValid\\r\\n) {\\r\\n  return function routeEnterGuard (to, from, next) {\\r\\n    return guard(to, from, function (cb) {\\r\\n      next(cb);\\r\\n      if (typeof cb === 'function') {\\r\\n        cbs.push(function () {\\r\\n          // #750\\r\\n          // if a router-view is wrapped with an out-in transition,\\r\\n          // the instance may not have been registered at this time.\\r\\n          // we will need to poll for registration until current route\\r\\n          // is no longer valid.\\r\\n          poll(cb, match.instances, key, isValid);\\r\\n        });\\r\\n      }\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction poll (\\r\\n  cb, // somehow flow cannot infer this is a function\\r\\n  instances,\\r\\n  key,\\r\\n  isValid\\r\\n) {\\r\\n  if (\\r\\n    instances[key] &&\\r\\n    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\\r\\n  ) {\\r\\n    cb(instances[key]);\\r\\n  } else if (isValid()) {\\r\\n    setTimeout(function () {\\r\\n      poll(cb, instances, key, isValid);\\r\\n    }, 16);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar HTML5History = (function (History$$1) {\\r\\n  function HTML5History (router, base) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    History$$1.call(this, router, base);\\r\\n\\r\\n    var expectScroll = router.options.scrollBehavior;\\r\\n    var supportsScroll = supportsPushState && expectScroll;\\r\\n\\r\\n    if (supportsScroll) {\\r\\n      setupScroll();\\r\\n    }\\r\\n\\r\\n    var initLocation = getLocation(this.base);\\r\\n    window.addEventListener('popstate', function (e) {\\r\\n      var current = this$1.current;\\r\\n\\r\\n      // Avoiding first `popstate` event dispatched in some browsers but first\\r\\n      // history route not updated since async guard at the same time.\\r\\n      var location = getLocation(this$1.base);\\r\\n      if (this$1.current === START && location === initLocation) {\\r\\n        return\\r\\n      }\\r\\n\\r\\n      this$1.transitionTo(location, function (route) {\\r\\n        if (supportsScroll) {\\r\\n          handleScroll(router, route, current, true);\\r\\n        }\\r\\n      });\\r\\n    });\\r\\n  }\\r\\n\\r\\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\\r\\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\\r\\n  HTML5History.prototype.constructor = HTML5History;\\r\\n\\r\\n  HTML5History.prototype.go = function go (n) {\\r\\n    window.history.go(n);\\r\\n  };\\r\\n\\r\\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var ref = this;\\r\\n    var fromRoute = ref.current;\\r\\n    this.transitionTo(location, function (route) {\\r\\n      pushState(cleanPath(this$1.base + route.fullPath));\\r\\n      handleScroll(this$1.router, route, fromRoute, false);\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var ref = this;\\r\\n    var fromRoute = ref.current;\\r\\n    this.transitionTo(location, function (route) {\\r\\n      replaceState(cleanPath(this$1.base + route.fullPath));\\r\\n      handleScroll(this$1.router, route, fromRoute, false);\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\\r\\n    if (getLocation(this.base) !== this.current.fullPath) {\\r\\n      var current = cleanPath(this.base + this.current.fullPath);\\r\\n      push ? pushState(current) : replaceState(current);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\\r\\n    return getLocation(this.base)\\r\\n  };\\r\\n\\r\\n  return HTML5History;\\r\\n}(History));\\r\\n\\r\\nfunction getLocation (base) {\\r\\n  var path = decodeURI(window.location.pathname);\\r\\n  if (base && path.indexOf(base) === 0) {\\r\\n    path = path.slice(base.length);\\r\\n  }\\r\\n  return (path || '/') + window.location.search + window.location.hash\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar HashHistory = (function (History$$1) {\\r\\n  function HashHistory (router, base, fallback) {\\r\\n    History$$1.call(this, router, base);\\r\\n    // check history fallback deeplinking\\r\\n    if (fallback && checkFallback(this.base)) {\\r\\n      return\\r\\n    }\\r\\n    ensureSlash();\\r\\n  }\\r\\n\\r\\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\\r\\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\\r\\n  HashHistory.prototype.constructor = HashHistory;\\r\\n\\r\\n  // this is delayed until the app mounts\\r\\n  // to avoid the hashchange listener being fired too early\\r\\n  HashHistory.prototype.setupListeners = function setupListeners () {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var router = this.router;\\r\\n    var expectScroll = router.options.scrollBehavior;\\r\\n    var supportsScroll = supportsPushState && expectScroll;\\r\\n\\r\\n    if (supportsScroll) {\\r\\n      setupScroll();\\r\\n    }\\r\\n\\r\\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\\r\\n      var current = this$1.current;\\r\\n      if (!ensureSlash()) {\\r\\n        return\\r\\n      }\\r\\n      this$1.transitionTo(getHash(), function (route) {\\r\\n        if (supportsScroll) {\\r\\n          handleScroll(this$1.router, route, current, true);\\r\\n        }\\r\\n        if (!supportsPushState) {\\r\\n          replaceHash(route.fullPath);\\r\\n        }\\r\\n      });\\r\\n    });\\r\\n  };\\r\\n\\r\\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var ref = this;\\r\\n    var fromRoute = ref.current;\\r\\n    this.transitionTo(location, function (route) {\\r\\n      pushHash(route.fullPath);\\r\\n      handleScroll(this$1.router, route, fromRoute, false);\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var ref = this;\\r\\n    var fromRoute = ref.current;\\r\\n    this.transitionTo(location, function (route) {\\r\\n      replaceHash(route.fullPath);\\r\\n      handleScroll(this$1.router, route, fromRoute, false);\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  HashHistory.prototype.go = function go (n) {\\r\\n    window.history.go(n);\\r\\n  };\\r\\n\\r\\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\\r\\n    var current = this.current.fullPath;\\r\\n    if (getHash() !== current) {\\r\\n      push ? pushHash(current) : replaceHash(current);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\\r\\n    return getHash()\\r\\n  };\\r\\n\\r\\n  return HashHistory;\\r\\n}(History));\\r\\n\\r\\nfunction checkFallback (base) {\\r\\n  var location = getLocation(base);\\r\\n  if (!/^\\\\/#/.test(location)) {\\r\\n    window.location.replace(\\r\\n      cleanPath(base + '/#' + location)\\r\\n    );\\r\\n    return true\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction ensureSlash () {\\r\\n  var path = getHash();\\r\\n  if (path.charAt(0) === '/') {\\r\\n    return true\\r\\n  }\\r\\n  replaceHash('/' + path);\\r\\n  return false\\r\\n}\\r\\n\\r\\nfunction getHash () {\\r\\n  // We can't use window.location.hash here because it's not\\r\\n  // consistent across browsers - Firefox will pre-decode it!\\r\\n  var href = window.location.href;\\r\\n  var index = href.indexOf('#');\\r\\n  return index === -1 ? '' : decodeURI(href.slice(index + 1))\\r\\n}\\r\\n\\r\\nfunction getUrl (path) {\\r\\n  var href = window.location.href;\\r\\n  var i = href.indexOf('#');\\r\\n  var base = i >= 0 ? href.slice(0, i) : href;\\r\\n  return (base + \\\"#\\\" + path)\\r\\n}\\r\\n\\r\\nfunction pushHash (path) {\\r\\n  if (supportsPushState) {\\r\\n    pushState(getUrl(path));\\r\\n  } else {\\r\\n    window.location.hash = path;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction replaceHash (path) {\\r\\n  if (supportsPushState) {\\r\\n    replaceState(getUrl(path));\\r\\n  } else {\\r\\n    window.location.replace(getUrl(path));\\r\\n  }\\r\\n}\\r\\n\\r\\n/*  */\\r\\n\\r\\nvar AbstractHistory = (function (History$$1) {\\r\\n  function AbstractHistory (router, base) {\\r\\n    History$$1.call(this, router, base);\\r\\n    this.stack = [];\\r\\n    this.index = -1;\\r\\n  }\\r\\n\\r\\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\\r\\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\\r\\n  AbstractHistory.prototype.constructor = AbstractHistory;\\r\\n\\r\\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    this.transitionTo(location, function (route) {\\r\\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\\r\\n      this$1.index++;\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    this.transitionTo(location, function (route) {\\r\\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\\r\\n      onComplete && onComplete(route);\\r\\n    }, onAbort);\\r\\n  };\\r\\n\\r\\n  AbstractHistory.prototype.go = function go (n) {\\r\\n    var this$1 = this;\\r\\n\\r\\n    var targetIndex = this.index + n;\\r\\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\\r\\n      return\\r\\n    }\\r\\n    var route = this.stack[targetIndex];\\r\\n    this.confirmTransition(route, function () {\\r\\n      this$1.index = targetIndex;\\r\\n      this$1.updateRoute(route);\\r\\n    });\\r\\n  };\\r\\n\\r\\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\\r\\n    var current = this.stack[this.stack.length - 1];\\r\\n    return current ? current.fullPath : '/'\\r\\n  };\\r\\n\\r\\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\\r\\n    // noop\\r\\n  };\\r\\n\\r\\n  return AbstractHistory;\\r\\n}(History));\\r\\n\\r\\n/*  */\\r\\n\\r\\n\\r\\n\\r\\nvar VueRouter = function VueRouter (options) {\\r\\n  if ( options === void 0 ) options = {};\\r\\n\\r\\n  this.app = null;\\r\\n  this.apps = [];\\r\\n  this.options = options;\\r\\n  this.beforeHooks = [];\\r\\n  this.resolveHooks = [];\\r\\n  this.afterHooks = [];\\r\\n  this.matcher = createMatcher(options.routes || [], this);\\r\\n\\r\\n  var mode = options.mode || 'hash';\\r\\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\\r\\n  if (this.fallback) {\\r\\n    mode = 'hash';\\r\\n  }\\r\\n  if (!inBrowser) {\\r\\n    mode = 'abstract';\\r\\n  }\\r\\n  this.mode = mode;\\r\\n\\r\\n  switch (mode) {\\r\\n    case 'history':\\r\\n      this.history = new HTML5History(this, options.base);\\r\\n      break\\r\\n    case 'hash':\\r\\n      this.history = new HashHistory(this, options.base, this.fallback);\\r\\n      break\\r\\n    case 'abstract':\\r\\n      this.history = new AbstractHistory(this, options.base);\\r\\n      break\\r\\n    default:\\r\\n      if (false) {}\\r\\n  }\\r\\n};\\r\\n\\r\\nvar prototypeAccessors = { currentRoute: { configurable: true } };\\r\\n\\r\\nVueRouter.prototype.match = function match (\\r\\n  raw,\\r\\n  current,\\r\\n  redirectedFrom\\r\\n) {\\r\\n  return this.matcher.match(raw, current, redirectedFrom)\\r\\n};\\r\\n\\r\\nprototypeAccessors.currentRoute.get = function () {\\r\\n  return this.history && this.history.current\\r\\n};\\r\\n\\r\\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\\r\\n    var this$1 = this;\\r\\n\\r\\n  \\\"production\\\" !== 'production' && assert(\\r\\n    install.installed,\\r\\n    \\\"not installed. Make sure to call `Vue.use(VueRouter)` \\\" +\\r\\n    \\\"before creating root instance.\\\"\\r\\n  );\\r\\n\\r\\n  this.apps.push(app);\\r\\n\\r\\n  // main app already initialized.\\r\\n  if (this.app) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  this.app = app;\\r\\n\\r\\n  var history = this.history;\\r\\n\\r\\n  if (history instanceof HTML5History) {\\r\\n    history.transitionTo(history.getCurrentLocation());\\r\\n  } else if (history instanceof HashHistory) {\\r\\n    var setupHashListener = function () {\\r\\n      history.setupListeners();\\r\\n    };\\r\\n    history.transitionTo(\\r\\n      history.getCurrentLocation(),\\r\\n      setupHashListener,\\r\\n      setupHashListener\\r\\n    );\\r\\n  }\\r\\n\\r\\n  history.listen(function (route) {\\r\\n    this$1.apps.forEach(function (app) {\\r\\n      app._route = route;\\r\\n    });\\r\\n  });\\r\\n};\\r\\n\\r\\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\\r\\n  return registerHook(this.beforeHooks, fn)\\r\\n};\\r\\n\\r\\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\\r\\n  return registerHook(this.resolveHooks, fn)\\r\\n};\\r\\n\\r\\nVueRouter.prototype.afterEach = function afterEach (fn) {\\r\\n  return registerHook(this.afterHooks, fn)\\r\\n};\\r\\n\\r\\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\\r\\n  this.history.onReady(cb, errorCb);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.onError = function onError (errorCb) {\\r\\n  this.history.onError(errorCb);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\\r\\n  this.history.push(location, onComplete, onAbort);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\\r\\n  this.history.replace(location, onComplete, onAbort);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.go = function go (n) {\\r\\n  this.history.go(n);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.back = function back () {\\r\\n  this.go(-1);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.forward = function forward () {\\r\\n  this.go(1);\\r\\n};\\r\\n\\r\\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\\r\\n  var route = to\\r\\n    ? to.matched\\r\\n      ? to\\r\\n      : this.resolve(to).route\\r\\n    : this.currentRoute;\\r\\n  if (!route) {\\r\\n    return []\\r\\n  }\\r\\n  return [].concat.apply([], route.matched.map(function (m) {\\r\\n    return Object.keys(m.components).map(function (key) {\\r\\n      return m.components[key]\\r\\n    })\\r\\n  }))\\r\\n};\\r\\n\\r\\nVueRouter.prototype.resolve = function resolve (\\r\\n  to,\\r\\n  current,\\r\\n  append\\r\\n) {\\r\\n  var location = normalizeLocation(\\r\\n    to,\\r\\n    current || this.history.current,\\r\\n    append,\\r\\n    this\\r\\n  );\\r\\n  var route = this.match(location, current);\\r\\n  var fullPath = route.redirectedFrom || route.fullPath;\\r\\n  var base = this.history.base;\\r\\n  var href = createHref(base, fullPath, this.mode);\\r\\n  return {\\r\\n    location: location,\\r\\n    route: route,\\r\\n    href: href,\\r\\n    // for backwards compat\\r\\n    normalizedTo: location,\\r\\n    resolved: route\\r\\n  }\\r\\n};\\r\\n\\r\\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\\r\\n  this.matcher.addRoutes(routes);\\r\\n  if (this.history.current !== START) {\\r\\n    this.history.transitionTo(this.history.getCurrentLocation());\\r\\n  }\\r\\n};\\r\\n\\r\\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\\r\\n\\r\\nfunction registerHook (list, fn) {\\r\\n  list.push(fn);\\r\\n  return function () {\\r\\n    var i = list.indexOf(fn);\\r\\n    if (i > -1) { list.splice(i, 1); }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createHref (base, fullPath, mode) {\\r\\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\\r\\n  return base ? cleanPath(base + '/' + path) : path\\r\\n}\\r\\n\\r\\nVueRouter.install = install;\\r\\nVueRouter.version = '3.0.2';\\r\\n\\r\\nif (inBrowser && window.Vue) {\\r\\n  window.Vue.use(VueRouter);\\r\\n}\\r\\n\\r\\n/* harmony default export */ var vue_router_esm = (VueRouter);\\r\\n\\n// CONCATENATED MODULE: ./node_modules/vue-resource/dist/vue-resource.esm.js\\n/*!\\r\\n * vue-resource v1.5.1\\r\\n * https://github.com/pagekit/vue-resource\\r\\n * Released under the MIT License.\\r\\n */\\r\\n\\r\\n/**\\r\\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\\r\\n */\\r\\n\\r\\nvar RESOLVED = 0;\\r\\nvar REJECTED = 1;\\r\\nvar PENDING = 2;\\r\\n\\r\\nfunction Promise$1(executor) {\\r\\n\\r\\n    this.state = PENDING;\\r\\n    this.value = undefined;\\r\\n    this.deferred = [];\\r\\n\\r\\n    var promise = this;\\r\\n\\r\\n    try {\\r\\n        executor(function (x) {\\r\\n            promise.resolve(x);\\r\\n        }, function (r) {\\r\\n            promise.reject(r);\\r\\n        });\\r\\n    } catch (e) {\\r\\n        promise.reject(e);\\r\\n    }\\r\\n}\\r\\n\\r\\nPromise$1.reject = function (r) {\\r\\n    return new Promise$1(function (resolve, reject) {\\r\\n        reject(r);\\r\\n    });\\r\\n};\\r\\n\\r\\nPromise$1.resolve = function (x) {\\r\\n    return new Promise$1(function (resolve, reject) {\\r\\n        resolve(x);\\r\\n    });\\r\\n};\\r\\n\\r\\nPromise$1.all = function all(iterable) {\\r\\n    return new Promise$1(function (resolve, reject) {\\r\\n        var count = 0, result = [];\\r\\n\\r\\n        if (iterable.length === 0) {\\r\\n            resolve(result);\\r\\n        }\\r\\n\\r\\n        function resolver(i) {\\r\\n            return function (x) {\\r\\n                result[i] = x;\\r\\n                count += 1;\\r\\n\\r\\n                if (count === iterable.length) {\\r\\n                    resolve(result);\\r\\n                }\\r\\n            };\\r\\n        }\\r\\n\\r\\n        for (var i = 0; i < iterable.length; i += 1) {\\r\\n            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\\r\\n        }\\r\\n    });\\r\\n};\\r\\n\\r\\nPromise$1.race = function race(iterable) {\\r\\n    return new Promise$1(function (resolve, reject) {\\r\\n        for (var i = 0; i < iterable.length; i += 1) {\\r\\n            Promise$1.resolve(iterable[i]).then(resolve, reject);\\r\\n        }\\r\\n    });\\r\\n};\\r\\n\\r\\nvar p = Promise$1.prototype;\\r\\n\\r\\np.resolve = function resolve(x) {\\r\\n    var promise = this;\\r\\n\\r\\n    if (promise.state === PENDING) {\\r\\n        if (x === promise) {\\r\\n            throw new TypeError('Promise settled with itself.');\\r\\n        }\\r\\n\\r\\n        var called = false;\\r\\n\\r\\n        try {\\r\\n            var then = x && x['then'];\\r\\n\\r\\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\\r\\n                then.call(x, function (x) {\\r\\n                    if (!called) {\\r\\n                        promise.resolve(x);\\r\\n                    }\\r\\n                    called = true;\\r\\n\\r\\n                }, function (r) {\\r\\n                    if (!called) {\\r\\n                        promise.reject(r);\\r\\n                    }\\r\\n                    called = true;\\r\\n                });\\r\\n                return;\\r\\n            }\\r\\n        } catch (e) {\\r\\n            if (!called) {\\r\\n                promise.reject(e);\\r\\n            }\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        promise.state = RESOLVED;\\r\\n        promise.value = x;\\r\\n        promise.notify();\\r\\n    }\\r\\n};\\r\\n\\r\\np.reject = function reject(reason) {\\r\\n    var promise = this;\\r\\n\\r\\n    if (promise.state === PENDING) {\\r\\n        if (reason === promise) {\\r\\n            throw new TypeError('Promise settled with itself.');\\r\\n        }\\r\\n\\r\\n        promise.state = REJECTED;\\r\\n        promise.value = reason;\\r\\n        promise.notify();\\r\\n    }\\r\\n};\\r\\n\\r\\np.notify = function notify() {\\r\\n    var promise = this;\\r\\n\\r\\n    nextTick(function () {\\r\\n        if (promise.state !== PENDING) {\\r\\n            while (promise.deferred.length) {\\r\\n                var deferred = promise.deferred.shift(),\\r\\n                    onResolved = deferred[0],\\r\\n                    onRejected = deferred[1],\\r\\n                    resolve = deferred[2],\\r\\n                    reject = deferred[3];\\r\\n\\r\\n                try {\\r\\n                    if (promise.state === RESOLVED) {\\r\\n                        if (typeof onResolved === 'function') {\\r\\n                            resolve(onResolved.call(undefined, promise.value));\\r\\n                        } else {\\r\\n                            resolve(promise.value);\\r\\n                        }\\r\\n                    } else if (promise.state === REJECTED) {\\r\\n                        if (typeof onRejected === 'function') {\\r\\n                            resolve(onRejected.call(undefined, promise.value));\\r\\n                        } else {\\r\\n                            reject(promise.value);\\r\\n                        }\\r\\n                    }\\r\\n                } catch (e) {\\r\\n                    reject(e);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    });\\r\\n};\\r\\n\\r\\np.then = function then(onResolved, onRejected) {\\r\\n    var promise = this;\\r\\n\\r\\n    return new Promise$1(function (resolve, reject) {\\r\\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\\r\\n        promise.notify();\\r\\n    });\\r\\n};\\r\\n\\r\\np.catch = function (onRejected) {\\r\\n    return this.then(undefined, onRejected);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Promise adapter.\\r\\n */\\r\\n\\r\\nif (typeof Promise === 'undefined') {\\r\\n    window.Promise = Promise$1;\\r\\n}\\r\\n\\r\\nfunction PromiseObj(executor, context) {\\r\\n\\r\\n    if (executor instanceof Promise) {\\r\\n        this.promise = executor;\\r\\n    } else {\\r\\n        this.promise = new Promise(executor.bind(context));\\r\\n    }\\r\\n\\r\\n    this.context = context;\\r\\n}\\r\\n\\r\\nPromiseObj.all = function (iterable, context) {\\r\\n    return new PromiseObj(Promise.all(iterable), context);\\r\\n};\\r\\n\\r\\nPromiseObj.resolve = function (value, context) {\\r\\n    return new PromiseObj(Promise.resolve(value), context);\\r\\n};\\r\\n\\r\\nPromiseObj.reject = function (reason, context) {\\r\\n    return new PromiseObj(Promise.reject(reason), context);\\r\\n};\\r\\n\\r\\nPromiseObj.race = function (iterable, context) {\\r\\n    return new PromiseObj(Promise.race(iterable), context);\\r\\n};\\r\\n\\r\\nvar p$1 = PromiseObj.prototype;\\r\\n\\r\\np$1.bind = function (context) {\\r\\n    this.context = context;\\r\\n    return this;\\r\\n};\\r\\n\\r\\np$1.then = function (fulfilled, rejected) {\\r\\n\\r\\n    if (fulfilled && fulfilled.bind && this.context) {\\r\\n        fulfilled = fulfilled.bind(this.context);\\r\\n    }\\r\\n\\r\\n    if (rejected && rejected.bind && this.context) {\\r\\n        rejected = rejected.bind(this.context);\\r\\n    }\\r\\n\\r\\n    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\\r\\n};\\r\\n\\r\\np$1.catch = function (rejected) {\\r\\n\\r\\n    if (rejected && rejected.bind && this.context) {\\r\\n        rejected = rejected.bind(this.context);\\r\\n    }\\r\\n\\r\\n    return new PromiseObj(this.promise.catch(rejected), this.context);\\r\\n};\\r\\n\\r\\np$1.finally = function (callback) {\\r\\n\\r\\n    return this.then(function (value) {\\r\\n        callback.call(this);\\r\\n        return value;\\r\\n    }, function (reason) {\\r\\n        callback.call(this);\\r\\n        return Promise.reject(reason);\\r\\n    }\\r\\n    );\\r\\n};\\r\\n\\r\\n/**\\r\\n * Utility functions.\\r\\n */\\r\\n\\r\\nvar ref = {};\\r\\nvar vue_resource_esm_hasOwnProperty = ref.hasOwnProperty;\\r\\nvar ref$1 = [];\\r\\nvar slice = ref$1.slice;\\r\\nvar debug = false, ntick;\\r\\n\\r\\nvar vue_resource_esm_inBrowser = typeof window !== 'undefined';\\r\\n\\r\\nfunction Util (ref) {\\r\\n    var config = ref.config;\\r\\n    var nextTick = ref.nextTick;\\r\\n\\r\\n    ntick = nextTick;\\r\\n    debug = config.debug || !config.silent;\\r\\n}\\r\\n\\r\\nfunction vue_resource_esm_warn(msg) {\\r\\n    if (typeof console !== 'undefined' && debug) {\\r\\n        console.warn('[VueResource warn]: ' + msg);\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction error(msg) {\\r\\n    if (typeof console !== 'undefined') {\\r\\n        console.error(msg);\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction nextTick(cb, ctx) {\\r\\n    return ntick(cb, ctx);\\r\\n}\\r\\n\\r\\nfunction trim(str) {\\r\\n    return str ? str.replace(/^\\\\s*|\\\\s*$/g, '') : '';\\r\\n}\\r\\n\\r\\nfunction trimEnd(str, chars) {\\r\\n\\r\\n    if (str && chars === undefined) {\\r\\n        return str.replace(/\\\\s+$/, '');\\r\\n    }\\r\\n\\r\\n    if (!str || !chars) {\\r\\n        return str;\\r\\n    }\\r\\n\\r\\n    return str.replace(new RegExp((\\\"[\\\" + chars + \\\"]+$\\\")), '');\\r\\n}\\r\\n\\r\\nfunction toLower(str) {\\r\\n    return str ? str.toLowerCase() : '';\\r\\n}\\r\\n\\r\\nfunction toUpper(str) {\\r\\n    return str ? str.toUpperCase() : '';\\r\\n}\\r\\n\\r\\nvar isArray = Array.isArray;\\r\\n\\r\\nfunction isString(val) {\\r\\n    return typeof val === 'string';\\r\\n}\\r\\n\\r\\nfunction isFunction(val) {\\r\\n    return typeof val === 'function';\\r\\n}\\r\\n\\r\\nfunction isObject(obj) {\\r\\n    return obj !== null && typeof obj === 'object';\\r\\n}\\r\\n\\r\\nfunction isPlainObject(obj) {\\r\\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\\r\\n}\\r\\n\\r\\nfunction isBlob(obj) {\\r\\n    return typeof Blob !== 'undefined' && obj instanceof Blob;\\r\\n}\\r\\n\\r\\nfunction isFormData(obj) {\\r\\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\\r\\n}\\r\\n\\r\\nfunction when(value, fulfilled, rejected) {\\r\\n\\r\\n    var promise = PromiseObj.resolve(value);\\r\\n\\r\\n    if (arguments.length < 2) {\\r\\n        return promise;\\r\\n    }\\r\\n\\r\\n    return promise.then(fulfilled, rejected);\\r\\n}\\r\\n\\r\\nfunction options(fn, obj, opts) {\\r\\n\\r\\n    opts = opts || {};\\r\\n\\r\\n    if (isFunction(opts)) {\\r\\n        opts = opts.call(obj);\\r\\n    }\\r\\n\\r\\n    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});\\r\\n}\\r\\n\\r\\nfunction each(obj, iterator) {\\r\\n\\r\\n    var i, key;\\r\\n\\r\\n    if (isArray(obj)) {\\r\\n        for (i = 0; i < obj.length; i++) {\\r\\n            iterator.call(obj[i], obj[i], i);\\r\\n        }\\r\\n    } else if (isObject(obj)) {\\r\\n        for (key in obj) {\\r\\n            if (vue_resource_esm_hasOwnProperty.call(obj, key)) {\\r\\n                iterator.call(obj[key], obj[key], key);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return obj;\\r\\n}\\r\\n\\r\\nvar vue_resource_esm_assign = Object.assign || _assign;\\r\\n\\r\\nfunction merge(target) {\\r\\n\\r\\n    var args = slice.call(arguments, 1);\\r\\n\\r\\n    args.forEach(function (source) {\\r\\n        _merge(target, source, true);\\r\\n    });\\r\\n\\r\\n    return target;\\r\\n}\\r\\n\\r\\nfunction defaults(target) {\\r\\n\\r\\n    var args = slice.call(arguments, 1);\\r\\n\\r\\n    args.forEach(function (source) {\\r\\n\\r\\n        for (var key in source) {\\r\\n            if (target[key] === undefined) {\\r\\n                target[key] = source[key];\\r\\n            }\\r\\n        }\\r\\n\\r\\n    });\\r\\n\\r\\n    return target;\\r\\n}\\r\\n\\r\\nfunction _assign(target) {\\r\\n\\r\\n    var args = slice.call(arguments, 1);\\r\\n\\r\\n    args.forEach(function (source) {\\r\\n        _merge(target, source);\\r\\n    });\\r\\n\\r\\n    return target;\\r\\n}\\r\\n\\r\\nfunction _merge(target, source, deep) {\\r\\n    for (var key in source) {\\r\\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\r\\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\\r\\n                target[key] = {};\\r\\n            }\\r\\n            if (isArray(source[key]) && !isArray(target[key])) {\\r\\n                target[key] = [];\\r\\n            }\\r\\n            _merge(target[key], source[key], deep);\\r\\n        } else if (source[key] !== undefined) {\\r\\n            target[key] = source[key];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Root Prefix Transform.\\r\\n */\\r\\n\\r\\nfunction root (options$$1, next) {\\r\\n\\r\\n    var url = next(options$$1);\\r\\n\\r\\n    if (isString(options$$1.root) && !/^(https?:)?\\\\//.test(url)) {\\r\\n        url = trimEnd(options$$1.root, '/') + '/' + url;\\r\\n    }\\r\\n\\r\\n    return url;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Query Parameter Transform.\\r\\n */\\r\\n\\r\\nfunction query (options$$1, next) {\\r\\n\\r\\n    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);\\r\\n\\r\\n    each(options$$1.params, function (value, key) {\\r\\n        if (urlParams.indexOf(key) === -1) {\\r\\n            query[key] = value;\\r\\n        }\\r\\n    });\\r\\n\\r\\n    query = Url.params(query);\\r\\n\\r\\n    if (query) {\\r\\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\\r\\n    }\\r\\n\\r\\n    return url;\\r\\n}\\r\\n\\r\\n/**\\r\\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\\r\\n */\\r\\n\\r\\nfunction expand(url, params, variables) {\\r\\n\\r\\n    var tmpl = vue_resource_esm_parse(url), expanded = tmpl.expand(params);\\r\\n\\r\\n    if (variables) {\\r\\n        variables.push.apply(variables, tmpl.vars);\\r\\n    }\\r\\n\\r\\n    return expanded;\\r\\n}\\r\\n\\r\\nfunction vue_resource_esm_parse(template) {\\r\\n\\r\\n    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];\\r\\n\\r\\n    return {\\r\\n        vars: variables,\\r\\n        expand: function expand(context) {\\r\\n            return template.replace(/\\\\{([^{}]+)\\\\}|([^{}]+)/g, function (_, expression, literal) {\\r\\n                if (expression) {\\r\\n\\r\\n                    var operator = null, values = [];\\r\\n\\r\\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\\r\\n                        operator = expression.charAt(0);\\r\\n                        expression = expression.substr(1);\\r\\n                    }\\r\\n\\r\\n                    expression.split(/,/g).forEach(function (variable) {\\r\\n                        var tmp = /([^:*]*)(?::(\\\\d+)|(\\\\*))?/.exec(variable);\\r\\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\\r\\n                        variables.push(tmp[1]);\\r\\n                    });\\r\\n\\r\\n                    if (operator && operator !== '+') {\\r\\n\\r\\n                        var separator = ',';\\r\\n\\r\\n                        if (operator === '?') {\\r\\n                            separator = '&';\\r\\n                        } else if (operator !== '#') {\\r\\n                            separator = operator;\\r\\n                        }\\r\\n\\r\\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\\r\\n                    } else {\\r\\n                        return values.join(',');\\r\\n                    }\\r\\n\\r\\n                } else {\\r\\n                    return encodeReserved(literal);\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    };\\r\\n}\\r\\n\\r\\nfunction getValues(context, operator, key, modifier) {\\r\\n\\r\\n    var value = context[key], result = [];\\r\\n\\r\\n    if (isDefined(value) && value !== '') {\\r\\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\\r\\n            value = value.toString();\\r\\n\\r\\n            if (modifier && modifier !== '*') {\\r\\n                value = value.substring(0, parseInt(modifier, 10));\\r\\n            }\\r\\n\\r\\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\\r\\n        } else {\\r\\n            if (modifier === '*') {\\r\\n                if (Array.isArray(value)) {\\r\\n                    value.filter(isDefined).forEach(function (value) {\\r\\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\\r\\n                    });\\r\\n                } else {\\r\\n                    Object.keys(value).forEach(function (k) {\\r\\n                        if (isDefined(value[k])) {\\r\\n                            result.push(encodeValue(operator, value[k], k));\\r\\n                        }\\r\\n                    });\\r\\n                }\\r\\n            } else {\\r\\n                var tmp = [];\\r\\n\\r\\n                if (Array.isArray(value)) {\\r\\n                    value.filter(isDefined).forEach(function (value) {\\r\\n                        tmp.push(encodeValue(operator, value));\\r\\n                    });\\r\\n                } else {\\r\\n                    Object.keys(value).forEach(function (k) {\\r\\n                        if (isDefined(value[k])) {\\r\\n                            tmp.push(encodeURIComponent(k));\\r\\n                            tmp.push(encodeValue(operator, value[k].toString()));\\r\\n                        }\\r\\n                    });\\r\\n                }\\r\\n\\r\\n                if (isKeyOperator(operator)) {\\r\\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\\r\\n                } else if (tmp.length !== 0) {\\r\\n                    result.push(tmp.join(','));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    } else {\\r\\n        if (operator === ';') {\\r\\n            result.push(encodeURIComponent(key));\\r\\n        } else if (value === '' && (operator === '&' || operator === '?')) {\\r\\n            result.push(encodeURIComponent(key) + '=');\\r\\n        } else if (value === '') {\\r\\n            result.push('');\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\nfunction isDefined(value) {\\r\\n    return value !== undefined && value !== null;\\r\\n}\\r\\n\\r\\nfunction isKeyOperator(operator) {\\r\\n    return operator === ';' || operator === '&' || operator === '?';\\r\\n}\\r\\n\\r\\nfunction encodeValue(operator, value, key) {\\r\\n\\r\\n    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);\\r\\n\\r\\n    if (key) {\\r\\n        return encodeURIComponent(key) + '=' + value;\\r\\n    } else {\\r\\n        return value;\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction encodeReserved(str) {\\r\\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\\r\\n        if (!/%[0-9A-Fa-f]/.test(part)) {\\r\\n            part = encodeURI(part);\\r\\n        }\\r\\n        return part;\\r\\n    }).join('');\\r\\n}\\r\\n\\r\\n/**\\r\\n * URL Template (RFC 6570) Transform.\\r\\n */\\r\\n\\r\\nfunction template (options) {\\r\\n\\r\\n    var variables = [], url = expand(options.url, options.params, variables);\\r\\n\\r\\n    variables.forEach(function (key) {\\r\\n        delete options.params[key];\\r\\n    });\\r\\n\\r\\n    return url;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Service for URL templating.\\r\\n */\\r\\n\\r\\nfunction Url(url, params) {\\r\\n\\r\\n    var self = this || {}, options$$1 = url, transform;\\r\\n\\r\\n    if (isString(url)) {\\r\\n        options$$1 = {url: url, params: params};\\r\\n    }\\r\\n\\r\\n    options$$1 = merge({}, Url.options, self.$options, options$$1);\\r\\n\\r\\n    Url.transforms.forEach(function (handler) {\\r\\n\\r\\n        if (isString(handler)) {\\r\\n            handler = Url.transform[handler];\\r\\n        }\\r\\n\\r\\n        if (isFunction(handler)) {\\r\\n            transform = factory(handler, transform, self.$vm);\\r\\n        }\\r\\n\\r\\n    });\\r\\n\\r\\n    return transform(options$$1);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Url options.\\r\\n */\\r\\n\\r\\nUrl.options = {\\r\\n    url: '',\\r\\n    root: null,\\r\\n    params: {}\\r\\n};\\r\\n\\r\\n/**\\r\\n * Url transforms.\\r\\n */\\r\\n\\r\\nUrl.transform = {template: template, query: query, root: root};\\r\\nUrl.transforms = ['template', 'query', 'root'];\\r\\n\\r\\n/**\\r\\n * Encodes a Url parameter string.\\r\\n *\\r\\n * @param {Object} obj\\r\\n */\\r\\n\\r\\nUrl.params = function (obj) {\\r\\n\\r\\n    var params = [], escape = encodeURIComponent;\\r\\n\\r\\n    params.add = function (key, value) {\\r\\n\\r\\n        if (isFunction(value)) {\\r\\n            value = value();\\r\\n        }\\r\\n\\r\\n        if (value === null) {\\r\\n            value = '';\\r\\n        }\\r\\n\\r\\n        this.push(escape(key) + '=' + escape(value));\\r\\n    };\\r\\n\\r\\n    serialize(params, obj);\\r\\n\\r\\n    return params.join('&').replace(/%20/g, '+');\\r\\n};\\r\\n\\r\\n/**\\r\\n * Parse a URL and return its components.\\r\\n *\\r\\n * @param {String} url\\r\\n */\\r\\n\\r\\nUrl.parse = function (url) {\\r\\n\\r\\n    var el = document.createElement('a');\\r\\n\\r\\n    if (document.documentMode) {\\r\\n        el.href = url;\\r\\n        url = el.href;\\r\\n    }\\r\\n\\r\\n    el.href = url;\\r\\n\\r\\n    return {\\r\\n        href: el.href,\\r\\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\\r\\n        port: el.port,\\r\\n        host: el.host,\\r\\n        hostname: el.hostname,\\r\\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\\r\\n        search: el.search ? el.search.replace(/^\\\\?/, '') : '',\\r\\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\\r\\n    };\\r\\n};\\r\\n\\r\\nfunction factory(handler, next, vm) {\\r\\n    return function (options$$1) {\\r\\n        return handler.call(vm, options$$1, next);\\r\\n    };\\r\\n}\\r\\n\\r\\nfunction serialize(params, obj, scope) {\\r\\n\\r\\n    var array = isArray(obj), plain = isPlainObject(obj), hash;\\r\\n\\r\\n    each(obj, function (value, key) {\\r\\n\\r\\n        hash = isObject(value) || isArray(value);\\r\\n\\r\\n        if (scope) {\\r\\n            key = scope + '[' + (plain || hash ? key : '') + ']';\\r\\n        }\\r\\n\\r\\n        if (!scope && array) {\\r\\n            params.add(value.name, value.value);\\r\\n        } else if (hash) {\\r\\n            serialize(params, value, key);\\r\\n        } else {\\r\\n            params.add(key, value);\\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\n/**\\r\\n * XDomain client (Internet Explorer).\\r\\n */\\r\\n\\r\\nfunction xdrClient (request) {\\r\\n    return new PromiseObj(function (resolve) {\\r\\n\\r\\n        var xdr = new XDomainRequest(), handler = function (ref) {\\r\\n                var type = ref.type;\\r\\n\\r\\n\\r\\n                var status = 0;\\r\\n\\r\\n                if (type === 'load') {\\r\\n                    status = 200;\\r\\n                } else if (type === 'error') {\\r\\n                    status = 500;\\r\\n                }\\r\\n\\r\\n                resolve(request.respondWith(xdr.responseText, {status: status}));\\r\\n            };\\r\\n\\r\\n        request.abort = function () { return xdr.abort(); };\\r\\n\\r\\n        xdr.open(request.method, request.getUrl());\\r\\n\\r\\n        if (request.timeout) {\\r\\n            xdr.timeout = request.timeout;\\r\\n        }\\r\\n\\r\\n        xdr.onload = handler;\\r\\n        xdr.onabort = handler;\\r\\n        xdr.onerror = handler;\\r\\n        xdr.ontimeout = handler;\\r\\n        xdr.onprogress = function () {};\\r\\n        xdr.send(request.getBody());\\r\\n    });\\r\\n}\\r\\n\\r\\n/**\\r\\n * CORS Interceptor.\\r\\n */\\r\\n\\r\\nvar SUPPORTS_CORS = vue_resource_esm_inBrowser && 'withCredentials' in new XMLHttpRequest();\\r\\n\\r\\nfunction cors (request) {\\r\\n\\r\\n    if (vue_resource_esm_inBrowser) {\\r\\n\\r\\n        var orgUrl = Url.parse(location.href);\\r\\n        var reqUrl = Url.parse(request.getUrl());\\r\\n\\r\\n        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {\\r\\n\\r\\n            request.crossOrigin = true;\\r\\n            request.emulateHTTP = false;\\r\\n\\r\\n            if (!SUPPORTS_CORS) {\\r\\n                request.client = xdrClient;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Form data Interceptor.\\r\\n */\\r\\n\\r\\nfunction vue_resource_esm_form (request) {\\r\\n\\r\\n    if (isFormData(request.body)) {\\r\\n        request.headers.delete('Content-Type');\\r\\n    } else if (isObject(request.body) && request.emulateJSON) {\\r\\n        request.body = Url.params(request.body);\\r\\n        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * JSON Interceptor.\\r\\n */\\r\\n\\r\\nfunction json (request) {\\r\\n\\r\\n    var type = request.headers.get('Content-Type') || '';\\r\\n\\r\\n    if (isObject(request.body) && type.indexOf('application/json') === 0) {\\r\\n        request.body = JSON.stringify(request.body);\\r\\n    }\\r\\n\\r\\n    return function (response) {\\r\\n\\r\\n        return response.bodyText ? when(response.text(), function (text) {\\r\\n\\r\\n            var type = response.headers.get('Content-Type') || '';\\r\\n\\r\\n            if (type.indexOf('application/json') === 0 || isJson(text)) {\\r\\n\\r\\n                try {\\r\\n                    response.body = JSON.parse(text);\\r\\n                } catch (e) {\\r\\n                    response.body = null;\\r\\n                }\\r\\n\\r\\n            } else {\\r\\n                response.body = text;\\r\\n            }\\r\\n\\r\\n            return response;\\r\\n\\r\\n        }) : response;\\r\\n\\r\\n    };\\r\\n}\\r\\n\\r\\nfunction isJson(str) {\\r\\n\\r\\n    var start = str.match(/^\\\\s*(\\\\[|\\\\{)/);\\r\\n    var end = {'[': /]\\\\s*$/, '{': /}\\\\s*$/};\\r\\n\\r\\n    return start && end[start[1]].test(str);\\r\\n}\\r\\n\\r\\n/**\\r\\n * JSONP client (Browser).\\r\\n */\\r\\n\\r\\nfunction jsonpClient (request) {\\r\\n    return new PromiseObj(function (resolve) {\\r\\n\\r\\n        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;\\r\\n\\r\\n        handler = function (ref) {\\r\\n            var type = ref.type;\\r\\n\\r\\n\\r\\n            var status = 0;\\r\\n\\r\\n            if (type === 'load' && body !== null) {\\r\\n                status = 200;\\r\\n            } else if (type === 'error') {\\r\\n                status = 500;\\r\\n            }\\r\\n\\r\\n            if (status && window[callback]) {\\r\\n                delete window[callback];\\r\\n                document.body.removeChild(script);\\r\\n            }\\r\\n\\r\\n            resolve(request.respondWith(body, {status: status}));\\r\\n        };\\r\\n\\r\\n        window[callback] = function (result) {\\r\\n            body = JSON.stringify(result);\\r\\n        };\\r\\n\\r\\n        request.abort = function () {\\r\\n            handler({type: 'abort'});\\r\\n        };\\r\\n\\r\\n        request.params[name] = callback;\\r\\n\\r\\n        if (request.timeout) {\\r\\n            setTimeout(request.abort, request.timeout);\\r\\n        }\\r\\n\\r\\n        script = document.createElement('script');\\r\\n        script.src = request.getUrl();\\r\\n        script.type = 'text/javascript';\\r\\n        script.async = true;\\r\\n        script.onload = handler;\\r\\n        script.onerror = handler;\\r\\n\\r\\n        document.body.appendChild(script);\\r\\n    });\\r\\n}\\r\\n\\r\\n/**\\r\\n * JSONP Interceptor.\\r\\n */\\r\\n\\r\\nfunction jsonp (request) {\\r\\n\\r\\n    if (request.method == 'JSONP') {\\r\\n        request.client = jsonpClient;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Before Interceptor.\\r\\n */\\r\\n\\r\\nfunction before (request) {\\r\\n\\r\\n    if (isFunction(request.before)) {\\r\\n        request.before.call(this, request);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * HTTP method override Interceptor.\\r\\n */\\r\\n\\r\\nfunction method (request) {\\r\\n\\r\\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\\r\\n        request.headers.set('X-HTTP-Method-Override', request.method);\\r\\n        request.method = 'POST';\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Header Interceptor.\\r\\n */\\r\\n\\r\\nfunction header (request) {\\r\\n\\r\\n    var headers = vue_resource_esm_assign({}, Http.headers.common,\\r\\n        !request.crossOrigin ? Http.headers.custom : {},\\r\\n        Http.headers[toLower(request.method)]\\r\\n    );\\r\\n\\r\\n    each(headers, function (value, name) {\\r\\n        if (!request.headers.has(name)) {\\r\\n            request.headers.set(name, value);\\r\\n        }\\r\\n    });\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * XMLHttp client (Browser).\\r\\n */\\r\\n\\r\\nfunction xhrClient (request) {\\r\\n    return new PromiseObj(function (resolve) {\\r\\n\\r\\n        var xhr = new XMLHttpRequest(), handler = function (event) {\\r\\n\\r\\n                var response = request.respondWith(\\r\\n                'response' in xhr ? xhr.response : xhr.responseText, {\\r\\n                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\\r\\n                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\\r\\n                });\\r\\n\\r\\n                each(trim(xhr.getAllResponseHeaders()).split('\\\\n'), function (row) {\\r\\n                    response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\\r\\n                });\\r\\n\\r\\n                resolve(response);\\r\\n            };\\r\\n\\r\\n        request.abort = function () { return xhr.abort(); };\\r\\n\\r\\n        xhr.open(request.method, request.getUrl(), true);\\r\\n\\r\\n        if (request.timeout) {\\r\\n            xhr.timeout = request.timeout;\\r\\n        }\\r\\n\\r\\n        if (request.responseType && 'responseType' in xhr) {\\r\\n            xhr.responseType = request.responseType;\\r\\n        }\\r\\n\\r\\n        if (request.withCredentials || request.credentials) {\\r\\n            xhr.withCredentials = true;\\r\\n        }\\r\\n\\r\\n        if (!request.crossOrigin) {\\r\\n            request.headers.set('X-Requested-With', 'XMLHttpRequest');\\r\\n        }\\r\\n\\r\\n        // deprecated use downloadProgress\\r\\n        if (isFunction(request.progress) && request.method === 'GET') {\\r\\n            xhr.addEventListener('progress', request.progress);\\r\\n        }\\r\\n\\r\\n        if (isFunction(request.downloadProgress)) {\\r\\n            xhr.addEventListener('progress', request.downloadProgress);\\r\\n        }\\r\\n\\r\\n        // deprecated use uploadProgress\\r\\n        if (isFunction(request.progress) && /^(POST|PUT)$/i.test(request.method)) {\\r\\n            xhr.upload.addEventListener('progress', request.progress);\\r\\n        }\\r\\n\\r\\n        if (isFunction(request.uploadProgress) && xhr.upload) {\\r\\n            xhr.upload.addEventListener('progress', request.uploadProgress);\\r\\n        }\\r\\n\\r\\n        request.headers.forEach(function (value, name) {\\r\\n            xhr.setRequestHeader(name, value);\\r\\n        });\\r\\n\\r\\n        xhr.onload = handler;\\r\\n        xhr.onabort = handler;\\r\\n        xhr.onerror = handler;\\r\\n        xhr.ontimeout = handler;\\r\\n        xhr.send(request.getBody());\\r\\n    });\\r\\n}\\r\\n\\r\\n/**\\r\\n * Http client (Node).\\r\\n */\\r\\n\\r\\nfunction nodeClient (request) {\\r\\n\\r\\n    var client = __webpack_require__(29);\\r\\n\\r\\n    return new PromiseObj(function (resolve) {\\r\\n\\r\\n        var url = request.getUrl();\\r\\n        var body = request.getBody();\\r\\n        var method = request.method;\\r\\n        var headers = {}, handler;\\r\\n\\r\\n        request.headers.forEach(function (value, name) {\\r\\n            headers[name] = value;\\r\\n        });\\r\\n\\r\\n        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {\\r\\n\\r\\n            var response = request.respondWith(resp.body, {\\r\\n                status: resp.statusCode,\\r\\n                statusText: trim(resp.statusMessage)\\r\\n            });\\r\\n\\r\\n            each(resp.headers, function (value, name) {\\r\\n                response.headers.set(name, value);\\r\\n            });\\r\\n\\r\\n            resolve(response);\\r\\n\\r\\n        }, function (error$$1) { return handler(error$$1.response); });\\r\\n    });\\r\\n}\\r\\n\\r\\n/**\\r\\n * Base client.\\r\\n */\\r\\n\\r\\nfunction Client (context) {\\r\\n\\r\\n    var reqHandlers = [sendRequest], resHandlers = [];\\r\\n\\r\\n    if (!isObject(context)) {\\r\\n        context = null;\\r\\n    }\\r\\n\\r\\n    function Client(request) {\\r\\n        while (reqHandlers.length) {\\r\\n\\r\\n            var handler = reqHandlers.pop();\\r\\n\\r\\n            if (isFunction(handler)) {\\r\\n\\r\\n                var response = (void 0), next = (void 0);\\r\\n\\r\\n                response = handler.call(context, request, function (val) { return next = val; }) || next;\\r\\n\\r\\n                if (isObject(response)) {\\r\\n                    return new PromiseObj(function (resolve, reject) {\\r\\n\\r\\n                        resHandlers.forEach(function (handler) {\\r\\n                            response = when(response, function (response) {\\r\\n                                return handler.call(context, response) || response;\\r\\n                            }, reject);\\r\\n                        });\\r\\n\\r\\n                        when(response, resolve, reject);\\r\\n\\r\\n                    }, context);\\r\\n                }\\r\\n\\r\\n                if (isFunction(response)) {\\r\\n                    resHandlers.unshift(response);\\r\\n                }\\r\\n\\r\\n            } else {\\r\\n                vue_resource_esm_warn((\\\"Invalid interceptor of type \\\" + (typeof handler) + \\\", must be a function\\\"));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    Client.use = function (handler) {\\r\\n        reqHandlers.push(handler);\\r\\n    };\\r\\n\\r\\n    return Client;\\r\\n}\\r\\n\\r\\nfunction sendRequest(request) {\\r\\n\\r\\n    var client = request.client || (vue_resource_esm_inBrowser ? xhrClient : nodeClient);\\r\\n\\r\\n    return client(request);\\r\\n}\\r\\n\\r\\n/**\\r\\n * HTTP Headers.\\r\\n */\\r\\n\\r\\nvar Headers = function Headers(headers) {\\r\\n    var this$1 = this;\\r\\n\\r\\n\\r\\n    this.map = {};\\r\\n\\r\\n    each(headers, function (value, name) { return this$1.append(name, value); });\\r\\n};\\r\\n\\r\\nHeaders.prototype.has = function has (name) {\\r\\n    return getName(this.map, name) !== null;\\r\\n};\\r\\n\\r\\nHeaders.prototype.get = function get (name) {\\r\\n\\r\\n    var list = this.map[getName(this.map, name)];\\r\\n\\r\\n    return list ? list.join() : null;\\r\\n};\\r\\n\\r\\nHeaders.prototype.getAll = function getAll (name) {\\r\\n    return this.map[getName(this.map, name)] || [];\\r\\n};\\r\\n\\r\\nHeaders.prototype.set = function set (name, value) {\\r\\n    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\\r\\n};\\r\\n\\r\\nHeaders.prototype.append = function append (name, value) {\\r\\n\\r\\n    var list = this.map[getName(this.map, name)];\\r\\n\\r\\n    if (list) {\\r\\n        list.push(trim(value));\\r\\n    } else {\\r\\n        this.set(name, value);\\r\\n    }\\r\\n};\\r\\n\\r\\nHeaders.prototype.delete = function delete$1 (name) {\\r\\n    delete this.map[getName(this.map, name)];\\r\\n};\\r\\n\\r\\nHeaders.prototype.deleteAll = function deleteAll () {\\r\\n    this.map = {};\\r\\n};\\r\\n\\r\\nHeaders.prototype.forEach = function forEach (callback, thisArg) {\\r\\n        var this$1 = this;\\r\\n\\r\\n    each(this.map, function (list, name) {\\r\\n        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });\\r\\n    });\\r\\n};\\r\\n\\r\\nfunction getName(map, name) {\\r\\n    return Object.keys(map).reduce(function (prev, curr) {\\r\\n        return toLower(name) === toLower(curr) ? curr : prev;\\r\\n    }, null);\\r\\n}\\r\\n\\r\\nfunction normalizeName(name) {\\r\\n\\r\\n    if (/[^a-z0-9\\\\-#$%&'*+.^_`|~]/i.test(name)) {\\r\\n        throw new TypeError('Invalid character in header field name');\\r\\n    }\\r\\n\\r\\n    return trim(name);\\r\\n}\\r\\n\\r\\n/**\\r\\n * HTTP Response.\\r\\n */\\r\\n\\r\\nvar Response = function Response(body, ref) {\\r\\n    var url = ref.url;\\r\\n    var headers = ref.headers;\\r\\n    var status = ref.status;\\r\\n    var statusText = ref.statusText;\\r\\n\\r\\n\\r\\n    this.url = url;\\r\\n    this.ok = status >= 200 && status < 300;\\r\\n    this.status = status || 0;\\r\\n    this.statusText = statusText || '';\\r\\n    this.headers = new Headers(headers);\\r\\n    this.body = body;\\r\\n\\r\\n    if (isString(body)) {\\r\\n\\r\\n        this.bodyText = body;\\r\\n\\r\\n    } else if (isBlob(body)) {\\r\\n\\r\\n        this.bodyBlob = body;\\r\\n\\r\\n        if (isBlobText(body)) {\\r\\n            this.bodyText = blobText(body);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nResponse.prototype.blob = function blob () {\\r\\n    return when(this.bodyBlob);\\r\\n};\\r\\n\\r\\nResponse.prototype.text = function text () {\\r\\n    return when(this.bodyText);\\r\\n};\\r\\n\\r\\nResponse.prototype.json = function json () {\\r\\n    return when(this.text(), function (text) { return JSON.parse(text); });\\r\\n};\\r\\n\\r\\nObject.defineProperty(Response.prototype, 'data', {\\r\\n\\r\\n    get: function get() {\\r\\n        return this.body;\\r\\n    },\\r\\n\\r\\n    set: function set(body) {\\r\\n        this.body = body;\\r\\n    }\\r\\n\\r\\n});\\r\\n\\r\\nfunction blobText(body) {\\r\\n    return new PromiseObj(function (resolve) {\\r\\n\\r\\n        var reader = new FileReader();\\r\\n\\r\\n        reader.readAsText(body);\\r\\n        reader.onload = function () {\\r\\n            resolve(reader.result);\\r\\n        };\\r\\n\\r\\n    });\\r\\n}\\r\\n\\r\\nfunction isBlobText(body) {\\r\\n    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\\r\\n}\\r\\n\\r\\n/**\\r\\n * HTTP Request.\\r\\n */\\r\\n\\r\\nvar Request = function Request(options$$1) {\\r\\n\\r\\n    this.body = null;\\r\\n    this.params = {};\\r\\n\\r\\n    vue_resource_esm_assign(this, options$$1, {\\r\\n        method: toUpper(options$$1.method || 'GET')\\r\\n    });\\r\\n\\r\\n    if (!(this.headers instanceof Headers)) {\\r\\n        this.headers = new Headers(this.headers);\\r\\n    }\\r\\n};\\r\\n\\r\\nRequest.prototype.getUrl = function getUrl () {\\r\\n    return Url(this);\\r\\n};\\r\\n\\r\\nRequest.prototype.getBody = function getBody () {\\r\\n    return this.body;\\r\\n};\\r\\n\\r\\nRequest.prototype.respondWith = function respondWith (body, options$$1) {\\r\\n    return new Response(body, vue_resource_esm_assign(options$$1 || {}, {url: this.getUrl()}));\\r\\n};\\r\\n\\r\\n/**\\r\\n * Service for sending network requests.\\r\\n */\\r\\n\\r\\nvar COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};\\r\\nvar JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};\\r\\n\\r\\nfunction Http(options$$1) {\\r\\n\\r\\n    var self = this || {}, client = Client(self.$vm);\\r\\n\\r\\n    defaults(options$$1 || {}, self.$options, Http.options);\\r\\n\\r\\n    Http.interceptors.forEach(function (handler) {\\r\\n\\r\\n        if (isString(handler)) {\\r\\n            handler = Http.interceptor[handler];\\r\\n        }\\r\\n\\r\\n        if (isFunction(handler)) {\\r\\n            client.use(handler);\\r\\n        }\\r\\n\\r\\n    });\\r\\n\\r\\n    return client(new Request(options$$1)).then(function (response) {\\r\\n\\r\\n        return response.ok ? response : PromiseObj.reject(response);\\r\\n\\r\\n    }, function (response) {\\r\\n\\r\\n        if (response instanceof Error) {\\r\\n            error(response);\\r\\n        }\\r\\n\\r\\n        return PromiseObj.reject(response);\\r\\n    });\\r\\n}\\r\\n\\r\\nHttp.options = {};\\r\\n\\r\\nHttp.headers = {\\r\\n    put: JSON_CONTENT_TYPE,\\r\\n    post: JSON_CONTENT_TYPE,\\r\\n    patch: JSON_CONTENT_TYPE,\\r\\n    delete: JSON_CONTENT_TYPE,\\r\\n    common: COMMON_HEADERS,\\r\\n    custom: {}\\r\\n};\\r\\n\\r\\nHttp.interceptor = {before: before, method: method, jsonp: jsonp, json: json, form: vue_resource_esm_form, header: header, cors: cors};\\r\\nHttp.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];\\r\\n\\r\\n['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {\\r\\n\\r\\n    Http[method$$1] = function (url, options$$1) {\\r\\n        return this(vue_resource_esm_assign(options$$1 || {}, {url: url, method: method$$1}));\\r\\n    };\\r\\n\\r\\n});\\r\\n\\r\\n['post', 'put', 'patch'].forEach(function (method$$1) {\\r\\n\\r\\n    Http[method$$1] = function (url, body, options$$1) {\\r\\n        return this(vue_resource_esm_assign(options$$1 || {}, {url: url, method: method$$1, body: body}));\\r\\n    };\\r\\n\\r\\n});\\r\\n\\r\\n/**\\r\\n * Service for interacting with RESTful services.\\r\\n */\\r\\n\\r\\nfunction Resource(url, params, actions, options$$1) {\\r\\n\\r\\n    var self = this || {}, resource = {};\\r\\n\\r\\n    actions = vue_resource_esm_assign({},\\r\\n        Resource.actions,\\r\\n        actions\\r\\n    );\\r\\n\\r\\n    each(actions, function (action, name) {\\r\\n\\r\\n        action = merge({url: url, params: vue_resource_esm_assign({}, params)}, options$$1, action);\\r\\n\\r\\n        resource[name] = function () {\\r\\n            return (self.$http || Http)(opts(action, arguments));\\r\\n        };\\r\\n    });\\r\\n\\r\\n    return resource;\\r\\n}\\r\\n\\r\\nfunction opts(action, args) {\\r\\n\\r\\n    var options$$1 = vue_resource_esm_assign({}, action), params = {}, body;\\r\\n\\r\\n    switch (args.length) {\\r\\n\\r\\n        case 2:\\r\\n\\r\\n            params = args[0];\\r\\n            body = args[1];\\r\\n\\r\\n            break;\\r\\n\\r\\n        case 1:\\r\\n\\r\\n            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {\\r\\n                body = args[0];\\r\\n            } else {\\r\\n                params = args[0];\\r\\n            }\\r\\n\\r\\n            break;\\r\\n\\r\\n        case 0:\\r\\n\\r\\n            break;\\r\\n\\r\\n        default:\\r\\n\\r\\n            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';\\r\\n    }\\r\\n\\r\\n    options$$1.body = body;\\r\\n    options$$1.params = vue_resource_esm_assign({}, options$$1.params, params);\\r\\n\\r\\n    return options$$1;\\r\\n}\\r\\n\\r\\nResource.actions = {\\r\\n\\r\\n    get: {method: 'GET'},\\r\\n    save: {method: 'POST'},\\r\\n    query: {method: 'GET'},\\r\\n    update: {method: 'PUT'},\\r\\n    remove: {method: 'DELETE'},\\r\\n    delete: {method: 'DELETE'}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * Install plugin.\\r\\n */\\r\\n\\r\\nfunction vue_resource_esm_plugin(Vue) {\\r\\n\\r\\n    if (vue_resource_esm_plugin.installed) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    Util(Vue);\\r\\n\\r\\n    Vue.url = Url;\\r\\n    Vue.http = Http;\\r\\n    Vue.resource = Resource;\\r\\n    Vue.Promise = PromiseObj;\\r\\n\\r\\n    Object.defineProperties(Vue.prototype, {\\r\\n\\r\\n        $url: {\\r\\n            get: function get() {\\r\\n                return options(Vue.url, this, this.$options.url);\\r\\n            }\\r\\n        },\\r\\n\\r\\n        $http: {\\r\\n            get: function get() {\\r\\n                return options(Vue.http, this, this.$options.http);\\r\\n            }\\r\\n        },\\r\\n\\r\\n        $resource: {\\r\\n            get: function get() {\\r\\n                return Vue.resource.bind(this);\\r\\n            }\\r\\n        },\\r\\n\\r\\n        $promise: {\\r\\n            get: function get() {\\r\\n                var this$1 = this;\\r\\n\\r\\n                return function (executor) { return new Vue.Promise(executor, this$1); };\\r\\n            }\\r\\n        }\\r\\n\\r\\n    });\\r\\n}\\r\\n\\r\\nif (typeof window !== 'undefined' && window.Vue) {\\r\\n    window.Vue.use(vue_resource_esm_plugin);\\r\\n}\\r\\n\\r\\n/* harmony default export */ var vue_resource_esm = (vue_resource_esm_plugin);\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/layout/Header.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Header = ({\\n    data: function data() {\\n        return {\\n            authenticated: false,\\n            mockAccount: {\\n                username: \\\"marbel\\\",\\n                password: \\\"mm\\\"\\n            }\\n        };\\n    },\\n\\n\\n    methods: {\\n        setAuthenticated: function setAuthenticated(status) {\\n            this.authenticated = status;\\n            this.$emit(\\\"authenticated\\\", status);\\n            console.log(this.authenticated);\\n        },\\n        logout: function logout() {\\n\\n            this.authenticated = false;\\n            this.$router.replace({ name: \\\"search\\\" });\\n            console.log(this.authenticated);\\n        },\\n        estado: function estado() {\\n            console.log(\\\"el estado es\\\");\\n            console.log(this.authenticated);\\n        }\\n    }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-5b45e25f\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/layout/Header.vue\\nvar Header_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\n    \\\"div\\\",\\n    [\\n      _c(\\\"div\\\", { staticClass: \\\"barra fixed\\\" }, [\\n        _c(\\n          \\\"div\\\",\\n          { staticClass: \\\"logo\\\" },\\n          [_c(\\\"router-link\\\", { attrs: { to: \\\"/\\\" } }, [_vm._v(\\\"SaludTech\\\")])],\\n          1\\n        ),\\n        _vm._v(\\\" \\\"),\\n        _c(\\n          \\\"nav\\\",\\n          { staticClass: \\\"navegacion-principal\\\" },\\n          [\\n            _c(\\\"router-link\\\", { attrs: { to: \\\"about\\\" } }, [\\n              _vm._v(\\\"Quienes somos\\\")\\n            ]),\\n            _vm._v(\\\" \\\"),\\n            _vm.authenticated\\n              ? _c(\\n                  \\\"router-link\\\",\\n                  {\\n                    attrs: { to: \\\"/\\\", replace: \\\"\\\" },\\n                    nativeOn: {\\n                      click: function($event) {\\n                        _vm.logout()\\n                      }\\n                    }\\n                  },\\n                  [_vm._v(\\\"Salir\\\")]\\n                )\\n              : _vm._e(),\\n            _vm._v(\\\" \\\"),\\n            !_vm.authenticated\\n              ? _c(\\\"router-link\\\", { attrs: { to: \\\"login\\\" } }, [\\n                  _vm._v(\\\"Iniciar sesion\\\")\\n                ])\\n              : _vm._e(),\\n            _vm._v(\\\" \\\"),\\n            _c(\\\"button\\\", { on: { click: _vm.estado } }, [_vm._v(\\\"probar\\\")])\\n          ],\\n          1\\n        )\\n      ]),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"router-view\\\", { on: { authenticated: _vm.setAuthenticated } })\\n    ],\\n    1\\n  )\\n}\\nvar staticRenderFns = []\\nHeader_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-5b45e25f\\\", { render: Header_render, staticRenderFns: staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/component-normalizer.js\\n/* globals __VUE_SSR_CONTEXT__ */\\r\\n\\r\\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\\r\\n// This module is a runtime utility for cleaner component module output and will\\r\\n// be included in the final webpack user bundle.\\r\\n\\r\\nfunction normalizeComponent (\\r\\n  scriptExports,\\r\\n  render,\\r\\n  staticRenderFns,\\r\\n  functionalTemplate,\\r\\n  injectStyles,\\r\\n  scopeId,\\r\\n  moduleIdentifier, /* server only */\\r\\n  shadowMode /* vue-cli only */\\r\\n) {\\r\\n  scriptExports = scriptExports || {}\\r\\n\\r\\n  // ES6 modules interop\\r\\n  var type = typeof scriptExports.default\\r\\n  if (type === 'object' || type === 'function') {\\r\\n    scriptExports = scriptExports.default\\r\\n  }\\r\\n\\r\\n  // Vue.extend constructor export interop\\r\\n  var options = typeof scriptExports === 'function'\\r\\n    ? scriptExports.options\\r\\n    : scriptExports\\r\\n\\r\\n  // render functions\\r\\n  if (render) {\\r\\n    options.render = render\\r\\n    options.staticRenderFns = staticRenderFns\\r\\n    options._compiled = true\\r\\n  }\\r\\n\\r\\n  // functional template\\r\\n  if (functionalTemplate) {\\r\\n    options.functional = true\\r\\n  }\\r\\n\\r\\n  // scopedId\\r\\n  if (scopeId) {\\r\\n    options._scopeId = scopeId\\r\\n  }\\r\\n\\r\\n  var hook\\r\\n  if (moduleIdentifier) { // server build\\r\\n    hook = function (context) {\\r\\n      // 2.3 injection\\r\\n      context =\\r\\n        context || // cached call\\r\\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\\r\\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\\r\\n      // 2.2 with runInNewContext: true\\r\\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\\r\\n        context = __VUE_SSR_CONTEXT__\\r\\n      }\\r\\n      // inject component styles\\r\\n      if (injectStyles) {\\r\\n        injectStyles.call(this, context)\\r\\n      }\\r\\n      // register component module identifier for async chunk inferrence\\r\\n      if (context && context._registeredComponents) {\\r\\n        context._registeredComponents.add(moduleIdentifier)\\r\\n      }\\r\\n    }\\r\\n    // used by ssr in case component is cached and beforeCreate\\r\\n    // never gets called\\r\\n    options._ssrRegister = hook\\r\\n  } else if (injectStyles) {\\r\\n    hook = shadowMode\\r\\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\\r\\n      : injectStyles\\r\\n  }\\r\\n\\r\\n  if (hook) {\\r\\n    if (options.functional) {\\r\\n      // for template-only hot-reload because in that case the render fn doesn't\\r\\n      // go through the normalizer\\r\\n      options._injectStyles = hook\\r\\n      // register for functioal component in vue file\\r\\n      var originalRender = options.render\\r\\n      options.render = function renderWithStyleInjection (h, context) {\\r\\n        hook.call(context)\\r\\n        return originalRender(h, context)\\r\\n      }\\r\\n    } else {\\r\\n      // inject component registration as beforeCreate hook\\r\\n      var existing = options.beforeCreate\\r\\n      options.beforeCreate = existing\\r\\n        ? [].concat(existing, hook)\\r\\n        : [hook]\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    exports: scriptExports,\\r\\n    options: options\\r\\n  }\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./src/components/layout/Header.vue\\nvar disposed = false\\nfunction injectStyle (context) {\\n  if (disposed) return\\n  __webpack_require__(26)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar __vue_template_functional__ = false\\n/* styles */\\nvar __vue_styles__ = injectStyle\\n/* scopeId */\\nvar __vue_scopeId__ = null\\n/* moduleIdentifier (server only) */\\nvar __vue_module_identifier__ = null\\n\\nvar Component = normalizeComponent(\\n  Header,\\n  Header_render,\\n  staticRenderFns,\\n  __vue_template_functional__,\\n  __vue_styles__,\\n  __vue_scopeId__,\\n  __vue_module_identifier__\\n)\\nComponent.options.__file = \\\"src\\\\\\\\components\\\\\\\\layout\\\\\\\\Header.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-5b45e25f\\\", Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-5b45e25f\\\", Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var layout_Header = (Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-3a137e6d\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/layout/Footer.vue\\nvar Footer_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _vm._m(0)\\n}\\nvar Footer_staticRenderFns = [\\n  function() {\\n    var _vm = this\\n    var _h = _vm.$createElement\\n    var _c = _vm._self._c || _h\\n    return _c(\\\"footer\\\", { staticClass: \\\"site-footer\\\" }, [\\n      _c(\\\"div\\\", { staticClass: \\\"contenedor clearfix\\\" }, [\\n        _c(\\\"div\\\", { staticClass: \\\"footer-informacion\\\" }, [\\n          _c(\\\"h3\\\", [_vm._v(\\\"SaludTech\\\")]),\\n          _vm._v(\\\" \\\"),\\n          _c(\\\"p\\\", [_vm._v(\\\"contacto@saludtech.com\\\")])\\n        ]),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"div\\\", { staticClass: \\\"menu\\\" })\\n      ]),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"p\\\", { staticClass: \\\"copyright\\\" }, [\\n        _vm._v(\\\"Todos los derechos reservados\\\")\\n      ])\\n    ])\\n  }\\n]\\nFooter_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-3a137e6d\\\", { render: Footer_render, staticRenderFns: Footer_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/layout/Footer.vue\\nvar Footer_disposed = false\\nfunction Footer_injectStyle (context) {\\n  if (Footer_disposed) return\\n  __webpack_require__(22)\\n}\\n/* script */\\nvar __vue_script__ = null\\n/* template */\\n\\n/* template functional */\\nvar Footer_vue_template_functional_ = false\\n/* styles */\\nvar Footer_vue_styles_ = Footer_injectStyle\\n/* scopeId */\\nvar Footer_vue_scopeId_ = null\\n/* moduleIdentifier (server only) */\\nvar Footer_vue_module_identifier_ = null\\n\\nvar Footer_Component = normalizeComponent(\\n  __vue_script__,\\n  Footer_render,\\n  Footer_staticRenderFns,\\n  Footer_vue_template_functional_,\\n  Footer_vue_styles_,\\n  Footer_vue_scopeId_,\\n  Footer_vue_module_identifier_\\n)\\nFooter_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\layout\\\\\\\\Footer.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-3a137e6d\\\", Footer_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-3a137e6d\\\", Footer_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Footer_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var Footer = (Footer_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/App.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n\\n\\n/* harmony default export */ var App = ({\\n    name: 'app',\\n    components: { stheader: layout_Header, stfooter: Footer },\\n    data: function data() {\\n        return {\\n            authenticated: false,\\n            mockAccount: {\\n                username: \\\"marbel\\\",\\n                password: \\\"mm\\\"\\n            }\\n        };\\n    },\\n\\n    methods: {\\n        setAuthenticated: function setAuthenticated(status) {\\n            this.authenticated = status;\\n            this.$emit(\\\"authenticated\\\", status);\\n            console.log(this.authenticated);\\n        }\\n    }\\n\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-04c2046b\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\\nvar App_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\n    \\\"div\\\",\\n    { attrs: { id: \\\"app\\\" } },\\n    [_c(\\\"stheader\\\"), _vm._v(\\\" \\\"), _c(\\\"stfooter\\\")],\\n    1\\n  )\\n}\\nvar App_staticRenderFns = []\\nApp_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-04c2046b\\\", { render: App_render, staticRenderFns: App_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/App.vue\\nvar App_disposed = false\\nfunction App_injectStyle (context) {\\n  if (App_disposed) return\\n  __webpack_require__(28)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar App_vue_template_functional_ = false\\n/* styles */\\nvar App_vue_styles_ = App_injectStyle\\n/* scopeId */\\nvar App_vue_scopeId_ = null\\n/* moduleIdentifier (server only) */\\nvar App_vue_module_identifier_ = null\\n\\nvar App_Component = normalizeComponent(\\n  App,\\n  App_render,\\n  App_staticRenderFns,\\n  App_vue_template_functional_,\\n  App_vue_styles_,\\n  App_vue_scopeId_,\\n  App_vue_module_identifier_\\n)\\nApp_Component.options.__file = \\\"src\\\\\\\\App.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-04c2046b\\\", App_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-04c2046b\\\", App_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    App_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var src_App = (App_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Search.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Search = ({\\n  name: \\\"app\\\",\\n  data: function data() {\\n    return {\\n      prueba: \\\"HOLA\\\",\\n      elem: [1, 2, 3, 4, 4, 3, 1, 2, 2, 1, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 9]\\n    };\\n  },\\n\\n  methods: {}\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-d9499c90\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Search.vue\\nvar Search_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\n    \\\"div\\\",\\n    { attrs: { id: \\\"main\\\" } },\\n    _vm._l(_vm.elem, function(i) {\\n      return _c(\\\"h1\\\", [_vm._v(_vm._s(i))])\\n    })\\n  )\\n}\\nvar Search_staticRenderFns = []\\nSearch_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-d9499c90\\\", { render: Search_render, staticRenderFns: Search_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/Search.vue\\nvar Search_disposed = false\\nfunction Search_injectStyle (context) {\\n  if (Search_disposed) return\\n  __webpack_require__(21)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Search_vue_template_functional_ = false\\n/* styles */\\nvar Search_vue_styles_ = Search_injectStyle\\n/* scopeId */\\nvar Search_vue_scopeId_ = null\\n/* moduleIdentifier (server only) */\\nvar Search_vue_module_identifier_ = null\\n\\nvar Search_Component = normalizeComponent(\\n  Search,\\n  Search_render,\\n  Search_staticRenderFns,\\n  Search_vue_template_functional_,\\n  Search_vue_styles_,\\n  Search_vue_scopeId_,\\n  Search_vue_module_identifier_\\n)\\nSearch_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\Search.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-d9499c90\\\", Search_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-d9499c90\\\", Search_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Search_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var components_Search = (Search_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-728ee9a6\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/About.vue\\nvar About_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _vm._m(0)\\n}\\nvar About_staticRenderFns = [\\n  function() {\\n    var _vm = this\\n    var _h = _vm.$createElement\\n    var _c = _vm._self._c || _h\\n    return _c(\\\"div\\\", [\\n      _c(\\\"div\\\", { staticClass: \\\"bajar\\\" }, [\\n        _c(\\\"h1\\\", [_vm._v(\\\"Nosotros\\\")]),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"p\\\", [_vm._v(\\\"acerca de saludtech\\\")])\\n      ])\\n    ])\\n  }\\n]\\nAbout_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-728ee9a6\\\", { render: About_render, staticRenderFns: About_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/About.vue\\nvar About_disposed = false\\nfunction About_injectStyle (context) {\\n  if (About_disposed) return\\n  __webpack_require__(20)\\n}\\n/* script */\\nvar About_vue_script_ = null\\n/* template */\\n\\n/* template functional */\\nvar About_vue_template_functional_ = false\\n/* styles */\\nvar About_vue_styles_ = About_injectStyle\\n/* scopeId */\\nvar About_vue_scopeId_ = null\\n/* moduleIdentifier (server only) */\\nvar About_vue_module_identifier_ = null\\n\\nvar About_Component = normalizeComponent(\\n  About_vue_script_,\\n  About_render,\\n  About_staticRenderFns,\\n  About_vue_template_functional_,\\n  About_vue_styles_,\\n  About_vue_scopeId_,\\n  About_vue_module_identifier_\\n)\\nAbout_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\About.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-728ee9a6\\\", About_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-728ee9a6\\\", About_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    About_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var About = (About_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Login.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Login = ({\\n    name: 'Login',\\n    data: function data() {\\n        return {\\n            input: {\\n                username: \\\"\\\",\\n                password: \\\"\\\"\\n            }\\n        };\\n    },\\n\\n    methods: {\\n        login: function login() {\\n            if (this.input.username != \\\"\\\" && this.input.password != \\\"\\\") {\\n                if (this.input.username == this.$parent.mockAccount.username && this.input.password == this.$parent.mockAccount.password) {\\n                    this.$emit(\\\"authenticated\\\", true);\\n                    //  localStorage.setItem('user',input.username)\\n                    this.$router.replace({ name: \\\"secure\\\" });\\n                } else {\\n                    console.log(\\\"The username and / or password is incorrect\\\");\\n                }\\n            } else {\\n                console.log(\\\"A username and password must be present\\\");\\n            }\\n        }\\n    }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-9fcfedee\\\",\\\"hasScoped\\\":true,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Login.vue\\nvar Login_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\\"div\\\", { attrs: { id: \\\"Login\\\" } }, [\\n    _c(\\n      \\\"div\\\",\\n      { staticClass: \\\"formulario\\\" },\\n      [\\n        _c(\\\"h1\\\", [_vm._v(\\\"Inicio de sesin\\\")]),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"input\\\", {\\n          directives: [\\n            {\\n              name: \\\"model\\\",\\n              rawName: \\\"v-model\\\",\\n              value: _vm.input.username,\\n              expression: \\\"input.username\\\"\\n            }\\n          ],\\n          attrs: { type: \\\"text\\\", name: \\\"username\\\", placeholder: \\\"Usuario\\\" },\\n          domProps: { value: _vm.input.username },\\n          on: {\\n            input: function($event) {\\n              if ($event.target.composing) {\\n                return\\n              }\\n              _vm.$set(_vm.input, \\\"username\\\", $event.target.value)\\n            }\\n          }\\n        }),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"input\\\", {\\n          directives: [\\n            {\\n              name: \\\"model\\\",\\n              rawName: \\\"v-model\\\",\\n              value: _vm.input.password,\\n              expression: \\\"input.password\\\"\\n            }\\n          ],\\n          attrs: {\\n            type: \\\"password\\\",\\n            name: \\\"password\\\",\\n            placeholder: \\\"Contrasea\\\"\\n          },\\n          domProps: { value: _vm.input.password },\\n          on: {\\n            input: function($event) {\\n              if ($event.target.composing) {\\n                return\\n              }\\n              _vm.$set(_vm.input, \\\"password\\\", $event.target.value)\\n            }\\n          }\\n        }),\\n        _vm._v(\\\" \\\"),\\n        _c(\\n          \\\"button\\\",\\n          {\\n            attrs: { type: \\\"button\\\" },\\n            on: {\\n              click: function($event) {\\n                _vm.login()\\n              }\\n            }\\n          },\\n          [_vm._v(\\\"Login\\\")]\\n        ),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"router-link\\\", { attrs: { to: \\\"signup\\\" } }, [_vm._v(\\\"Crear cuenta\\\")])\\n      ],\\n      1\\n    )\\n  ])\\n}\\nvar Login_staticRenderFns = []\\nLogin_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-9fcfedee\\\", { render: Login_render, staticRenderFns: Login_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/Login.vue\\nvar Login_disposed = false\\nfunction Login_injectStyle (context) {\\n  if (Login_disposed) return\\n  __webpack_require__(19)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Login_vue_template_functional_ = false\\n/* styles */\\nvar Login_vue_styles_ = Login_injectStyle\\n/* scopeId */\\nvar Login_vue_scopeId_ = \\\"data-v-9fcfedee\\\"\\n/* moduleIdentifier (server only) */\\nvar Login_vue_module_identifier_ = null\\n\\nvar Login_Component = normalizeComponent(\\n  Login,\\n  Login_render,\\n  Login_staticRenderFns,\\n  Login_vue_template_functional_,\\n  Login_vue_styles_,\\n  Login_vue_scopeId_,\\n  Login_vue_module_identifier_\\n)\\nLogin_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\Login.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-9fcfedee\\\", Login_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-9fcfedee\\\", Login_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Login_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var components_Login = (Login_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Secure.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Secure = ({\\n    name: 'Secure',\\n    data: function data() {\\n        return {};\\n    }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-1b3ea807\\\",\\\"hasScoped\\\":true,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Secure.vue\\nvar Secure_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _vm._m(0)\\n}\\nvar Secure_staticRenderFns = [\\n  function() {\\n    var _vm = this\\n    var _h = _vm.$createElement\\n    var _c = _vm._self._c || _h\\n    return _c(\\\"div\\\", { attrs: { id: \\\"secure\\\" } }, [\\n      _c(\\\"h1\\\", [_vm._v(\\\"Secure Area\\\")]),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"p\\\", [_vm._v(\\\"\\\\n            This is a secure area\\\\n        \\\")])\\n    ])\\n  }\\n]\\nSecure_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-1b3ea807\\\", { render: Secure_render, staticRenderFns: Secure_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/Secure.vue\\nvar Secure_disposed = false\\nfunction Secure_injectStyle (context) {\\n  if (Secure_disposed) return\\n  __webpack_require__(18)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Secure_vue_template_functional_ = false\\n/* styles */\\nvar Secure_vue_styles_ = Secure_injectStyle\\n/* scopeId */\\nvar Secure_vue_scopeId_ = \\\"data-v-1b3ea807\\\"\\n/* moduleIdentifier (server only) */\\nvar Secure_vue_module_identifier_ = null\\n\\nvar Secure_Component = normalizeComponent(\\n  Secure,\\n  Secure_render,\\n  Secure_staticRenderFns,\\n  Secure_vue_template_functional_,\\n  Secure_vue_styles_,\\n  Secure_vue_scopeId_,\\n  Secure_vue_module_identifier_\\n)\\nSecure_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\Secure.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-1b3ea807\\\", Secure_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-1b3ea807\\\", Secure_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Secure_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var components_Secure = (Secure_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Signup.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Signup = ({\\n    name: 'register',\\n    data: function data() {\\n        return {\\n            input: {\\n                username: \\\"\\\",\\n                email: \\\"\\\",\\n                password: \\\"\\\",\\n                tipo: \\\"\\\"\\n\\n            }\\n        };\\n    },\\n\\n    methods: {\\n        signup: function signup() {\\n            if (this.input.username != \\\"\\\" && this.input.password != \\\"\\\") {\\n                if (this.input.username == this.$parent.mockAccount.username && this.input.password == this.$parent.mockAccount.password) {\\n                    this.$emit(\\\"authenticated\\\", true);\\n                    //  localStorage.setItem('user',input.username)\\n                    this.$router.replace({ name: \\\"secure\\\" });\\n                } else {\\n                    console.log(\\\"The username and / or password is incorrect\\\");\\n                }\\n            } else {\\n                console.log(\\\"A username and password must be present\\\");\\n            }\\n        }\\n    }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-c179f5b0\\\",\\\"hasScoped\\\":true,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Signup.vue\\nvar Signup_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\\"div\\\", { attrs: { id: \\\"register\\\" } }, [\\n    _c(\\\"div\\\", { staticClass: \\\"formulario\\\" }, [\\n      _c(\\\"h1\\\", [_vm._v(\\\"Crear cuenta\\\")]),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"input\\\", {\\n        directives: [\\n          {\\n            name: \\\"model\\\",\\n            rawName: \\\"v-model\\\",\\n            value: _vm.input.username,\\n            expression: \\\"input.username\\\"\\n          }\\n        ],\\n        attrs: { type: \\\"text\\\", name: \\\"username\\\", placeholder: \\\"Usuario\\\" },\\n        domProps: { value: _vm.input.username },\\n        on: {\\n          input: function($event) {\\n            if ($event.target.composing) {\\n              return\\n            }\\n            _vm.$set(_vm.input, \\\"username\\\", $event.target.value)\\n          }\\n        }\\n      }),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"input\\\", {\\n        directives: [\\n          {\\n            name: \\\"model\\\",\\n            rawName: \\\"v-model\\\",\\n            value: _vm.input.email,\\n            expression: \\\"input.email\\\"\\n          }\\n        ],\\n        attrs: { type: \\\"password\\\", name: \\\"password\\\", placeholder: \\\"Email\\\" },\\n        domProps: { value: _vm.input.email },\\n        on: {\\n          input: function($event) {\\n            if ($event.target.composing) {\\n              return\\n            }\\n            _vm.$set(_vm.input, \\\"email\\\", $event.target.value)\\n          }\\n        }\\n      }),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"input\\\", {\\n        directives: [\\n          {\\n            name: \\\"model\\\",\\n            rawName: \\\"v-model\\\",\\n            value: _vm.input.password,\\n            expression: \\\"input.password\\\"\\n          }\\n        ],\\n        attrs: { type: \\\"text\\\", name: \\\"username\\\", placeholder: \\\"Contrasea\\\" },\\n        domProps: { value: _vm.input.password },\\n        on: {\\n          input: function($event) {\\n            if ($event.target.composing) {\\n              return\\n            }\\n            _vm.$set(_vm.input, \\\"password\\\", $event.target.value)\\n          }\\n        }\\n      }),\\n      _vm._v(\\\" \\\"),\\n      _c(\\\"input\\\", {\\n        directives: [\\n          {\\n            name: \\\"model\\\",\\n            rawName: \\\"v-model\\\",\\n            value: _vm.input.tipo,\\n            expression: \\\"input.tipo\\\"\\n          }\\n        ],\\n        attrs: { type: \\\"password\\\", name: \\\"password\\\", placeholder: \\\"Tipo\\\" },\\n        domProps: { value: _vm.input.tipo },\\n        on: {\\n          input: function($event) {\\n            if ($event.target.composing) {\\n              return\\n            }\\n            _vm.$set(_vm.input, \\\"tipo\\\", $event.target.value)\\n          }\\n        }\\n      }),\\n      _vm._v(\\\" \\\"),\\n      _c(\\n        \\\"button\\\",\\n        {\\n          attrs: { type: \\\"button\\\" },\\n          on: {\\n            click: function($event) {\\n              _vm.signup()\\n            }\\n          }\\n        },\\n        [_vm._v(\\\"Registrar\\\")]\\n      )\\n    ])\\n  ])\\n}\\nvar Signup_staticRenderFns = []\\nSignup_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-c179f5b0\\\", { render: Signup_render, staticRenderFns: Signup_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/Signup.vue\\nvar Signup_disposed = false\\nfunction Signup_injectStyle (context) {\\n  if (Signup_disposed) return\\n  __webpack_require__(17)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Signup_vue_template_functional_ = false\\n/* styles */\\nvar Signup_vue_styles_ = Signup_injectStyle\\n/* scopeId */\\nvar Signup_vue_scopeId_ = \\\"data-v-c179f5b0\\\"\\n/* moduleIdentifier (server only) */\\nvar Signup_vue_module_identifier_ = null\\n\\nvar Signup_Component = normalizeComponent(\\n  Signup,\\n  Signup_render,\\n  Signup_staticRenderFns,\\n  Signup_vue_template_functional_,\\n  Signup_vue_styles_,\\n  Signup_vue_scopeId_,\\n  Signup_vue_module_identifier_\\n)\\nSignup_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\Signup.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-c179f5b0\\\", Signup_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-c179f5b0\\\", Signup_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Signup_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var components_Signup = (Signup_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/layout/Card.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n/* harmony default export */ var Card = ({\\n  props: {\\n    med: { type: Object, required: true }\\n  }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-fe3db03c\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/layout/Card.vue\\nvar Card_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\\"div\\\", [\\n    _c(\\n      \\\"div\\\",\\n      { staticClass: \\\"medico\\\" },\\n      [\\n        _c(\\\"router-link\\\", { attrs: { to: \\\"aboutmed\\\" } }, [\\n          _vm._v(\\\"Quienes somos\\\")\\n        ]),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"img\\\", {\\n          attrs: {\\n            src: __webpack_require__(53),\\n            alt: \\\"Imagen invitado\\\"\\n          }\\n        }),\\n        _vm._v(\\\" \\\"),\\n        _c(\\\"p\\\", [_vm._v(_vm._s(_vm.med.nombre))])\\n      ],\\n      1\\n    )\\n  ])\\n}\\nvar Card_staticRenderFns = []\\nCard_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-fe3db03c\\\", { render: Card_render, staticRenderFns: Card_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/layout/Card.vue\\nvar Card_disposed = false\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Card_vue_template_functional_ = false\\n/* styles */\\nvar Card_vue_styles_ = null\\n/* scopeId */\\nvar Card_vue_scopeId_ = null\\n/* moduleIdentifier (server only) */\\nvar Card_vue_module_identifier_ = null\\n\\nvar Card_Component = normalizeComponent(\\n  Card,\\n  Card_render,\\n  Card_staticRenderFns,\\n  Card_vue_template_functional_,\\n  Card_vue_styles_,\\n  Card_vue_scopeId_,\\n  Card_vue_module_identifier_\\n)\\nCard_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\layout\\\\\\\\Card.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-fe3db03c\\\", Card_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-fe3db03c\\\", Card_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Card_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var layout_Card = (Card_Component.exports);\\n\\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Portfolio.vue\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n\\n/* harmony default export */ var Portfolio = ({\\n  name: 'servicios',\\n  components: { stmed: layout_Card },\\n  data: function data() {\\n    return {\\n      medicos: [{ \\\"nombre\\\": \\\"marbel\\\", \\\"especialidad\\\": \\\"dermatologia\\\", \\\"imagen\\\": \\\"../assets/logo.png\\\" }]\\n    };\\n  }\\n});\\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\\\"id\\\":\\\"data-v-c8b3d930\\\",\\\"hasScoped\\\":true,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Portfolio.vue\\nvar Portfolio_render = function() {\\n  var _vm = this\\n  var _h = _vm.$createElement\\n  var _c = _vm._self._c || _h\\n  return _c(\\n    \\\"div\\\",\\n    { attrs: { id: \\\"servicios\\\" } },\\n    [\\n      _c(\\\"h1\\\", [_vm._v(\\\"Hola\\\")]),\\n      _vm._v(\\\" \\\"),\\n      _vm._l(_vm.medicos, function(m) {\\n        return _c(\\\"div\\\", { key: m }, [_c(\\\"stmed\\\", { attrs: { med: m } })], 1)\\n      })\\n    ],\\n    2\\n  )\\n}\\nvar Portfolio_staticRenderFns = []\\nPortfolio_render._withStripped = true\\n\\nif (true) {\\n  module.hot.accept()\\n  if (module.hot.data) {\\n    __webpack_require__(0)      .rerender(\\\"data-v-c8b3d930\\\", { render: Portfolio_render, staticRenderFns: Portfolio_staticRenderFns })\\n  }\\n}\\n// CONCATENATED MODULE: ./src/components/Portfolio.vue\\nvar Portfolio_disposed = false\\nfunction Portfolio_injectStyle (context) {\\n  if (Portfolio_disposed) return\\n  __webpack_require__(55)\\n}\\n/* script */\\n\\n\\n/* template */\\n\\n/* template functional */\\nvar Portfolio_vue_template_functional_ = false\\n/* styles */\\nvar Portfolio_vue_styles_ = Portfolio_injectStyle\\n/* scopeId */\\nvar Portfolio_vue_scopeId_ = \\\"data-v-c8b3d930\\\"\\n/* moduleIdentifier (server only) */\\nvar Portfolio_vue_module_identifier_ = null\\n\\nvar Portfolio_Component = normalizeComponent(\\n  Portfolio,\\n  Portfolio_render,\\n  Portfolio_staticRenderFns,\\n  Portfolio_vue_template_functional_,\\n  Portfolio_vue_styles_,\\n  Portfolio_vue_scopeId_,\\n  Portfolio_vue_module_identifier_\\n)\\nPortfolio_Component.options.__file = \\\"src\\\\\\\\components\\\\\\\\Portfolio.vue\\\"\\n\\n/* hot reload */\\nif (true) {(function () {\\n  var hotAPI = __webpack_require__(0)\\n  hotAPI.install(__webpack_require__(1), false)\\n  if (!hotAPI.compatible) return\\n  module.hot.accept()\\n  if (!module.hot.data) {\\n    hotAPI.createRecord(\\\"data-v-c8b3d930\\\", Portfolio_Component.options)\\n  } else {\\n    hotAPI.reload(\\\"data-v-c8b3d930\\\", Portfolio_Component.options)\\n  }\\n  module.hot.dispose(function (data) {\\n    Portfolio_disposed = true\\n  })\\n})()}\\n\\n/* harmony default export */ var components_Portfolio = (Portfolio_Component.exports);\\n\\n// CONCATENATED MODULE: ./src/routes.js\\n\\n\\n\\n\\n\\n\\n\\n\\nvar routes = [{ path: '/', component: components_Search, name: 'search' }, { path: '/about', component: About, name: 'about' }, { path: '/login', component: components_Login, name: 'login' }, { path: '/signup', component: components_Signup, name: 'register' }, { path: '/services', component: components_Portfolio, name: 'services' }, { path: '/med', component: layout_Card, name: 'med' }, { path: '/secure', component: components_Secure, name: 'secure' }];\\n\\n/* harmony default export */ var src_routes = (routes);\\n// CONCATENATED MODULE: ./src/main.js\\n\\n\\n\\n\\n\\n\\nvue_esm[\\\"default\\\"].use(vue_router_esm);\\nvue_esm[\\\"default\\\"].use(vue_resource_esm);\\nvar router = new vue_router_esm({ routes: src_routes });\\nnew vue_esm[\\\"default\\\"]({\\n    el: '#app',\\n    render: function render(h) {\\n        return h(src_App);\\n    },\\n    router: router\\n});\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzPzhjNGYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5lc20uanM/MjhkZCIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvbGF5b3V0L0hlYWRlci52dWU/NmZjMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvSGVhZGVyLnZ1ZT85Y2Y0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzPzI0NTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbGF5b3V0L0hlYWRlci52dWU/MjUwZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvRm9vdGVyLnZ1ZT83ODIxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2xheW91dC9Gb290ZXIudnVlPzMxZDYiLCJ3ZWJwYWNrOi8vL3NyYy9BcHAudnVlP2M2NWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/ZDEwYiIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9iYmJiIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9TZWFyY2gudnVlPzYxZjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU2VhcmNoLnZ1ZT9iYTg2Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1NlYXJjaC52dWU/ZWYxZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BYm91dC52dWU/NWRjZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BYm91dC52dWU/MjM5MCIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTG9naW4udnVlPzkwMTgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTG9naW4udnVlPzcxZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTG9naW4udnVlP2Y2MmEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1NlY3VyZS52dWU/YjA1YSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TZWN1cmUudnVlPzE3ZDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU2VjdXJlLnZ1ZT8zMDAxIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9TaWdudXAudnVlPzYwNmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU2lnbnVwLnZ1ZT85YzdkIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1NpZ251cC52dWU/NDk2MSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvbGF5b3V0L0NhcmQudnVlPzBhOGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbGF5b3V0L0NhcmQudnVlPzhiNjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbGF5b3V0L0NhcmQudnVlP2M0YmMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1BvcnRmb2xpby52dWU/ZWNhMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW8udnVlP2NkM2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUG9ydGZvbGlvLnZ1ZT81MjFmIiwid2VicGFjazovLy8uL3NyYy9yb3V0ZXMuanM/NTY2NSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbInJvdXRlcyIsInBhdGgiLCJjb21wb25lbnQiLCJTZWFyY2giLCJuYW1lIiwiQWJvdXQiLCJMb2dpbiIsIlJlZ2lzdGVyIiwiU2VydmljZXMiLCJNZWQiLCJTZWN1cmUiLCJWdWUiLCJ1c2UiLCJWdWVSb3V0ZXIiLCJWdWVSZXNvdXJjZSIsInJvdXRlciIsImVsIiwicmVuZGVyIiwiaCIsIkFwcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQW1ELEVBQUUsRUFFeEQ7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFNMUM7QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLFlBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLHVCQUF1QixxQkFBcUIsRUFBRTtBQUNqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLHVDQUF1QyxpQkFBaUIsRUFBRTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDZDQUE2QztBQUM3QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQSw0QkFBNEIsd0JBQXdCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUIsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPLHVCQUF1QixPQUFPO0FBQ3pFOztBQUVBLG1DQUFtQyxPQUFPLHVCQUF1QixPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsR0FBRyxlQUFlO0FBQ2hELEdBQUc7QUFDSCxRQUFRLEtBQXFDLEVBQUUsRUFFMUM7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQU8xQzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFXMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSxLQUFpRCxFQUFFLEVBTTdEO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLGFBTTFDO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLFVBQVUsS0FBcUMsRUFBRSxFQUVqRDtBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsS0FBcUMsRUFBRSxFQUUxQztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBLGdDQUFnQyxzQkFBc0IsRUFBRTtBQUN4RCw2QkFBNkIsaUJBQWlCLEVBQUU7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBLFVBQVUsS0FBcUMsRUFBRSxFQUkxQztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUMsRUFBRSxFQUUxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFVBQVUsS0FBcUMsRUFBRSxFQUUxQztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUM7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxZQUFZLEtBQXFDLEVBQUUsRUFFMUM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QyxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVSxZQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUU7QUFDUixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsRUFBRTtBQUMxRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVMsRUFBRTtBQUM3RDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVMsRUFBRTtBQUMxRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQixFQUFFO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLEVBQUU7QUFDdEQsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDLEVBQUU7QUFDbEY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUMsRUFBRSxFQUUxQztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQixxQkFBcUI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsWUFBb0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlLDREQUFTLEVBQUM7OztBQ3pqRnpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwrQkFBYztBQUNsQjtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwwQkFBUzs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMscUJBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix5QkFBeUIsUUFBUSxlQUFlO0FB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QUFoRCxFQUxXLEVBTVgsRUFBRUgsTUFBTSxNQUFSLEVBQWdCQyxXQUFXTyxXQUEzQixFQUFnQ0wsTUFBTSxLQUF0QyxFQU5XLEVBT1gsRUFBRUgsTUFBTSxTQUFSLEVBQW1CQyxXQUFXUSxpQkFBOUIsRUFBc0NOLE1BQU0sUUFBNUMsRUFQVyxDQUFmOztBQVVlSixxREFBZixFOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBVyxrQkFBR0EsQ0FBQ0MsR0FBSixDQUFRQyxjQUFSO0FBQ0FGLGtCQUFHQSxDQUFDQyxHQUFKLENBQVFFLGdCQUFSO0FBQ0EsSUFBTUMsU0FBUyxJQUFJRixjQUFKLENBQWMsRUFBRWIsa0JBQUYsRUFBZCxDQUFmO0FBQ0EsSUFBSVcsa0JBQUosQ0FBUTtBQUNKSyxRQUFJLE1BREE7QUFFSkMsWUFBUTtBQUFBLGVBQUtDLEVBQUVDLE9BQUYsQ0FBTDtBQUFBLEtBRko7QUFHSko7QUFISSxDQUFSIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAgKiB2dWUtcm91dGVyIHYzLjAuMlxyXG4gICogKGMpIDIwMTggRXZhbiBZb3VcclxuICAqIEBsaWNlbnNlIE1JVFxyXG4gICovXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xyXG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYikge1xyXG4gIGZvciAodmFyIGtleSBpbiBiKSB7XHJcbiAgICBhW2tleV0gPSBiW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBhXHJcbn1cclxuXHJcbnZhciBWaWV3ID0ge1xyXG4gIG5hbWU6ICdSb3V0ZXJWaWV3JyxcclxuICBmdW5jdGlvbmFsOiB0cnVlLFxyXG4gIHByb3BzOiB7XHJcbiAgICBuYW1lOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XHJcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XHJcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcclxuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XHJcblxyXG4gICAgLy8gdXNlZCBieSBkZXZ0b29scyB0byBkaXNwbGF5IGEgcm91dGVyLXZpZXcgYmFkZ2VcclxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XHJcblxyXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXHJcbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcclxuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xyXG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xyXG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcclxuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxyXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cclxuICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcclxuICAgICAgICBkZXB0aCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XHJcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xyXG4gICAgfVxyXG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcclxuXHJcbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxyXG4gICAgaWYgKGluYWN0aXZlKSB7XHJcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xyXG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxyXG4gICAgaWYgKCFtYXRjaGVkKSB7XHJcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcclxuICAgICAgcmV0dXJuIGgoKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcclxuXHJcbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcclxuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3MgaW5qZWN0ZWQgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XHJcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXHJcbiAgICAgIHZhciBjdXJyZW50ID0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV07XHJcbiAgICAgIGlmIChcclxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxyXG4gICAgICAgICghdmFsICYmIGN1cnJlbnQgPT09IHZtKVxyXG4gICAgICApIHtcclxuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsc28gcmVnaXN0ZXIgaW5zdGFuY2UgaW4gcHJlcGF0Y2ggaG9va1xyXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXHJcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xyXG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZXNvbHZlIHByb3BzXHJcbiAgICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xyXG4gICAgaWYgKHByb3BzVG9QYXNzKSB7XHJcbiAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cclxuICAgICAgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gZXh0ZW5kKHt9LCBwcm9wc1RvUGFzcyk7XHJcbiAgICAgIC8vIHBhc3Mgbm9uLWRlY2xhcmVkIHByb3BzIGFzIGF0dHJzXHJcbiAgICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb1Bhc3MpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudC5wcm9wcyB8fCAhKGtleSBpbiBjb21wb25lbnQucHJvcHMpKSB7XHJcbiAgICAgICAgICBhdHRyc1trZXldID0gcHJvcHNUb1Bhc3Nba2V5XTtcclxuICAgICAgICAgIGRlbGV0ZSBwcm9wc1RvUGFzc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcclxuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcclxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XHJcbiAgICAgIHJldHVyblxyXG4gICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgcmV0dXJuIGNvbmZpZ1xyXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxyXG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxyXG4gICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBcIiArXHJcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xyXG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XHJcbnZhciBjb21tYVJFID0gLyUyQy9nO1xyXG5cclxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxyXG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxyXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xyXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcclxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcclxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xyXG5cclxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXHJcbiAgcXVlcnksXHJcbiAgZXh0cmFRdWVyeSxcclxuICBfcGFyc2VRdWVyeVxyXG4pIHtcclxuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcclxuXHJcbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcclxuICB2YXIgcGFyc2VkUXVlcnk7XHJcbiAgdHJ5IHtcclxuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcclxuICAgIHBhcnNlZFF1ZXJ5ID0ge307XHJcbiAgfVxyXG4gIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XHJcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gcGFyc2VkUXVlcnlcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcclxuICB2YXIgcmVzID0ge307XHJcblxyXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XHJcblxyXG4gIGlmICghcXVlcnkpIHtcclxuICAgIHJldHVybiByZXNcclxuICB9XHJcblxyXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XHJcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xyXG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcclxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxyXG4gICAgICA6IG51bGw7XHJcblxyXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmVzW2tleV0gPSB2YWw7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XHJcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcclxuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xyXG5cclxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gJydcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xyXG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxyXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KS5qb2luKCcmJykgOiBudWxsO1xyXG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcclxuICByZWNvcmQsXHJcbiAgbG9jYXRpb24sXHJcbiAgcmVkaXJlY3RlZEZyb20sXHJcbiAgcm91dGVyXHJcbikge1xyXG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcclxuXHJcbiAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgfHwge307XHJcbiAgdHJ5IHtcclxuICAgIHF1ZXJ5ID0gY2xvbmUocXVlcnkpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIHZhciByb3V0ZSA9IHtcclxuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXHJcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcclxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxyXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcclxuICAgIHF1ZXJ5OiBxdWVyeSxcclxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxyXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSQkMSksXHJcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cclxuICB9O1xyXG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xyXG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xyXG4gIH1cclxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcclxufVxyXG5cclxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdmFsdWUubWFwKGNsb25lKVxyXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgIHJlc1trZXldID0gY2xvbmUodmFsdWVba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2YWx1ZVxyXG4gIH1cclxufVxyXG5cclxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxyXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XHJcbiAgcGF0aDogJy8nXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xyXG4gIHZhciByZXMgPSBbXTtcclxuICB3aGlsZSAocmVjb3JkKSB7XHJcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xyXG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXHJcbiAgcmVmLFxyXG4gIF9zdHJpbmdpZnlRdWVyeVxyXG4pIHtcclxuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xyXG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcclxuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcclxuXHJcbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcclxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XHJcbiAgaWYgKGIgPT09IFNUQVJUKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYlxyXG4gIH0gZWxzZSBpZiAoIWIpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXHJcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXHJcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcclxuICAgIClcclxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXHJcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXHJcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcclxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXHJcbiAgICApXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xyXG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xyXG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xyXG5cclxuICAvLyBoYW5kbGUgbnVsbCB2YWx1ZSAjMTU2NlxyXG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA9PT0gYiB9XHJcbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciBhVmFsID0gYVtrZXldO1xyXG4gICAgdmFyIGJWYWwgPSBiW2tleV07XHJcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcclxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xyXG4gIHJldHVybiAoXHJcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcclxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcclxuICAgICkgPT09IDAgJiZcclxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcclxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XHJcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xyXG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXHJcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcclxudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XHJcblxyXG52YXIgTGluayA9IHtcclxuICBuYW1lOiAnUm91dGVyTGluaycsXHJcbiAgcHJvcHM6IHtcclxuICAgIHRvOiB7XHJcbiAgICAgIHR5cGU6IHRvVHlwZXMsXHJcbiAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgdGFnOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgZGVmYXVsdDogJ2EnXHJcbiAgICB9LFxyXG4gICAgZXhhY3Q6IEJvb2xlYW4sXHJcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXHJcbiAgICByZXBsYWNlOiBCb29sZWFuLFxyXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGV2ZW50OiB7XHJcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXHJcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcclxuICAgIH1cclxuICB9LFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xyXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcclxuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XHJcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XHJcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XHJcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xyXG5cclxuICAgIHZhciBjbGFzc2VzID0ge307XHJcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XHJcbiAgICB2YXIgZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtFeGFjdEFjdGl2ZUNsYXNzO1xyXG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXHJcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcclxuICAgICAgPyAncm91dGVyLWxpbmstYWN0aXZlJ1xyXG4gICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xyXG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxyXG4gICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXHJcbiAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcclxuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxyXG4gICAgICA/IGFjdGl2ZUNsYXNzRmFsbGJhY2tcclxuICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xyXG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxyXG4gICAgICA/IGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFja1xyXG4gICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcclxuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxyXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpXHJcbiAgICAgIDogcm91dGU7XHJcblxyXG4gICAgY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXSA9IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xyXG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XHJcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxyXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcclxuXHJcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XHJcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcclxuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgIGNsYXNzOiBjbGFzc2VzXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XHJcbiAgICAgIGRhdGEub24gPSBvbjtcclxuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxyXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcclxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xyXG4gICAgICAgIGFEYXRhLm9uID0gb247XHJcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcclxuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxyXG4gICAgICAgIGRhdGEub24gPSBvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xyXG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXHJcbiAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxyXG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXHJcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxyXG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXHJcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cclxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXHJcbiAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XHJcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxyXG4gIH1cclxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXHJcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcclxuICBpZiAoY2hpbGRyZW4pIHtcclxuICAgIHZhciBjaGlsZDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkXHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgX1Z1ZTtcclxuXHJcbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xyXG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCAmJiBfVnVlID09PSBWdWUpIHsgcmV0dXJuIH1cclxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XHJcblxyXG4gIF9WdWUgPSBWdWU7XHJcblxyXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XHJcblxyXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XHJcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcclxuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XHJcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5taXhpbih7XHJcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XHJcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcclxuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcclxuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcclxuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcclxuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9ICh0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50Ll9yb3V0ZXJSb290KSB8fCB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xyXG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxyXG4gIH0pO1xyXG5cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cclxuICB9KTtcclxuXHJcbiAgVnVlLmNvbXBvbmVudCgnUm91dGVyVmlldycsIFZpZXcpO1xyXG4gIFZ1ZS5jb21wb25lbnQoJ1JvdXRlckxpbmsnLCBMaW5rKTtcclxuXHJcbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXHJcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxyXG4gIHJlbGF0aXZlLFxyXG4gIGJhc2UsXHJcbiAgYXBwZW5kXHJcbikge1xyXG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XHJcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XHJcbiAgICByZXR1cm4gcmVsYXRpdmVcclxuICB9XHJcblxyXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xyXG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxyXG4gIH1cclxuXHJcbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xyXG5cclxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcclxuICAvLyAtIG5vdCBhcHBlbmRpbmdcclxuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxyXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xyXG4gICAgc3RhY2sucG9wKCk7XHJcbiAgfVxyXG5cclxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcclxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcclxuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XHJcbiAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcclxuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXHJcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xyXG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhY2suam9pbignLycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xyXG4gIHZhciBoYXNoID0gJyc7XHJcbiAgdmFyIHF1ZXJ5ID0gJyc7XHJcblxyXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcclxuICBpZiAoaGFzaEluZGV4ID49IDApIHtcclxuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XHJcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcclxuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XHJcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xyXG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aDogcGF0aCxcclxuICAgIHF1ZXJ5OiBxdWVyeSxcclxuICAgIGhhc2g6IGhhc2hcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xyXG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXHJcbn1cclxuXHJcbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxyXG4gKi9cclxudmFyIHBhdGhUb1JlZ2V4cF8xID0gcGF0aFRvUmVnZXhwO1xyXG52YXIgcGFyc2VfMSA9IHBhcnNlO1xyXG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcclxudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XHJcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cclxuICpcclxuICogQHR5cGUge1JlZ0V4cH1cclxuICovXHJcbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xyXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXHJcbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cclxuICAnKFxcXFxcXFxcLiknLFxyXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XHJcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcclxuICAvL1xyXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cclxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXHJcbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxyXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcclxuXS5qb2luKCd8JyksICdnJyk7XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcclxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshQXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XHJcbiAgdmFyIHRva2VucyA9IFtdO1xyXG4gIHZhciBrZXkgPSAwO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIHBhdGggPSAnJztcclxuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xyXG4gIHZhciByZXM7XHJcblxyXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XHJcbiAgICB2YXIgbSA9IHJlc1swXTtcclxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xyXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcclxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xyXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcclxuXHJcbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cclxuICAgIGlmIChlc2NhcGVkKSB7XHJcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XHJcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xyXG4gICAgdmFyIG5hbWUgPSByZXNbM107XHJcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcclxuICAgIHZhciBncm91cCA9IHJlc1s1XTtcclxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcclxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcclxuXHJcbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxyXG4gICAgaWYgKHBhdGgpIHtcclxuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XHJcbiAgICAgIHBhdGggPSAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XHJcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xyXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xyXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xyXG5cclxuICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcclxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXHJcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxyXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXHJcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxyXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxyXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcclxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXHJcbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xyXG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXHJcbiAgaWYgKHBhdGgpIHtcclxuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRva2Vuc1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcclxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXHJcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xyXG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xyXG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ31cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xyXG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXHJcbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XHJcblxyXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcclxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcclxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHBhdGggKz0gdG9rZW47XHJcblxyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XHJcbiAgICAgIHZhciBzZWdtZW50O1xyXG5cclxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcclxuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxyXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcclxuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XHJcblxyXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcclxuXHJcbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGF0aFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcclxufVxyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcclxuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXHJcbiAqXHJcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XHJcbiAgcmUua2V5cyA9IGtleXM7XHJcbiAgcmV0dXJuIHJlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xyXG59XHJcblxyXG4vKipcclxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXHJcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XHJcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cclxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XHJcblxyXG4gIGlmIChncm91cHMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGtleXMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogaSxcclxuICAgICAgICBwcmVmaXg6IG51bGwsXHJcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxyXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcclxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxyXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxyXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcclxuICAgICAgICBwYXR0ZXJuOiBudWxsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcclxuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xyXG4gIHZhciBwYXJ0cyA9IFtdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xyXG5cclxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxyXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXHJcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxyXG59XHJcblxyXG4vKipcclxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cclxuICpcclxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcclxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xyXG4gIGlmICghaXNhcnJheShrZXlzKSkge1xyXG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XHJcbiAgICBrZXlzID0gW107XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xyXG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XHJcbiAgdmFyIHJvdXRlID0gJyc7XHJcblxyXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xyXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcclxuXHJcbiAgICAgIGtleXMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XHJcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcclxuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcclxuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcclxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcclxuXHJcbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cclxuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcclxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XHJcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxyXG4gIGlmICghc3RyaWN0KSB7XHJcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCkge1xyXG4gICAgcm91dGUgKz0gJyQnO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xyXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cclxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcclxuICB9XHJcblxyXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcclxufVxyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICpcclxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcclxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxyXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cclxuICpcclxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXHJcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcclxuICogQHJldHVybiB7IVJlZ0V4cH1cclxuICovXHJcbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xyXG4gIGlmICghaXNhcnJheShrZXlzKSkge1xyXG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XHJcbiAgICBrZXlzID0gW107XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxyXG4gIH1cclxuXHJcbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcclxuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcclxufVxyXG5wYXRoVG9SZWdleHBfMS5wYXJzZSA9IHBhcnNlXzE7XHJcbnBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUgPSBjb21waWxlXzE7XHJcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XHJcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXHJcbiAgcGF0aCxcclxuICBwYXJhbXMsXHJcbiAgcm91dGVNc2dcclxuKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBmaWxsZXIgPVxyXG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcclxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IHBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUocGF0aCkpO1xyXG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJydcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxyXG4gIHJvdXRlcyxcclxuICBvbGRQYXRoTGlzdCxcclxuICBvbGRQYXRoTWFwLFxyXG4gIG9sZE5hbWVNYXBcclxuKSB7XHJcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxyXG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcclxuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XHJcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcclxuICAgICAgbC0tO1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxyXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcclxuICAgIG5hbWVNYXA6IG5hbWVNYXBcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcclxuICBwYXRoTGlzdCxcclxuICBwYXRoTWFwLFxyXG4gIG5hbWVNYXAsXHJcbiAgcm91dGUsXHJcbiAgcGFyZW50LFxyXG4gIG1hdGNoQXNcclxuKSB7XHJcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xyXG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcclxuICAgIGFzc2VydChcclxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXHJcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXHJcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xyXG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoXHJcbiAgICBwYXRoLFxyXG4gICAgcGFyZW50LFxyXG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zdHJpY3RcclxuICApO1xyXG5cclxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xyXG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zZW5zaXRpdmUgPSByb3V0ZS5jYXNlU2Vuc2l0aXZlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlY29yZCA9IHtcclxuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxyXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcclxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcclxuICAgIGluc3RhbmNlczoge30sXHJcbiAgICBuYW1lOiBuYW1lLFxyXG4gICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxyXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxyXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxyXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcclxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXHJcbiAgICAgID8ge31cclxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXHJcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xyXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XHJcbiAgfTtcclxuXHJcbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XHJcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cclxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxyXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcclxuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXHJcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXHJcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xyXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcclxuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpXHJcbiAgICAgID8gcm91dGUuYWxpYXNcclxuICAgICAgOiBbcm91dGUuYWxpYXNdO1xyXG5cclxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcclxuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XHJcbiAgICAgICAgcGF0aDogYWxpYXMsXHJcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXHJcbiAgICAgIH07XHJcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxyXG4gICAgICAgIHBhdGhMaXN0LFxyXG4gICAgICAgIHBhdGhNYXAsXHJcbiAgICAgICAgbmFtZU1hcCxcclxuICAgICAgICBhbGlhc1JvdXRlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XHJcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcclxuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5hbWUpIHtcclxuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xyXG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xyXG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcclxuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBpbGVSb3V0ZVJlZ2V4IChwYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSB7XHJcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcclxuICAgICAga2V5c1trZXkubmFtZV0gPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiByZWdleFxyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChwYXRoLCBwYXJlbnQsIHN0cmljdCkge1xyXG4gIGlmICghc3RyaWN0KSB7IHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH1cclxuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cclxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxyXG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcclxuICByYXcsXHJcbiAgY3VycmVudCxcclxuICBhcHBlbmQsXHJcbiAgcm91dGVyXHJcbikge1xyXG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xyXG4gIC8vIG5hbWVkIHRhcmdldFxyXG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xyXG4gICAgcmV0dXJuIG5leHRcclxuICB9XHJcblxyXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xyXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcclxuICAgIG5leHQgPSBleHRlbmQoe30sIG5leHQpO1xyXG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XHJcbiAgICB2YXIgcGFyYW1zID0gZXh0ZW5kKGV4dGVuZCh7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XHJcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XHJcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcclxuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcclxuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XHJcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcclxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dFxyXG4gIH1cclxuXHJcbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcclxuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcclxuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxyXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXHJcbiAgICA6IGJhc2VQYXRoO1xyXG5cclxuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkoXHJcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxyXG4gICAgbmV4dC5xdWVyeSxcclxuICAgIHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5wYXJzZVF1ZXJ5XHJcbiAgKTtcclxuXHJcbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xyXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcclxuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXHJcbiAgICBwYXRoOiBwYXRoLFxyXG4gICAgcXVlcnk6IHF1ZXJ5LFxyXG4gICAgaGFzaDogaGFzaFxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxyXG4gIHJvdXRlcyxcclxuICByb3V0ZXJcclxuKSB7XHJcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XHJcbiAgdmFyIHBhdGhMaXN0ID0gcmVmLnBhdGhMaXN0O1xyXG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XHJcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcclxuXHJcbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcclxuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWF0Y2ggKFxyXG4gICAgcmF3LFxyXG4gICAgY3VycmVudFJvdXRlLFxyXG4gICAgcmVkaXJlY3RlZEZyb21cclxuICApIHtcclxuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcclxuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcclxuXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cclxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XHJcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlY29yZCkge1xyXG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xyXG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xyXG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBwYXRoID0gcGF0aExpc3RbaV07XHJcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcclxuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xyXG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQkMSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm8gbWF0Y2hcclxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWRpcmVjdCAoXHJcbiAgICByZWNvcmQsXHJcbiAgICBsb2NhdGlvblxyXG4gICkge1xyXG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XHJcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcclxuICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xyXG5cclxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xyXG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xyXG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xyXG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XHJcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XHJcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xyXG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XHJcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xyXG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xyXG5cclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxyXG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hdGNoKHtcclxuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcclxuICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcclxuICAgICAgICBoYXNoOiBoYXNoLFxyXG4gICAgICAgIHBhcmFtczogcGFyYW1zXHJcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXHJcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcclxuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxyXG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XHJcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXHJcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xyXG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcclxuICAgICAgcmV0dXJuIG1hdGNoKHtcclxuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcclxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXHJcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxyXG4gICAgICAgIGhhc2g6IGhhc2hcclxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWxpYXMgKFxyXG4gICAgcmVjb3JkLFxyXG4gICAgbG9jYXRpb24sXHJcbiAgICBtYXRjaEFzXHJcbiAgKSB7XHJcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XHJcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xyXG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcclxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcclxuICAgIH0pO1xyXG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xyXG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xyXG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcclxuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcclxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcclxuICAgIH1cclxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxyXG4gICAgcmVjb3JkLFxyXG4gICAgbG9jYXRpb24sXHJcbiAgICByZWRpcmVjdGVkRnJvbVxyXG4gICkge1xyXG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcclxuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXHJcbiAgICB9XHJcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XHJcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG1hdGNoOiBtYXRjaCxcclxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcclxuICByZWdleCxcclxuICBwYXRoLFxyXG4gIHBhcmFtc1xyXG4pIHtcclxuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xyXG5cclxuICBpZiAoIW0pIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XHJcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgLy8gRml4ICMxOTk0OiB1c2luZyAqIHdpdGggcHJvcHM6IHRydWUgZ2VuZXJhdGVzIGEgcGFyYW0gbmFtZWQgMFxyXG4gICAgICBwYXJhbXNba2V5Lm5hbWUgfHwgJ3BhdGhNYXRjaCddID0gdmFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xyXG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcclxuICAvLyBGaXggZm9yICMxNTg1IGZvciBGaXJlZm94XHJcbiAgLy8gRml4IGZvciAjMjE5NSBBZGQgb3B0aW9uYWwgdGhpcmQgYXR0cmlidXRlIHRvIHdvcmthcm91bmQgYSBidWcgaW4gc2FmYXJpIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODI2NzhcclxuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGdldFN0YXRlS2V5KCkgfSwgJycsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLm9yaWdpbiwgJycpKTtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XHJcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xyXG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXHJcbiAgcm91dGVyLFxyXG4gIHRvLFxyXG4gIGZyb20sXHJcbiAgaXNQb3BcclxuKSB7XHJcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xyXG4gIGlmICghYmVoYXZpb3IpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xyXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XHJcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IuY2FsbChyb3V0ZXIsIHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XHJcblxyXG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzaG91bGRTY3JvbGwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBzaG91bGRTY3JvbGwudGhlbihmdW5jdGlvbiAoc2hvdWxkU2Nyb2xsKSB7XHJcbiAgICAgICAgc2Nyb2xsVG9Qb3NpdGlvbigoc2hvdWxkU2Nyb2xsKSwgcG9zaXRpb24pO1xyXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xyXG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xyXG4gIGlmIChrZXkpIHtcclxuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcclxuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XHJcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XHJcbiAgaWYgKGtleSkge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XHJcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxyXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXHJcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uIChzaG91bGRTY3JvbGwsIHBvc2l0aW9uKSB7XHJcbiAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XHJcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XHJcbiAgICBpZiAoZWwpIHtcclxuICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xyXG4gICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XHJcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XHJcbiAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XHJcbiAgfVxyXG5cclxuICBpZiAocG9zaXRpb24pIHtcclxuICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblxyXG4gIGlmIChcclxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxyXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxyXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXHJcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxyXG59KSgpO1xyXG5cclxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxyXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xyXG4gID8gd2luZG93LnBlcmZvcm1hbmNlXHJcbiAgOiBEYXRlO1xyXG5cclxudmFyIF9rZXkgPSBnZW5LZXkoKTtcclxuXHJcbmZ1bmN0aW9uIGdlbktleSAoKSB7XHJcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XHJcbiAgcmV0dXJuIF9rZXlcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xyXG4gIF9rZXkgPSBrZXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XHJcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XHJcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXHJcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xyXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XHJcbiAgdHJ5IHtcclxuICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX2tleSA9IGdlbktleSgpO1xyXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcclxuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xyXG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XHJcbiAgICAgIGNiKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XHJcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBzdGVwKDApO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XHJcbiAgICB2YXIgaGFzQXN5bmMgPSBmYWxzZTtcclxuICAgIHZhciBwZW5kaW5nID0gMDtcclxuICAgIHZhciBlcnJvciA9IG51bGw7XHJcblxyXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xyXG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXHJcbiAgICAgIC8vIGFzc3VtZSBpdCdzIGFuIGFzeW5jIGNvbXBvbmVudCByZXNvbHZlIGZ1bmN0aW9uLlxyXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXHJcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXHJcbiAgICAgIC8vIHJlc29sdmVkLlxyXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBoYXNBc3luYyA9IHRydWU7XHJcbiAgICAgICAgcGVuZGluZysrO1xyXG5cclxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XHJcbiAgICAgICAgICBpZiAoaXNFU01vZHVsZShyZXNvbHZlZERlZikpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gc2F2ZSByZXNvbHZlZCBvbiBhc3luYyBmYWN0b3J5IGluIGNhc2UgaXQncyB1c2VkIGVsc2V3aGVyZVxyXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcclxuICAgICAgICAgICAgOiBfVnVlLmV4dGVuZChyZXNvbHZlZERlZik7XHJcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcclxuICAgICAgICAgIHBlbmRpbmctLTtcclxuICAgICAgICAgIGlmIChwZW5kaW5nIDw9IDApIHtcclxuICAgICAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICB2YXIgbXNnID0gXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb247XHJcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XHJcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycm9yID0gaXNFcnJvcihyZWFzb24pXHJcbiAgICAgICAgICAgICAgPyByZWFzb25cclxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcclxuICAgICAgICAgICAgdmFyIGNvbXAgPSByZXMuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghaGFzQXN5bmMpIHsgbmV4dCgpOyB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXHJcbiAgbWF0Y2hlZCxcclxuICBmblxyXG4pIHtcclxuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxyXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcclxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcclxuICAgICAgbSwga2V5XHJcbiAgICApOyB9KVxyXG4gIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxyXG59XHJcblxyXG52YXIgaGFzU3ltYm9sID1cclxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXHJcbiAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XHJcblxyXG5mdW5jdGlvbiBpc0VTTW9kdWxlIChvYmopIHtcclxuICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXHJcbn1cclxuXHJcbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2VcclxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXHJcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xyXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxyXG5mdW5jdGlvbiBvbmNlIChmbikge1xyXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XHJcblxyXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxyXG4gICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xyXG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XHJcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcclxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcclxuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xyXG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICB0aGlzLnJlYWR5Q2JzID0gW107XHJcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XHJcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xyXG4gIHRoaXMuY2IgPSBjYjtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xyXG4gIGlmICh0aGlzLnJlYWR5KSB7XHJcbiAgICBjYigpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xyXG4gICAgaWYgKGVycm9yQ2IpIHtcclxuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcclxuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XHJcbn07XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XHJcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcclxuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XHJcblxyXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxyXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcclxuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XHJcbiAgICB9XHJcbiAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgaWYgKG9uQWJvcnQpIHtcclxuICAgICAgb25BYm9ydChlcnIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XHJcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XHJcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcclxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XHJcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xyXG4gIH07XHJcbiAgaWYgKFxyXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXHJcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXHJcbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxyXG4gICkge1xyXG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcclxuICAgIHJldHVybiBhYm9ydCgpXHJcbiAgfVxyXG5cclxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcclxuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XHJcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XHJcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcclxuXHJcbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxyXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xyXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcclxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcclxuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxyXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xyXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxyXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xyXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXHJcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXHJcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcclxuICApO1xyXG5cclxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcclxuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xyXG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xyXG4gICAgICByZXR1cm4gYWJvcnQoKVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XHJcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xyXG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXHJcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xyXG4gICAgICAgICAgYWJvcnQodG8pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXHJcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxyXG4gICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXHJcbiAgICAgICAgICBuZXh0KHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBhYm9ydChlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcclxuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xyXG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcclxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xyXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcclxuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XHJcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xyXG4gICAgICAgIHJldHVybiBhYm9ydCgpXHJcbiAgICAgIH1cclxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xyXG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcclxuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XHJcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xyXG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xyXG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xyXG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XHJcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xyXG4gIGlmICghYmFzZSkge1xyXG4gICAgaWYgKGluQnJvd3Nlcikge1xyXG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcclxuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcclxuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XHJcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxyXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlID0gJy8nO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcclxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xyXG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XHJcbiAgfVxyXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxyXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcclxuICBjdXJyZW50LFxyXG4gIG5leHRcclxuKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XHJcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcclxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcclxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcclxuICByZWNvcmRzLFxyXG4gIG5hbWUsXHJcbiAgYmluZCxcclxuICByZXZlcnNlXHJcbikge1xyXG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xyXG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XHJcbiAgICBpZiAoZ3VhcmQpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXHJcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXHJcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcclxuICBkZWYsXHJcbiAga2V5XHJcbikge1xyXG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cclxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XHJcbiAgfVxyXG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcclxuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xyXG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcclxufVxyXG5cclxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcclxuICBpZiAoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xyXG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXHJcbiAgYWN0aXZhdGVkLFxyXG4gIGNicyxcclxuICBpc1ZhbGlkXHJcbikge1xyXG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcclxuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcclxuICBndWFyZCxcclxuICBtYXRjaCxcclxuICBrZXksXHJcbiAgY2JzLFxyXG4gIGlzVmFsaWRcclxuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcclxuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgIG5leHQoY2IpO1xyXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLy8gIzc1MFxyXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXHJcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXHJcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcclxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cclxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvbGwgKFxyXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxyXG4gIGluc3RhbmNlcyxcclxuICBrZXksXHJcbiAgaXNWYWxpZFxyXG4pIHtcclxuICBpZiAoXHJcbiAgICBpbnN0YW5jZXNba2V5XSAmJlxyXG4gICAgIWluc3RhbmNlc1trZXldLl9pc0JlaW5nRGVzdHJveWVkIC8vIGRvIG5vdCByZXVzZSBiZWluZyBkZXN0cm95ZWQgaW5zdGFuY2VcclxuICApIHtcclxuICAgIGNiKGluc3RhbmNlc1trZXldKTtcclxuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcclxuICAgIH0sIDE2KTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xyXG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcclxuXHJcbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XHJcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XHJcbiAgICAgIHNldHVwU2Nyb2xsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluaXRMb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMuYmFzZSk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xyXG5cclxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XHJcbiAgICAgIC8vIGhpc3Rvcnkgcm91dGUgbm90IHVwZGF0ZWQgc2luY2UgYXN5bmMgZ3VhcmQgYXQgdGhlIHNhbWUgdGltZS5cclxuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpO1xyXG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XHJcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcclxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xyXG5cclxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcclxuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xyXG4gIH07XHJcblxyXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgcmVmID0gdGhpcztcclxuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcclxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XHJcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XHJcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB9LCBvbkFib3J0KTtcclxuICB9O1xyXG5cclxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xyXG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xyXG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xyXG4gICAgfSwgb25BYm9ydCk7XHJcbiAgfTtcclxuXHJcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcclxuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcclxuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcclxuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XHJcbn0oSGlzdG9yeSkpO1xyXG5cclxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcclxuICB2YXIgcGF0aCA9IGRlY29kZVVSSSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xyXG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xyXG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xyXG4gIH1cclxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xyXG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XHJcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcclxuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcclxuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBlbnN1cmVTbGFzaCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcclxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XHJcblxyXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xyXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxyXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcclxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcclxuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcclxuXHJcbiAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcclxuICAgICAgc2V0dXBTY3JvbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzdXBwb3J0c1B1c2hTdGF0ZSA/ICdwb3BzdGF0ZScgOiAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcclxuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xyXG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdXBwb3J0c1B1c2hTdGF0ZSkge1xyXG4gICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgcmVmID0gdGhpcztcclxuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcclxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xyXG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xyXG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xyXG4gICAgfSwgb25BYm9ydCk7XHJcbiAgfTtcclxuXHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcclxuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcclxuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcclxuICAgIH0sIG9uQWJvcnQpO1xyXG4gIH07XHJcblxyXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XHJcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcclxuICB9O1xyXG5cclxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcclxuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcclxuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZ2V0SGFzaCgpXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xyXG59KEhpc3RvcnkpKTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcclxuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcclxuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcclxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxyXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcclxuICAgICk7XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xyXG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xyXG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XHJcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxyXG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXHJcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcclxuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcclxuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBkZWNvZGVVUkkoaHJlZi5zbGljZShpbmRleCArIDEpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRVcmwgKHBhdGgpIHtcclxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xyXG4gIHZhciBpID0gaHJlZi5pbmRleE9mKCcjJyk7XHJcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcclxuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XHJcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XHJcbiAgICBwdXNoU3RhdGUoZ2V0VXJsKHBhdGgpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcclxuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcclxuICAgIHJlcGxhY2VTdGF0ZShnZXRVcmwocGF0aCkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XHJcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcclxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xyXG4gICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgdGhpcy5pbmRleCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XHJcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xyXG5cclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcclxuICAgICAgdGhpcyQxLmluZGV4Kys7XHJcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XHJcbiAgICB9LCBvbkFib3J0KTtcclxuICB9O1xyXG5cclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xyXG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xyXG4gICAgfSwgb25BYm9ydCk7XHJcbiAgfTtcclxuXHJcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcclxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcclxuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XHJcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xyXG4gIH07XHJcblxyXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcclxuICAgIC8vIG5vb3BcclxuICB9O1xyXG5cclxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xyXG59KEhpc3RvcnkpKTtcclxuXHJcbi8qICAqL1xyXG5cclxuXHJcblxyXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XHJcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XHJcblxyXG4gIHRoaXMuYXBwID0gbnVsbDtcclxuICB0aGlzLmFwcHMgPSBbXTtcclxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcclxuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xyXG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xyXG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xyXG5cclxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XHJcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XHJcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcclxuICAgIG1vZGUgPSAnaGFzaCc7XHJcbiAgfVxyXG4gIGlmICghaW5Ccm93c2VyKSB7XHJcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcclxuICB9XHJcbiAgdGhpcy5tb2RlID0gbW9kZTtcclxuXHJcbiAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICBjYXNlICdoaXN0b3J5JzpcclxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnaGFzaCc6XHJcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxyXG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcclxuICAgICAgfVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcclxuICByYXcsXHJcbiAgY3VycmVudCxcclxuICByZWRpcmVjdGVkRnJvbVxyXG4pIHtcclxuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXHJcbn07XHJcblxyXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxyXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXHJcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcclxuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcclxuICApO1xyXG5cclxuICB0aGlzLmFwcHMucHVzaChhcHApO1xyXG5cclxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxyXG4gIGlmICh0aGlzLmFwcCkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB0aGlzLmFwcCA9IGFwcDtcclxuXHJcbiAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XHJcblxyXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XHJcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcclxuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xyXG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBoaXN0b3J5LnNldHVwTGlzdGVuZXJzKCk7XHJcbiAgICB9O1xyXG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXHJcbiAgICAgIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCksXHJcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxyXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XHJcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcclxuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYmVmb3JlSG9va3MsIGZuKVxyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVSZXNvbHZlID0gZnVuY3Rpb24gYmVmb3JlUmVzb2x2ZSAoZm4pIHtcclxuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMucmVzb2x2ZUhvb2tzLCBmbilcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbikge1xyXG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XHJcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IsIGVycm9yQ2IpO1xyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xyXG4gIHRoaXMuaGlzdG9yeS5vbkVycm9yKGVycm9yQ2IpO1xyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcclxuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XHJcbn07XHJcblxyXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xyXG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xyXG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xyXG4gIHRoaXMuZ28oLTEpO1xyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XHJcbiAgdGhpcy5nbygxKTtcclxufTtcclxuXHJcblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcclxuICB2YXIgcm91dGUgPSB0b1xyXG4gICAgPyB0by5tYXRjaGVkXHJcbiAgICAgID8gdG9cclxuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXHJcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xyXG4gIGlmICghcm91dGUpIHtcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXHJcbiAgICB9KVxyXG4gIH0pKVxyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXHJcbiAgdG8sXHJcbiAgY3VycmVudCxcclxuICBhcHBlbmRcclxuKSB7XHJcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXHJcbiAgICB0byxcclxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXHJcbiAgICBhcHBlbmQsXHJcbiAgICB0aGlzXHJcbiAgKTtcclxuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcclxuICB2YXIgZnVsbFBhdGggPSByb3V0ZS5yZWRpcmVjdGVkRnJvbSB8fCByb3V0ZS5mdWxsUGF0aDtcclxuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xyXG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcclxuICByZXR1cm4ge1xyXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgcm91dGU6IHJvdXRlLFxyXG4gICAgaHJlZjogaHJlZixcclxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XHJcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxyXG4gICAgcmVzb2x2ZWQ6IHJvdXRlXHJcbiAgfVxyXG59O1xyXG5cclxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xyXG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcclxuICBpZiAodGhpcy5oaXN0b3J5LmN1cnJlbnQgIT09IFNUQVJUKSB7XHJcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xyXG4gIGxpc3QucHVzaChmbik7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcclxuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhyZWYgKGJhc2UsIGZ1bGxQYXRoLCBtb2RlKSB7XHJcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xyXG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcclxufVxyXG5cclxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xyXG5WdWVSb3V0ZXIudmVyc2lvbiA9ICczLjAuMic7XHJcblxyXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcclxuICB3aW5kb3cuVnVlLnVzZShWdWVSb3V0ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWdWVSb3V0ZXI7XHJcbiIsIi8qIVxyXG4gKiB2dWUtcmVzb3VyY2UgdjEuNS4xXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWdla2l0L3Z1ZS1yZXNvdXJjZVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFByb21pc2VzL0ErIHBvbHlmaWxsIHYxLjEuNCAoaHR0cHM6Ly9naXRodWIuY29tL2JyYW1zdGVpbi9wcm9taXMpXHJcbiAqL1xyXG5cclxudmFyIFJFU09MVkVEID0gMDtcclxudmFyIFJFSkVDVEVEID0gMTtcclxudmFyIFBFTkRJTkcgPSAyO1xyXG5cclxuZnVuY3Rpb24gUHJvbWlzZSQxKGV4ZWN1dG9yKSB7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XHJcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xyXG5cclxuICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcclxuICAgIH1cclxufVxyXG5cclxuUHJvbWlzZSQxLnJlamVjdCA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcmVqZWN0KHIpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Qcm9taXNlJDEucmVzb2x2ZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcmVzb2x2ZSh4KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuUHJvbWlzZSQxLmFsbCA9IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IDAsIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoaXRlcmFibGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB4O1xyXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IGl0ZXJhYmxlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgUHJvbWlzZSQxLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIFByb21pc2UkMS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgcCA9IFByb21pc2UkMS5wcm90b3R5cGU7XHJcblxyXG5wLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHgpIHtcclxuICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuXHJcbiAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xyXG4gICAgICAgIGlmICh4ID09PSBwcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHRoZW4gPSB4ICYmIHhbJ3RoZW4nXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRVNPTFZFRDtcclxuICAgICAgICBwcm9taXNlLnZhbHVlID0geDtcclxuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxucC5yZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XHJcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcclxuICAgICAgICBpZiAocmVhc29uID09PSBwcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRUpFQ1RFRDtcclxuICAgICAgICBwcm9taXNlLnZhbHVlID0gcmVhc29uO1xyXG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5wLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcclxuICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuXHJcbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUgIT09IFBFTkRJTkcpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHByb21pc2UuZGVmZXJyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBwcm9taXNlLmRlZmVycmVkLnNoaWZ0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgb25SZXNvbHZlZCA9IGRlZmVycmVkWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSBkZWZlcnJlZFsxXSxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gZGVmZXJyZWRbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ID0gZGVmZXJyZWRbM107XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVTT0xWRUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQuY2FsbCh1bmRlZmluZWQsIHByb21pc2UudmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdGUgPT09IFJFSkVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlamVjdGVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5wLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcHJvbWlzZS5kZWZlcnJlZC5wdXNoKFtvblJlc29sdmVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5wLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcclxuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9taXNlIGFkYXB0ZXIuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgd2luZG93LlByb21pc2UgPSBQcm9taXNlJDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFByb21pc2VPYmooZXhlY3V0b3IsIGNvbnRleHQpIHtcclxuXHJcbiAgICBpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gZXhlY3V0b3I7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGV4ZWN1dG9yLmJpbmQoY29udGV4dCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbn1cclxuXHJcblByb21pc2VPYmouYWxsID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooUHJvbWlzZS5hbGwoaXRlcmFibGUpLCBjb250ZXh0KTtcclxufTtcclxuXHJcblByb21pc2VPYmoucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKFByb21pc2UucmVzb2x2ZSh2YWx1ZSksIGNvbnRleHQpO1xyXG59O1xyXG5cclxuUHJvbWlzZU9iai5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooUHJvbWlzZS5yZWplY3QocmVhc29uKSwgY29udGV4dCk7XHJcbn07XHJcblxyXG5Qcm9taXNlT2JqLnJhY2UgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJhY2UoaXRlcmFibGUpLCBjb250ZXh0KTtcclxufTtcclxuXHJcbnZhciBwJDEgPSBQcm9taXNlT2JqLnByb3RvdHlwZTtcclxuXHJcbnAkMS5iaW5kID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbnAkMS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcclxuXHJcbiAgICBpZiAoZnVsZmlsbGVkICYmIGZ1bGZpbGxlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xyXG4gICAgICAgIGZ1bGZpbGxlZCA9IGZ1bGZpbGxlZC5iaW5kKHRoaXMuY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlamVjdGVkICYmIHJlamVjdGVkLmJpbmQgJiYgdGhpcy5jb250ZXh0KSB7XHJcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKHRoaXMucHJvbWlzZS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpLCB0aGlzLmNvbnRleHQpO1xyXG59O1xyXG5cclxucCQxLmNhdGNoID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XHJcblxyXG4gICAgaWYgKHJlamVjdGVkICYmIHJlamVjdGVkLmJpbmQgJiYgdGhpcy5jb250ZXh0KSB7XHJcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKHRoaXMucHJvbWlzZS5jYXRjaChyZWplY3RlZCksIHRoaXMuY29udGV4dCk7XHJcbn07XHJcblxyXG5wJDEuZmluYWxseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG5cclxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcclxuICAgIH1cclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5cclxudmFyIHJlZiA9IHt9O1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XHJcbnZhciByZWYkMSA9IFtdO1xyXG52YXIgc2xpY2UgPSByZWYkMS5zbGljZTtcclxudmFyIGRlYnVnID0gZmFsc2UsIG50aWNrO1xyXG5cclxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xyXG5cclxuZnVuY3Rpb24gVXRpbCAocmVmKSB7XHJcbiAgICB2YXIgY29uZmlnID0gcmVmLmNvbmZpZztcclxuICAgIHZhciBuZXh0VGljayA9IHJlZi5uZXh0VGljaztcclxuXHJcbiAgICBudGljayA9IG5leHRUaWNrO1xyXG4gICAgZGVidWcgPSBjb25maWcuZGVidWcgfHwgIWNvbmZpZy5zaWxlbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhcm4obXNnKSB7XHJcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGRlYnVnKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbVnVlUmVzb3VyY2Ugd2Fybl06ICcgKyBtc2cpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcclxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRUaWNrKGNiLCBjdHgpIHtcclxuICAgIHJldHVybiBudGljayhjYiwgY3R4KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuICAgIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpIDogJyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyaW1FbmQoc3RyLCBjaGFycykge1xyXG5cclxuICAgIGlmIChzdHIgJiYgY2hhcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKyQvLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzdHIgfHwgIWNoYXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgoXCJbXCIgKyBjaGFycyArIFwiXSskXCIpKSwgJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0xvd2VyKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ciA/IHN0ci50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvVXBwZXIoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyID8gc3RyLnRvVXBwZXJDYXNlKCkgOiAnJztcclxufVxyXG5cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5cclxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNCbG9iKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcclxuXHJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2VPYmoucmVzb2x2ZSh2YWx1ZSk7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb3B0aW9ucyhmbiwgb2JqLCBvcHRzKSB7XHJcblxyXG4gICAgb3B0cyA9IG9wdHMgfHwge307XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0cykpIHtcclxuICAgICAgICBvcHRzID0gb3B0cy5jYWxsKG9iaik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1lcmdlKGZuLmJpbmQoeyR2bTogb2JqLCAkb3B0aW9uczogb3B0c30pLCBmbiwgeyRvcHRpb25zOiBvcHRzfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvcikge1xyXG5cclxuICAgIHZhciBpLCBrZXk7XHJcblxyXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChvYmpba2V5XSwgb2JqW2tleV0sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG5cclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgX2Fzc2lnbjtcclxuXHJcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xyXG5cclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgX21lcmdlKHRhcmdldCwgc291cmNlLCB0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xyXG5cclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQpIHtcclxuXHJcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBpZiAoZGVlcCAmJiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSb290IFByZWZpeCBUcmFuc2Zvcm0uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcm9vdCAob3B0aW9ucyQkMSwgbmV4dCkge1xyXG5cclxuICAgIHZhciB1cmwgPSBuZXh0KG9wdGlvbnMkJDEpO1xyXG5cclxuICAgIGlmIChpc1N0cmluZyhvcHRpb25zJCQxLnJvb3QpICYmICEvXihodHRwcz86KT9cXC8vLnRlc3QodXJsKSkge1xyXG4gICAgICAgIHVybCA9IHRyaW1FbmQob3B0aW9ucyQkMS5yb290LCAnLycpICsgJy8nICsgdXJsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBRdWVyeSBQYXJhbWV0ZXIgVHJhbnNmb3JtLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5IChvcHRpb25zJCQxLCBuZXh0KSB7XHJcblxyXG4gICAgdmFyIHVybFBhcmFtcyA9IE9iamVjdC5rZXlzKFVybC5vcHRpb25zLnBhcmFtcyksIHF1ZXJ5ID0ge30sIHVybCA9IG5leHQob3B0aW9ucyQkMSk7XHJcblxyXG4gICAgZWFjaChvcHRpb25zJCQxLnBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICBpZiAodXJsUGFyYW1zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHF1ZXJ5ID0gVXJsLnBhcmFtcyhxdWVyeSk7XHJcblxyXG4gICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnKSArIHF1ZXJ5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVUkwgVGVtcGxhdGUgdjIuMC42IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3VybC10ZW1wbGF0ZSlcclxuICovXHJcblxyXG5mdW5jdGlvbiBleHBhbmQodXJsLCBwYXJhbXMsIHZhcmlhYmxlcykge1xyXG5cclxuICAgIHZhciB0bXBsID0gcGFyc2UodXJsKSwgZXhwYW5kZWQgPSB0bXBsLmV4cGFuZChwYXJhbXMpO1xyXG5cclxuICAgIGlmICh2YXJpYWJsZXMpIHtcclxuICAgICAgICB2YXJpYWJsZXMucHVzaC5hcHBseSh2YXJpYWJsZXMsIHRtcGwudmFycyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cGFuZGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSkge1xyXG5cclxuICAgIHZhciBvcGVyYXRvcnMgPSBbJysnLCAnIycsICcuJywgJy8nLCAnOycsICc/JywgJyYnXSwgdmFyaWFibGVzID0gW107XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YXJzOiB2YXJpYWJsZXMsXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7KFtee31dKylcXH18KFtee31dKykvZywgZnVuY3Rpb24gKF8sIGV4cHJlc3Npb24sIGxpdGVyYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IG51bGwsIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZXhwcmVzc2lvbi5jaGFyQXQoMCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSAvKFteOipdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHRtcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciAmJiBvcGVyYXRvciAhPT0gJysnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJywnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9ICcmJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiAnJykgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbignLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVSZXNlcnZlZChsaXRlcmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XHJcblxyXG4gICAgdmFyIHZhbHVlID0gY29udGV4dFtrZXldLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllciAmJiBtb2RpZmllciAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWVba10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdG1wLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbignLCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnOycpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnICYmIChvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPycpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcclxuICAgIHJldHVybiBvcGVyYXRvciA9PT0gJzsnIHx8IG9wZXJhdG9yID09PSAnJicgfHwgb3BlcmF0b3IgPT09ICc/JztcclxufVxyXG5cclxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcclxuXHJcbiAgICB2YWx1ZSA9IChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnIycpID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnNwbGl0KC8oJVswLTlBLUZhLWZdezJ9KS9nKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcclxuICAgICAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcclxuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICB9KS5qb2luKCcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVSTCBUZW1wbGF0ZSAoUkZDIDY1NzApIFRyYW5zZm9ybS5cclxuICovXHJcblxyXG5mdW5jdGlvbiB0ZW1wbGF0ZSAob3B0aW9ucykge1xyXG5cclxuICAgIHZhciB2YXJpYWJsZXMgPSBbXSwgdXJsID0gZXhwYW5kKG9wdGlvbnMudXJsLCBvcHRpb25zLnBhcmFtcywgdmFyaWFibGVzKTtcclxuXHJcbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG4vKipcclxuICogU2VydmljZSBmb3IgVVJMIHRlbXBsYXRpbmcuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gVXJsKHVybCwgcGFyYW1zKSB7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LCBvcHRpb25zJCQxID0gdXJsLCB0cmFuc2Zvcm07XHJcblxyXG4gICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgICBvcHRpb25zJCQxID0ge3VybDogdXJsLCBwYXJhbXM6IHBhcmFtc307XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyQkMSA9IG1lcmdlKHt9LCBVcmwub3B0aW9ucywgc2VsZi4kb3B0aW9ucywgb3B0aW9ucyQkMSk7XHJcblxyXG4gICAgVXJsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xyXG5cclxuICAgICAgICBpZiAoaXNTdHJpbmcoaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IFVybC50cmFuc2Zvcm1baGFuZGxlcl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBmYWN0b3J5KGhhbmRsZXIsIHRyYW5zZm9ybSwgc2VsZi4kdm0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdHJhbnNmb3JtKG9wdGlvbnMkJDEpO1xyXG59XHJcblxyXG4vKipcclxuICogVXJsIG9wdGlvbnMuXHJcbiAqL1xyXG5cclxuVXJsLm9wdGlvbnMgPSB7XHJcbiAgICB1cmw6ICcnLFxyXG4gICAgcm9vdDogbnVsbCxcclxuICAgIHBhcmFtczoge31cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcmwgdHJhbnNmb3Jtcy5cclxuICovXHJcblxyXG5VcmwudHJhbnNmb3JtID0ge3RlbXBsYXRlOiB0ZW1wbGF0ZSwgcXVlcnk6IHF1ZXJ5LCByb290OiByb290fTtcclxuVXJsLnRyYW5zZm9ybXMgPSBbJ3RlbXBsYXRlJywgJ3F1ZXJ5JywgJ3Jvb3QnXTtcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICovXHJcblxyXG5VcmwucGFyYW1zID0gZnVuY3Rpb24gKG9iaikge1xyXG5cclxuICAgIHZhciBwYXJhbXMgPSBbXSwgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xyXG5cclxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnB1c2goZXNjYXBlKGtleSkgKyAnPScgKyBlc2NhcGUodmFsdWUpKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VyaWFsaXplKHBhcmFtcywgb2JqKTtcclxuXHJcbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIFVSTCBhbmQgcmV0dXJuIGl0cyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXHJcbiAqL1xyXG5cclxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xyXG5cclxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHJcbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XHJcbiAgICAgICAgZWwuaHJlZiA9IHVybDtcclxuICAgICAgICB1cmwgPSBlbC5ocmVmO1xyXG4gICAgfVxyXG5cclxuICAgIGVsLmhyZWYgPSB1cmw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBocmVmOiBlbC5ocmVmLFxyXG4gICAgICAgIHByb3RvY29sOiBlbC5wcm90b2NvbCA/IGVsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXHJcbiAgICAgICAgcG9ydDogZWwucG9ydCxcclxuICAgICAgICBob3N0OiBlbC5ob3N0LFxyXG4gICAgICAgIGhvc3RuYW1lOiBlbC5ob3N0bmFtZSxcclxuICAgICAgICBwYXRobmFtZTogZWwucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycgPyBlbC5wYXRobmFtZSA6ICcvJyArIGVsLnBhdGhuYW1lLFxyXG4gICAgICAgIHNlYXJjaDogZWwuc2VhcmNoID8gZWwuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcclxuICAgICAgICBoYXNoOiBlbC5oYXNoID8gZWwuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZmFjdG9yeShoYW5kbGVyLCBuZXh0LCB2bSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zJCQxKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh2bSwgb3B0aW9ucyQkMSwgbmV4dCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHNjb3BlKSB7XHJcblxyXG4gICAgdmFyIGFycmF5ID0gaXNBcnJheShvYmopLCBwbGFpbiA9IGlzUGxhaW5PYmplY3Qob2JqKSwgaGFzaDtcclxuXHJcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuXHJcbiAgICAgICAgaGFzaCA9IGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHNjb3BlICsgJ1snICsgKHBsYWluIHx8IGhhc2ggPyBrZXkgOiAnJykgKyAnXSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXNjb3BlICYmIGFycmF5KSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFzaCkge1xyXG4gICAgICAgICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwga2V5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMuYWRkKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogWERvbWFpbiBjbGllbnQgKEludGVybmV0IEV4cGxvcmVyKS5cclxuICovXHJcblxyXG5mdW5jdGlvbiB4ZHJDbGllbnQgKHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG5cclxuICAgICAgICB2YXIgeGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCksIGhhbmRsZXIgPSBmdW5jdGlvbiAocmVmKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xvYWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gNTAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25kV2l0aCh4ZHIucmVzcG9uc2VUZXh0LCB7c3RhdHVzOiBzdGF0dXN9KSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB4ZHIuYWJvcnQoKTsgfTtcclxuXHJcbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCkpO1xyXG5cclxuICAgICAgICBpZiAocmVxdWVzdC50aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHhkci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGRyLm9ubG9hZCA9IGhhbmRsZXI7XHJcbiAgICAgICAgeGRyLm9uYWJvcnQgPSBoYW5kbGVyO1xyXG4gICAgICAgIHhkci5vbmVycm9yID0gaGFuZGxlcjtcclxuICAgICAgICB4ZHIub250aW1lb3V0ID0gaGFuZGxlcjtcclxuICAgICAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIHhkci5zZW5kKHJlcXVlc3QuZ2V0Qm9keSgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ09SUyBJbnRlcmNlcHRvci5cclxuICovXHJcblxyXG52YXIgU1VQUE9SVFNfQ09SUyA9IGluQnJvd3NlciAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbmZ1bmN0aW9uIGNvcnMgKHJlcXVlc3QpIHtcclxuXHJcbiAgICBpZiAoaW5Ccm93c2VyKSB7XHJcblxyXG4gICAgICAgIHZhciBvcmdVcmwgPSBVcmwucGFyc2UobG9jYXRpb24uaHJlZik7XHJcbiAgICAgICAgdmFyIHJlcVVybCA9IFVybC5wYXJzZShyZXF1ZXN0LmdldFVybCgpKTtcclxuXHJcbiAgICAgICAgaWYgKHJlcVVybC5wcm90b2NvbCAhPT0gb3JnVXJsLnByb3RvY29sIHx8IHJlcVVybC5ob3N0ICE9PSBvcmdVcmwuaG9zdCkge1xyXG5cclxuICAgICAgICAgICAgcmVxdWVzdC5jcm9zc09yaWdpbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuZW11bGF0ZUhUVFAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICghU1VQUE9SVFNfQ09SUykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnQgPSB4ZHJDbGllbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogRm9ybSBkYXRhIEludGVyY2VwdG9yLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGZvcm0gKHJlcXVlc3QpIHtcclxuXHJcbiAgICBpZiAoaXNGb3JtRGF0YShyZXF1ZXN0LmJvZHkpKSB7XHJcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmRlbGV0ZSgnQ29udGVudC1UeXBlJyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlcXVlc3QuYm9keSkgJiYgcmVxdWVzdC5lbXVsYXRlSlNPTikge1xyXG4gICAgICAgIHJlcXVlc3QuYm9keSA9IFVybC5wYXJhbXMocmVxdWVzdC5ib2R5KTtcclxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogSlNPTiBJbnRlcmNlcHRvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBqc29uIChyZXF1ZXN0KSB7XHJcblxyXG4gICAgdmFyIHR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSB8fCAnJztcclxuXHJcbiAgICBpZiAoaXNPYmplY3QocmVxdWVzdC5ib2R5KSAmJiB0eXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCkge1xyXG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuYm9keSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keVRleHQgPyB3aGVuKHJlc3BvbnNlLnRleHQoKSwgZnVuY3Rpb24gKHRleHQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpIHx8ICcnO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID09PSAwIHx8IGlzSnNvbih0ZXh0KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IEpTT04ucGFyc2UodGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuXHJcbiAgICAgICAgfSkgOiByZXNwb25zZTtcclxuXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0pzb24oc3RyKSB7XHJcblxyXG4gICAgdmFyIHN0YXJ0ID0gc3RyLm1hdGNoKC9eXFxzKihcXFt8XFx7KS8pO1xyXG4gICAgdmFyIGVuZCA9IHsnWyc6IC9dXFxzKiQvLCAneyc6IC99XFxzKiQvfTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgJiYgZW5kW3N0YXJ0WzFdXS50ZXN0KHN0cik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBKU09OUCBjbGllbnQgKEJyb3dzZXIpLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGpzb25wQ2xpZW50IChyZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuXHJcbiAgICAgICAgdmFyIG5hbWUgPSByZXF1ZXN0Lmpzb25wIHx8ICdjYWxsYmFjaycsIGNhbGxiYWNrID0gcmVxdWVzdC5qc29ucENhbGxiYWNrIHx8ICdfanNvbnAnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpLCBib2R5ID0gbnVsbCwgaGFuZGxlciwgc2NyaXB0O1xyXG5cclxuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsb2FkJyAmJiBib2R5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gNTAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzICYmIHdpbmRvd1tjYWxsYmFja10pIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tdO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uZFdpdGgoYm9keSwge3N0YXR1czogc3RhdHVzfSkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdpbmRvd1tjYWxsYmFja10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoe3R5cGU6ICdhYm9ydCd9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXF1ZXN0LnBhcmFtc1tuYW1lXSA9IGNhbGxiYWNrO1xyXG5cclxuICAgICAgICBpZiAocmVxdWVzdC50aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVxdWVzdC5hYm9ydCwgcmVxdWVzdC50aW1lb3V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgIHNjcmlwdC5zcmMgPSByZXF1ZXN0LmdldFVybCgpO1xyXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICBzY3JpcHQub25sb2FkID0gaGFuZGxlcjtcclxuICAgICAgICBzY3JpcHQub25lcnJvciA9IGhhbmRsZXI7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogSlNPTlAgSW50ZXJjZXB0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24ganNvbnAgKHJlcXVlc3QpIHtcclxuXHJcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT0gJ0pTT05QJykge1xyXG4gICAgICAgIHJlcXVlc3QuY2xpZW50ID0ganNvbnBDbGllbnQ7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQmVmb3JlIEludGVyY2VwdG9yLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGJlZm9yZSAocmVxdWVzdCkge1xyXG5cclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlcXVlc3QuYmVmb3JlKSkge1xyXG4gICAgICAgIHJlcXVlc3QuYmVmb3JlLmNhbGwodGhpcywgcmVxdWVzdCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogSFRUUCBtZXRob2Qgb3ZlcnJpZGUgSW50ZXJjZXB0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWV0aG9kIChyZXF1ZXN0KSB7XHJcblxyXG4gICAgaWYgKHJlcXVlc3QuZW11bGF0ZUhUVFAgJiYgL14oUFVUfFBBVENIfERFTEVURSkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcclxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgcmVxdWVzdC5tZXRob2QpO1xyXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gJ1BPU1QnO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlYWRlciBJbnRlcmNlcHRvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBoZWFkZXIgKHJlcXVlc3QpIHtcclxuXHJcbiAgICB2YXIgaGVhZGVycyA9IGFzc2lnbih7fSwgSHR0cC5oZWFkZXJzLmNvbW1vbixcclxuICAgICAgICAhcmVxdWVzdC5jcm9zc09yaWdpbiA/IEh0dHAuaGVhZGVycy5jdXN0b20gOiB7fSxcclxuICAgICAgICBIdHRwLmhlYWRlcnNbdG9Mb3dlcihyZXF1ZXN0Lm1ldGhvZCldXHJcbiAgICApO1xyXG5cclxuICAgIGVhY2goaGVhZGVycywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFhNTEh0dHAgY2xpZW50IChCcm93c2VyKS5cclxuICovXHJcblxyXG5mdW5jdGlvbiB4aHJDbGllbnQgKHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG5cclxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbmRXaXRoKFxyXG4gICAgICAgICAgICAgICAgJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cywgLy8gSUU5IHN0YXR1cyBidWdcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogdHJpbSh4aHIuc3RhdHVzVGV4dClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGVhY2godHJpbSh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuYXBwZW5kKHJvdy5zbGljZSgwLCByb3cuaW5kZXhPZignOicpKSwgcm93LnNsaWNlKHJvdy5pbmRleE9mKCc6JykgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhoci5hYm9ydCgpOyB9O1xyXG5cclxuICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5nZXRVcmwoKSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcclxuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZVR5cGUgJiYgJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XHJcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXF1ZXN0LndpdGhDcmVkZW50aWFscyB8fCByZXF1ZXN0LmNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlcHJlY2F0ZWQgdXNlIGRvd25sb2FkUHJvZ3Jlc3NcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LnByb2dyZXNzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcmVxdWVzdC5wcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LmRvd25sb2FkUHJvZ3Jlc3MpKSB7XHJcbiAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QuZG93bmxvYWRQcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkZXByZWNhdGVkIHVzZSB1cGxvYWRQcm9ncmVzc1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlcXVlc3QucHJvZ3Jlc3MpICYmIC9eKFBPU1R8UFVUKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xyXG4gICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcmVxdWVzdC5wcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LnVwbG9hZFByb2dyZXNzKSAmJiB4aHIudXBsb2FkKSB7XHJcbiAgICAgICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZXF1ZXN0LnVwbG9hZFByb2dyZXNzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHhoci5vbmxvYWQgPSBoYW5kbGVyO1xyXG4gICAgICAgIHhoci5vbmFib3J0ID0gaGFuZGxlcjtcclxuICAgICAgICB4aHIub25lcnJvciA9IGhhbmRsZXI7XHJcbiAgICAgICAgeGhyLm9udGltZW91dCA9IGhhbmRsZXI7XHJcbiAgICAgICAgeGhyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIdHRwIGNsaWVudCAoTm9kZSkuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbm9kZUNsaWVudCAocmVxdWVzdCkge1xyXG5cclxuICAgIHZhciBjbGllbnQgPSByZXF1aXJlKCdnb3QnKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHVybCA9IHJlcXVlc3QuZ2V0VXJsKCk7XHJcbiAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0LmdldEJvZHkoKTtcclxuICAgICAgICB2YXIgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XHJcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7fSwgaGFuZGxlcjtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2xpZW50KHVybCwge2JvZHk6IGJvZHksIG1ldGhvZDogbWV0aG9kLCBoZWFkZXJzOiBoZWFkZXJzfSkudGhlbihoYW5kbGVyID0gZnVuY3Rpb24gKHJlc3ApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uZFdpdGgocmVzcC5ib2R5LCB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3Auc3RhdHVzQ29kZSxcclxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRyaW0ocmVzcC5zdGF0dXNNZXNzYWdlKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGVhY2gocmVzcC5oZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yJCQxKSB7IHJldHVybiBoYW5kbGVyKGVycm9yJCQxLnJlc3BvbnNlKTsgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xpZW50LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIENsaWVudCAoY29udGV4dCkge1xyXG5cclxuICAgIHZhciByZXFIYW5kbGVycyA9IFtzZW5kUmVxdWVzdF0sIHJlc0hhbmRsZXJzID0gW107XHJcblxyXG4gICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIENsaWVudChyZXF1ZXN0KSB7XHJcbiAgICAgICAgd2hpbGUgKHJlcUhhbmRsZXJzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSByZXFIYW5kbGVycy5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGhhbmRsZXIuY2FsbChjb250ZXh0LCByZXF1ZXN0LCBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBuZXh0ID0gdmFsOyB9KSB8fCBuZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChyZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB3aGVuKHJlc3BvbnNlLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKGNvbnRleHQsIHJlc3BvbnNlKSB8fCByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbihyZXNwb25zZSwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzSGFuZGxlcnMudW5zaGlmdChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybigoXCJJbnZhbGlkIGludGVyY2VwdG9yIG9mIHR5cGUgXCIgKyAodHlwZW9mIGhhbmRsZXIpICsgXCIsIG11c3QgYmUgYSBmdW5jdGlvblwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ2xpZW50LnVzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgcmVxSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIENsaWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VuZFJlcXVlc3QocmVxdWVzdCkge1xyXG5cclxuICAgIHZhciBjbGllbnQgPSByZXF1ZXN0LmNsaWVudCB8fCAoaW5Ccm93c2VyID8geGhyQ2xpZW50IDogbm9kZUNsaWVudCk7XHJcblxyXG4gICAgcmV0dXJuIGNsaWVudChyZXF1ZXN0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhUVFAgSGVhZGVycy5cclxuICovXHJcblxyXG52YXIgSGVhZGVycyA9IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG5cclxuICAgIHRoaXMubWFwID0ge307XHJcblxyXG4gICAgZWFjaChoZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHsgcmV0dXJuIHRoaXMkMS5hcHBlbmQobmFtZSwgdmFsdWUpOyB9KTtcclxufTtcclxuXHJcbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAobmFtZSkge1xyXG4gICAgcmV0dXJuIGdldE5hbWUodGhpcy5tYXAsIG5hbWUpICE9PSBudWxsO1xyXG59O1xyXG5cclxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChuYW1lKSB7XHJcblxyXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtnZXROYW1lKHRoaXMubWFwLCBuYW1lKV07XHJcblxyXG4gICAgcmV0dXJuIGxpc3QgPyBsaXN0LmpvaW4oKSA6IG51bGw7XHJcbn07XHJcblxyXG5IZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwgKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcFtnZXROYW1lKHRoaXMubWFwLCBuYW1lKV0gfHwgW107XHJcbn07XHJcblxyXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKG5hbWUsIHZhbHVlKSB7XHJcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKGdldE5hbWUodGhpcy5tYXAsIG5hbWUpIHx8IG5hbWUpXSA9IFt0cmltKHZhbHVlKV07XHJcbn07XHJcblxyXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XHJcblxyXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtnZXROYW1lKHRoaXMubWFwLCBuYW1lKV07XHJcblxyXG4gICAgaWYgKGxpc3QpIHtcclxuICAgICAgICBsaXN0LnB1c2godHJpbSh2YWx1ZSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5IZWFkZXJzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiBkZWxldGUkMSAobmFtZSkge1xyXG4gICAgZGVsZXRlIHRoaXMubWFwW2dldE5hbWUodGhpcy5tYXAsIG5hbWUpXTtcclxufTtcclxuXHJcbkhlYWRlcnMucHJvdG90eXBlLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIGRlbGV0ZUFsbCAoKSB7XHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG59O1xyXG5cclxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24gKGxpc3QsIG5hbWUpIHtcclxuICAgICAgICBlYWNoKGxpc3QsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyQxKTsgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldE5hbWUobWFwLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICByZXR1cm4gdG9Mb3dlcihuYW1lKSA9PT0gdG9Mb3dlcihjdXJyKSA/IGN1cnIgOiBwcmV2O1xyXG4gICAgfSwgbnVsbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xyXG5cclxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmltKG5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogSFRUUCBSZXNwb25zZS5cclxuICovXHJcblxyXG52YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiBSZXNwb25zZShib2R5LCByZWYpIHtcclxuICAgIHZhciB1cmwgPSByZWYudXJsO1xyXG4gICAgdmFyIGhlYWRlcnMgPSByZWYuaGVhZGVycztcclxuICAgIHZhciBzdGF0dXMgPSByZWYuc3RhdHVzO1xyXG4gICAgdmFyIHN0YXR1c1RleHQgPSByZWYuc3RhdHVzVGV4dDtcclxuXHJcblxyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLm9rID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cyB8fCAwO1xyXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCAnJztcclxuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xyXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoYm9keSkpIHtcclxuXHJcbiAgICAgICAgdGhpcy5ib2R5VGV4dCA9IGJvZHk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcclxuXHJcbiAgICAgICAgdGhpcy5ib2R5QmxvYiA9IGJvZHk7XHJcblxyXG4gICAgICAgIGlmIChpc0Jsb2JUZXh0KGJvZHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keVRleHQgPSBibG9iVGV4dChib2R5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuYmxvYiA9IGZ1bmN0aW9uIGJsb2IgKCkge1xyXG4gICAgcmV0dXJuIHdoZW4odGhpcy5ib2R5QmxvYik7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIHRleHQgKCkge1xyXG4gICAgcmV0dXJuIHdoZW4odGhpcy5ib2R5VGV4dCk7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24gKCkge1xyXG4gICAgcmV0dXJuIHdoZW4odGhpcy50ZXh0KCksIGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBKU09OLnBhcnNlKHRleHQpOyB9KTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zZS5wcm90b3R5cGUsICdkYXRhJywge1xyXG5cclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gc2V0KGJvZHkpIHtcclxuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5mdW5jdGlvbiBibG9iVGV4dChib2R5KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJvZHkpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNCbG9iVGV4dChib2R5KSB7XHJcbiAgICByZXR1cm4gYm9keS50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gMCB8fCBib2R5LnR5cGUuaW5kZXhPZignanNvbicpICE9PSAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhUVFAgUmVxdWVzdC5cclxuICovXHJcblxyXG52YXIgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3Qob3B0aW9ucyQkMSkge1xyXG5cclxuICAgIHRoaXMuYm9keSA9IG51bGw7XHJcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xyXG5cclxuICAgIGFzc2lnbih0aGlzLCBvcHRpb25zJCQxLCB7XHJcbiAgICAgICAgbWV0aG9kOiB0b1VwcGVyKG9wdGlvbnMkJDEubWV0aG9kIHx8ICdHRVQnKVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCEodGhpcy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gZ2V0VXJsICgpIHtcclxuICAgIHJldHVybiBVcmwodGhpcyk7XHJcbn07XHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRCb2R5ID0gZnVuY3Rpb24gZ2V0Qm9keSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ib2R5O1xyXG59O1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGggPSBmdW5jdGlvbiByZXNwb25kV2l0aCAoYm9keSwgb3B0aW9ucyQkMSkge1xyXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBhc3NpZ24ob3B0aW9ucyQkMSB8fCB7fSwge3VybDogdGhpcy5nZXRVcmwoKX0pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXJ2aWNlIGZvciBzZW5kaW5nIG5ldHdvcmsgcmVxdWVzdHMuXHJcbiAqL1xyXG5cclxudmFyIENPTU1PTl9IRUFERVJTID0geydBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ307XHJcbnZhciBKU09OX0NPTlRFTlRfVFlQRSA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCd9O1xyXG5cclxuZnVuY3Rpb24gSHR0cChvcHRpb25zJCQxKSB7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LCBjbGllbnQgPSBDbGllbnQoc2VsZi4kdm0pO1xyXG5cclxuICAgIGRlZmF1bHRzKG9wdGlvbnMkJDEgfHwge30sIHNlbGYuJG9wdGlvbnMsIEh0dHAub3B0aW9ucyk7XHJcblxyXG4gICAgSHR0cC5pbnRlcmNlcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xyXG5cclxuICAgICAgICBpZiAoaXNTdHJpbmcoaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IEh0dHAuaW50ZXJjZXB0b3JbaGFuZGxlcl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICBjbGllbnQudXNlKGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY2xpZW50KG5ldyBSZXF1ZXN0KG9wdGlvbnMkJDEpKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyByZXNwb25zZSA6IFByb21pc2VPYmoucmVqZWN0KHJlc3BvbnNlKTtcclxuXHJcbiAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgZXJyb3IocmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VPYmoucmVqZWN0KHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5IdHRwLm9wdGlvbnMgPSB7fTtcclxuXHJcbkh0dHAuaGVhZGVycyA9IHtcclxuICAgIHB1dDogSlNPTl9DT05URU5UX1RZUEUsXHJcbiAgICBwb3N0OiBKU09OX0NPTlRFTlRfVFlQRSxcclxuICAgIHBhdGNoOiBKU09OX0NPTlRFTlRfVFlQRSxcclxuICAgIGRlbGV0ZTogSlNPTl9DT05URU5UX1RZUEUsXHJcbiAgICBjb21tb246IENPTU1PTl9IRUFERVJTLFxyXG4gICAgY3VzdG9tOiB7fVxyXG59O1xyXG5cclxuSHR0cC5pbnRlcmNlcHRvciA9IHtiZWZvcmU6IGJlZm9yZSwgbWV0aG9kOiBtZXRob2QsIGpzb25wOiBqc29ucCwganNvbjoganNvbiwgZm9ybTogZm9ybSwgaGVhZGVyOiBoZWFkZXIsIGNvcnM6IGNvcnN9O1xyXG5IdHRwLmludGVyY2VwdG9ycyA9IFsnYmVmb3JlJywgJ21ldGhvZCcsICdqc29ucCcsICdqc29uJywgJ2Zvcm0nLCAnaGVhZGVyJywgJ2NvcnMnXTtcclxuXHJcblsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kJCQxKSB7XHJcblxyXG4gICAgSHR0cFttZXRob2QkJDFdID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucyQkMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zJCQxIHx8IHt9LCB7dXJsOiB1cmwsIG1ldGhvZDogbWV0aG9kJCQxfSkpO1xyXG4gICAgfTtcclxuXHJcbn0pO1xyXG5cclxuWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCQkMSkge1xyXG5cclxuICAgIEh0dHBbbWV0aG9kJCQxXSA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMkJDEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyhhc3NpZ24ob3B0aW9ucyQkMSB8fCB7fSwge3VybDogdXJsLCBtZXRob2Q6IG1ldGhvZCQkMSwgYm9keTogYm9keX0pKTtcclxuICAgIH07XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTZXJ2aWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIFJFU1RmdWwgc2VydmljZXMuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUmVzb3VyY2UodXJsLCBwYXJhbXMsIGFjdGlvbnMsIG9wdGlvbnMkJDEpIHtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXMgfHwge30sIHJlc291cmNlID0ge307XHJcblxyXG4gICAgYWN0aW9ucyA9IGFzc2lnbih7fSxcclxuICAgICAgICBSZXNvdXJjZS5hY3Rpb25zLFxyXG4gICAgICAgIGFjdGlvbnNcclxuICAgICk7XHJcblxyXG4gICAgZWFjaChhY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uLCBuYW1lKSB7XHJcblxyXG4gICAgICAgIGFjdGlvbiA9IG1lcmdlKHt1cmw6IHVybCwgcGFyYW1zOiBhc3NpZ24oe30sIHBhcmFtcyl9LCBvcHRpb25zJCQxLCBhY3Rpb24pO1xyXG5cclxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChzZWxmLiRodHRwIHx8IEh0dHApKG9wdHMoYWN0aW9uLCBhcmd1bWVudHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc291cmNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcHRzKGFjdGlvbiwgYXJncykge1xyXG5cclxuICAgIHZhciBvcHRpb25zJCQxID0gYXNzaWduKHt9LCBhY3Rpb24pLCBwYXJhbXMgPSB7fSwgYm9keTtcclxuXHJcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGJvZHkgPSBhcmdzWzFdO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMTpcclxuXHJcbiAgICAgICAgICAgIGlmICgvXihQT1NUfFBVVHxQQVRDSCkkL2kudGVzdChvcHRpb25zJCQxLm1ldGhvZCkpIHtcclxuICAgICAgICAgICAgICAgIGJvZHkgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gYXJnc1swXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMDpcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHVwIHRvIDIgYXJndW1lbnRzIFtwYXJhbXMsIGJvZHldLCBnb3QgJyArIGFyZ3MubGVuZ3RoICsgJyBhcmd1bWVudHMnO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMkJDEuYm9keSA9IGJvZHk7XHJcbiAgICBvcHRpb25zJCQxLnBhcmFtcyA9IGFzc2lnbih7fSwgb3B0aW9ucyQkMS5wYXJhbXMsIHBhcmFtcyk7XHJcblxyXG4gICAgcmV0dXJuIG9wdGlvbnMkJDE7XHJcbn1cclxuXHJcblJlc291cmNlLmFjdGlvbnMgPSB7XHJcblxyXG4gICAgZ2V0OiB7bWV0aG9kOiAnR0VUJ30sXHJcbiAgICBzYXZlOiB7bWV0aG9kOiAnUE9TVCd9LFxyXG4gICAgcXVlcnk6IHttZXRob2Q6ICdHRVQnfSxcclxuICAgIHVwZGF0ZToge21ldGhvZDogJ1BVVCd9LFxyXG4gICAgcmVtb3ZlOiB7bWV0aG9kOiAnREVMRVRFJ30sXHJcbiAgICBkZWxldGU6IHttZXRob2Q6ICdERUxFVEUnfVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YWxsIHBsdWdpbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBwbHVnaW4oVnVlKSB7XHJcblxyXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgVXRpbChWdWUpO1xyXG5cclxuICAgIFZ1ZS51cmwgPSBVcmw7XHJcbiAgICBWdWUuaHR0cCA9IEh0dHA7XHJcbiAgICBWdWUucmVzb3VyY2UgPSBSZXNvdXJjZTtcclxuICAgIFZ1ZS5Qcm9taXNlID0gUHJvbWlzZU9iajtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhWdWUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgICR1cmw6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyhWdWUudXJsLCB0aGlzLCB0aGlzLiRvcHRpb25zLnVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAkaHR0cDoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS5odHRwLCB0aGlzLCB0aGlzLiRvcHRpb25zLmh0dHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJHJlc291cmNlOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5yZXNvdXJjZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgJHByb21pc2U6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7IHJldHVybiBuZXcgVnVlLlByb21pc2UoZXhlY3V0b3IsIHRoaXMkMSk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XHJcbiAgICB3aW5kb3cuVnVlLnVzZShwbHVnaW4pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XHJcbmV4cG9ydCB7IFVybCwgSHR0cCwgUmVzb3VyY2UgfTtcclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYmFycmEgZml4ZWRcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImxvZ29cIj5cclxuICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvXCI+U2FsdWRUZWNoPC9yb3V0ZXItbGluaz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxuYXYgY2xhc3M9XCJuYXZlZ2FjaW9uLXByaW5jaXBhbFwiPlxyXG4gICAgICAgIDxyb3V0ZXItbGluayB0bz1cImFib3V0XCI+UXVpZW5lcyBzb21vczwvcm91dGVyLWxpbms+XHJcbiAgICAgICAgPHJvdXRlci1saW5rIHYtaWY9XCJhdXRoZW50aWNhdGVkXCIgdG89XCIvXCIgdi1vbjpjbGljay5uYXRpdmU9XCJsb2dvdXQoKVwiIHJlcGxhY2U+U2FsaXI8L3JvdXRlci1saW5rPlxyXG4gICAgICAgIDxyb3V0ZXItbGluayB2LWlmPVwiIWF1dGhlbnRpY2F0ZWRcIiB0bz1cImxvZ2luXCI+SW5pY2lhciBzZXNpb248L3JvdXRlci1saW5rPlxyXG4gICAgICAgIDxidXR0b24gdi1vbjpjbGljaz1cImVzdGFkb1wiPnByb2JhcjwvYnV0dG9uPlxyXG4gICAgICA8L25hdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPHJvdXRlci12aWV3IEBhdXRoZW50aWNhdGVkPVwic2V0QXV0aGVudGljYXRlZFwiIC8+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG5cclxuPHNjcmlwdD5cclxuICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1vY2tBY2NvdW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IFwibWFyYmVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IFwibW1cIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgICBzZXRBdXRoZW50aWNhdGVkKHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdChcImF1dGhlbnRpY2F0ZWRcIiwgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXV0aGVudGljYXRlZClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbG9nb3V0KCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy4kcm91dGVyLnJlcGxhY2UoeyBuYW1lOiBcInNlYXJjaFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXV0aGVudGljYXRlZClcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVzdGFkbygpe1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZWwgZXN0YWRvIGVzXCIpXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdXRoZW50aWNhdGVkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5AaW1wb3J0ICcuLi8uLi9hc3NldHMvc3R5bGVzLmNzcyc7XHJcbmRpdi5iYXJyYSB7XHJcbiAgcGFkZGluZzogMTBweDtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1henVsKTtcclxufVxyXG4uYnJhbmR7XHJcbiAgbWFyZ2luOiAwO1xyXG59XHJcbi5maXhlZCB7XHJcbiAgcG9zaXRpb246IGZpeGVkO1xyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIHRvcDogMDtcclxuICBsZWZ0OiAwO1xyXG4gIHotaW5kZXg6IDI7XHJcbn1cclxuXHJcbmRpdi5sb2dvIHtcclxuICBmbG9hdDogbGVmdDtcclxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XHJcbn1cclxuXHJcbmRpdi5sb2dvIGF7XHJcbiAgY29sb3I6IHZhcigtLWNsYXJvKTtcclxuICBmb250LXNpemU6IDEuNWVtO1xyXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxufVxyXG5cclxuZGl2LmxvZ28gaW1nIHtcclxuICB3aWR0aDogMzBweDtcclxufVxyXG5cclxuXHJcbi8qKiBOYXYgcHJpbmNpcGFsICoqL1xyXG5cclxubmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIHtcclxuICBkaXNwbGF5OiBub25lO1xyXG4gIHdpZHRoOiAxMDAlO1xyXG59XHJcblxyXG5uYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYSB7XHJcbiAgZm9udC1mYW1pbHk6IFwiT3N3YWxkXCIsIHNhbnMtc2VyaWY7XHJcbiAgY29sb3I6ICNmZmZmZmY7XHJcbiAgZm9udC1zaXplOiAwLjhlbTtcclxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgdHJhbnNpdGlvbjogYWxsIDAuNnMgZWFzZTtcclxuICB3aWR0aDogMTAwJTtcclxuICBkaXNwbGF5OiBibG9jaztcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgY2xlYXI6IGJvdGg7XHJcbn1cclxuXHJcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCBhOmhvdmVyIHtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1waWVsKTtcclxufVxyXG5cclxubmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIGE6bGFzdC1jaGlsZCB7XHJcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbn1cclxuXHJcbm5hdi5uYXZlZ2FjaW9uLXByaW5jaXBhbCBhOmxhc3QtY2hpbGQ6aG92ZXIge1xyXG4gIGNvbG9yOiAjZmZmZmZmO1xyXG59XHJcblxyXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XHJcbiAgbmF2Lm5hdmVnYWNpb24tcHJpbmNpcGFsIHtcclxuICAgIHdpZHRoOiA2NyU7XHJcbiAgICBmbG9hdDogcmlnaHQ7XHJcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gIH1cclxuICBuYXYubmF2ZWdhY2lvbi1wcmluY2lwYWwgYSB7XHJcbiAgICBwYWRkaW5nOiAxMHB4IDEwcHg7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICB3aWR0aDogYXV0bztcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIG1hcmdpbjogMCAxMHB4IDAgMDtcclxuICB9XHJcbn1cclxuXHJcbmRpdi5tZW51LW1vdmlsIHtcclxuICB3aWR0aDogNjBweDtcclxuICBkaXNwbGF5OiBibG9jaztcclxuICBmbG9hdDogcmlnaHQ7XHJcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XHJcbiAgbWFyZ2luLXRvcDogMTJweDtcclxufVxyXG5cclxuZGl2Lm1lbnUtbW92aWw6aG92ZXIge1xyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xyXG4gIGRpdi5tZW51LW1vdmlsIHtcclxuICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgfVxyXG59XHJcblxyXG5kaXYubWVudS1tb3ZpbCBzcGFuIHtcclxuICBoZWlnaHQ6IDhweDtcclxuICBtYXJnaW4tYm90dG9tOiA2cHg7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgZGlzcGxheTogYmxvY2s7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYmFycmEgZml4ZWRcIiB9LCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJsb2dvXCIgfSxcbiAgICAgICAgICBbX2MoXCJyb3V0ZXItbGlua1wiLCB7IGF0dHJzOiB7IHRvOiBcIi9cIiB9IH0sIFtfdm0uX3YoXCJTYWx1ZFRlY2hcIildKV0sXG4gICAgICAgICAgMVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcIm5hdlwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibmF2ZWdhY2lvbi1wcmluY2lwYWxcIiB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwicm91dGVyLWxpbmtcIiwgeyBhdHRyczogeyB0bzogXCJhYm91dFwiIH0gfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJRdWllbmVzIHNvbW9zXCIpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfdm0uYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgXCJyb3V0ZXItbGlua1wiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0bzogXCIvXCIsIHJlcGxhY2U6IFwiXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0ubG9nb3V0KClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl92KFwiU2FsaXJcIildXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICFfdm0uYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgICA/IF9jKFwicm91dGVyLWxpbmtcIiwgeyBhdHRyczogeyB0bzogXCJsb2dpblwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiSW5pY2lhciBzZXNpb25cIilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHsgb246IHsgY2xpY2s6IF92bS5lc3RhZG8gfSB9LCBbX3ZtLl92KFwicHJvYmFyXCIpXSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJyb3V0ZXItdmlld1wiLCB7IG9uOiB7IGF1dGhlbnRpY2F0ZWQ6IF92bS5zZXRBdXRoZW50aWNhdGVkIH0gfSlcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNWI0NWUyNWZcIiwgeyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfSlcbiAgfVxufSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xyXG5cclxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXHJcbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXHJcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcclxuICBzY3JpcHRFeHBvcnRzLFxyXG4gIHJlbmRlcixcclxuICBzdGF0aWNSZW5kZXJGbnMsXHJcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxyXG4gIGluamVjdFN0eWxlcyxcclxuICBzY29wZUlkLFxyXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXHJcbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cclxuKSB7XHJcbiAgc2NyaXB0RXhwb3J0cyA9IHNjcmlwdEV4cG9ydHMgfHwge31cclxuXHJcbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxyXG4gIHZhciB0eXBlID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMuZGVmYXVsdFxyXG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBzY3JpcHRFeHBvcnRzID0gc2NyaXB0RXhwb3J0cy5kZWZhdWx0XHJcbiAgfVxyXG5cclxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXHJcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcclxuICAgIDogc2NyaXB0RXhwb3J0c1xyXG5cclxuICAvLyByZW5kZXIgZnVuY3Rpb25zXHJcbiAgaWYgKHJlbmRlcikge1xyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXHJcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcclxuICB9XHJcblxyXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcclxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XHJcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXHJcbiAgfVxyXG5cclxuICAvLyBzY29wZWRJZFxyXG4gIGlmIChzY29wZUlkKSB7XHJcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxyXG4gIH1cclxuXHJcbiAgdmFyIGhvb2tcclxuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcclxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXHJcbiAgICAgIGNvbnRleHQgPVxyXG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcclxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcclxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXHJcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxyXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cclxuICAgICAgfVxyXG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xyXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XHJcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcclxuICAgICAgfVxyXG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcclxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcclxuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcclxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXHJcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcclxuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xyXG4gICAgaG9vayA9IHNoYWRvd01vZGVcclxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxyXG4gICAgICA6IGluamVjdFN0eWxlc1xyXG4gIH1cclxuXHJcbiAgaWYgKGhvb2spIHtcclxuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcclxuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcclxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXHJcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXHJcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXHJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXHJcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXHJcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcclxuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcclxuICAgICAgICA6IFtob29rXVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXHJcbiAgICBvcHRpb25zOiBvcHRpb25zXHJcbiAgfVxyXG59XHJcbiIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoY29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9IZWFkZXIudnVlXCIpXG59XG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0hlYWRlci52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0hlYWRlci52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWI0NWUyNWZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyY1xcXFxjb21wb25lbnRzXFxcXGxheW91dFxcXFxIZWFkZXIudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTViNDVlMjVmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNWI0NWUyNWZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZm9vdGVyXCIsIHsgc3RhdGljQ2xhc3M6IFwic2l0ZS1mb290ZXJcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRlbmVkb3IgY2xlYXJmaXhcIiB9LCBbXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZm9vdGVyLWluZm9ybWFjaW9uXCIgfSwgW1xuICAgICAgICAgIF9jKFwiaDNcIiwgW192bS5fdihcIlNhbHVkVGVjaFwiKV0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoXCJjb250YWN0b0BzYWx1ZHRlY2guY29tXCIpXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWVudVwiIH0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInBcIiwgeyBzdGF0aWNDbGFzczogXCJjb3B5cmlnaHRcIiB9LCBbXG4gICAgICAgIF92bS5fdihcIlRvZG9zIGxvcyBkZXJlY2hvcyByZXNlcnZhZG9zXCIpXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0zYTEzN2U2ZFwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0Zvb3Rlci52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xudmFyIF9fdnVlX3NjcmlwdF9fID0gbnVsbFxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2ExMzdlNmRcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRm9vdGVyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyY1xcXFxjb21wb25lbnRzXFxcXGxheW91dFxcXFxGb290ZXIudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTNhMTM3ZTZkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtM2ExMzdlNmRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgaWQ9XCJhcHBcIj5cclxuICA8c3RoZWFkZXI+PC9zdGhlYWRlcj5cclxuICA8c3Rmb290ZXI+PC9zdGZvb3Rlcj5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBzdGhlYWRlciBmcm9tICcuL2NvbXBvbmVudHMvbGF5b3V0L0hlYWRlci52dWUnXHJcbmltcG9ydCBzdGZvb3RlciBmcm9tICcuL2NvbXBvbmVudHMvbGF5b3V0L0Zvb3Rlci52dWUnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnYXBwJyxcclxuIGNvbXBvbmVudHM6IHsgc3RoZWFkZXIsIHN0Zm9vdGVyIH0sXHJcbiAgIGRhdGEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1vY2tBY2NvdW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IFwibWFyYmVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IFwibW1cIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgc2V0QXV0aGVudGljYXRlZChzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoXCJhdXRoZW50aWNhdGVkXCIsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF1dGhlbnRpY2F0ZWQpXHJcbiAgICAgICAgICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuQGltcG9ydCAnLi9hc3NldHMvc3R5bGVzLmNzcyc7XHJcbjwvc3R5bGU+XHJcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IGF0dHJzOiB7IGlkOiBcImFwcFwiIH0gfSxcbiAgICBbX2MoXCJzdGhlYWRlclwiKSwgX3ZtLl92KFwiIFwiKSwgX2MoXCJzdGZvb3RlclwiKV0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wNGMyMDQ2YlwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wNGMyMDQ2YlxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG5pbXBvcnQgbm9ybWFsaXplQ29tcG9uZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50LW5vcm1hbGl6ZXJcIlxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3JlbmRlcl9fLFxuICBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjXFxcXEFwcC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMDRjMjA0NmJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wNGMyMDQ2YlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJtYWluXCI+XG4gICAgPGgxIHYtZm9yPVwiaSBpbiBlbGVtXCI+e3sgaSB9fTwvaDE+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJhcHBcIixcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJ1ZWJhOiBcIkhPTEFcIixcbiAgICAgIGVsZW06IFtcbiAgICAgICAgMSxcbiAgICAgICAgMixcbiAgICAgICAgMyxcbiAgICAgICAgNCxcbiAgICAgICAgNCxcbiAgICAgICAgMyxcbiAgICAgICAgMSxcbiAgICAgICAgMixcbiAgICAgICAgMixcbiAgICAgICAgMSxcbiAgICAgICAgMyxcbiAgICAgICAgMyxcbiAgICAgICAgMyxcbiAgICAgICAgMixcbiAgICAgICAgMixcbiAgICAgICAgMixcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMixcbiAgICAgICAgMyxcbiAgICAgICAgOVxuICAgICAgXVxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHt9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiNtYWlue1xuICBtYXJnaW4tdG9wOiA4MHB4O1xufVxuPC9zdHlsZT5cbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IGF0dHJzOiB7IGlkOiBcIm1haW5cIiB9IH0sXG4gICAgX3ZtLl9sKF92bS5lbGVtLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gX2MoXCJoMVwiLCBbX3ZtLl92KF92bS5fcyhpKSldKVxuICAgIH0pXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9XG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWQ5NDk5YzkwXCIsIHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH0pXG4gIH1cbn0iLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKGNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2VhcmNoLnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TZWFyY2gudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TZWFyY2gudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQge3JlbmRlciBhcyBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zIGFzIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX199IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWQ5NDk5YzkwXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NlYXJjaC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxTZWFyY2gudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWQ5NDk5YzkwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZDk0OTljOTBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYmFqYXJcIiB9LCBbXG4gICAgICAgIF9jKFwiaDFcIiwgW192bS5fdihcIk5vc290cm9zXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwicFwiLCBbX3ZtLl92KFwiYWNlcmNhIGRlIHNhbHVkdGVjaFwiKV0pXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03MjhlZTlhNlwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0Fib3V0LnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG52YXIgX192dWVfc2NyaXB0X18gPSBudWxsXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03MjhlZTlhNlxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BYm91dC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxBYm91dC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNzI4ZWU5YTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03MjhlZTlhNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBpZD1cIkxvZ2luXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybXVsYXJpb1wiPlxyXG4gICAgICA8aDE+SW5pY2lvIGRlIHNlc2nDs248L2gxPlxyXG4gICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwidXNlcm5hbWVcIiB2LW1vZGVsPVwiaW5wdXQudXNlcm5hbWVcIiBwbGFjZWhvbGRlcj1cIlVzdWFyaW9cIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5hbWU9XCJwYXNzd29yZFwiIHYtbW9kZWw9XCJpbnB1dC5wYXNzd29yZFwiIHBsYWNlaG9sZGVyPVwiQ29udHJhc2XDsWFcIj5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdi1vbjpjbGljaz1cImxvZ2luKClcIj5Mb2dpbjwvYnV0dG9uPlxyXG4gICAgICA8cm91dGVyLWxpbmsgdG89XCJzaWdudXBcIj5DcmVhciBjdWVudGE8L3JvdXRlci1saW5rPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIG5hbWU6ICdMb2dpbicsXHJcbmRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlucHV0OiB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcIlwiLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogXCJcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICAgIGxvZ2luKCkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pbnB1dC51c2VybmFtZSAhPSBcIlwiICYmIHRoaXMuaW5wdXQucGFzc3dvcmQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudXNlcm5hbWUgPT0gdGhpcy4kcGFyZW50Lm1vY2tBY2NvdW50LnVzZXJuYW1lICYmIHRoaXMuaW5wdXQucGFzc3dvcmQgPT0gdGhpcy4kcGFyZW50Lm1vY2tBY2NvdW50LnBhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoXCJhdXRoZW50aWNhdGVkXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyJyxpbnB1dC51c2VybmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcm91dGVyLnJlcGxhY2UoeyBuYW1lOiBcInNlY3VyZVwiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGhlIHVzZXJuYW1lIGFuZCAvIG9yIHBhc3N3b3JkIGlzIGluY29ycmVjdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgbXVzdCBiZSBwcmVzZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBzY29wZWQ+XHJcblxyXG4gICAgLmZvcm11bGFyaW8ge1xyXG4gICAgICAgIHdpZHRoOiA5MCU7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xyXG4gICAgICAgIG1hcmdpbjogYXV0bztcclxuICAgICAgICBtYXJnaW4tdG9wOiAxMCU7XHJcbiAgICAgICAgcGFkZGluZzogMjBweDtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDUlO1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAuMyk7XHJcbiAgICB9XHJcbiAgICBpbnB1dCwgYnV0dG9ue1xyXG4gICAgICB3aWR0aDogOTAlO1xyXG4gICAgICBoZWlnaHQ6IDQwJTtcclxuICAgICAgbWFyZ2luOiA1cHg7XHJcbiAgICAgIHBhZGRpbmc6IDElO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NzY4cHgpIHtcclxuICAgIC5mb3JtdWxhcmlvIHtcclxuICAgICAgICB3aWR0aDogMzAlO1xyXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDEwJTtcclxuXHJcbiAgICB9XHJcbiAgICBpbnB1dCwgYnV0dG9ue1xyXG4gICAgICB3aWR0aDogOTAlO1xyXG4gICAgICBoZWlnaHQ6IDQwJTtcclxuICAgIH1cclxuXHJcbiAgICBidXR0b257XHJcbiAgICAgICAgcGFkZGluZzogMiU7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT5cclxuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IGF0dHJzOiB7IGlkOiBcIkxvZ2luXCIgfSB9LCBbXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdGF0aWNDbGFzczogXCJmb3JtdWxhcmlvXCIgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXCJoMVwiLCBbX3ZtLl92KFwiSW5pY2lvIGRlIHNlc2nDs25cIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmlucHV0LnVzZXJuYW1lLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImlucHV0LnVzZXJuYW1lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwidGV4dFwiLCBuYW1lOiBcInVzZXJuYW1lXCIsIHBsYWNlaG9sZGVyOiBcIlVzdWFyaW9cIiB9LFxuICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0uaW5wdXQudXNlcm5hbWUgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdm0uJHNldChfdm0uaW5wdXQsIFwidXNlcm5hbWVcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0uaW5wdXQucGFzc3dvcmQsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaW5wdXQucGFzc3dvcmRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicGFzc3dvcmRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicGFzc3dvcmRcIixcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkNvbnRyYXNlw7FhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0uaW5wdXQucGFzc3dvcmQgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdm0uJHNldChfdm0uaW5wdXQsIFwicGFzc3dvcmRcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdm0ubG9naW4oKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl92KFwiTG9naW5cIildXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwicm91dGVyLWxpbmtcIiwgeyBhdHRyczogeyB0bzogXCJzaWdudXBcIiB9IH0sIFtfdm0uX3YoXCJDcmVhciBjdWVudGFcIildKVxuICAgICAgXSxcbiAgICAgIDFcbiAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi05ZmNmZWRlZVwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWZjZmVkZWVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Mb2dpbi52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vTG9naW4udnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9Mb2dpbi52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWZjZmVkZWVcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9Mb2dpbi52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gXCJkYXRhLXYtOWZjZmVkZWVcIlxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxMb2dpbi52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtOWZjZmVkZWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi05ZmNmZWRlZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBpZD1cInNlY3VyZVwiPlxuICAgICAgICA8aDE+U2VjdXJlIEFyZWE8L2gxPlxuICAgICAgICA8cD5cbiAgICAgICAgICAgIFRoaXMgaXMgYSBzZWN1cmUgYXJlYVxuICAgICAgICA8L3A+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgICAgbmFtZTogJ1NlY3VyZScsXG4gICAgICAgIGRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbiAgICAjc2VjdXJlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICB9XG48L3N0eWxlPlxuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgYXR0cnM6IHsgaWQ6IFwic2VjdXJlXCIgfSB9LCBbXG4gICAgICBfYyhcImgxXCIsIFtfdm0uX3YoXCJTZWN1cmUgQXJlYVwiKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwicFwiLCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgVGhpcyBpcyBhIHNlY3VyZSBhcmVhXFxuICAgICAgICBcIildKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0xYjNlYTgwN1wiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWIzZWE4MDdcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TZWN1cmUudnVlXCIpXG59XG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1NlY3VyZS52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1NlY3VyZS52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWIzZWE4MDdcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TZWN1cmUudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IFwiZGF0YS12LTFiM2VhODA3XCJcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG5pbXBvcnQgbm9ybWFsaXplQ29tcG9uZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50LW5vcm1hbGl6ZXJcIlxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3JlbmRlcl9fLFxuICBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjXFxcXGNvbXBvbmVudHNcXFxcU2VjdXJlLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xYjNlYTgwN1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTFiM2VhODA3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcbiIsIjx0ZW1wbGF0ZT5cclxuPGRpdiBpZD1cInJlZ2lzdGVyXCI+XHJcbjxkaXYgY2xhc3M9XCJmb3JtdWxhcmlvXCI+XHJcbiAgICA8aDE+Q3JlYXIgY3VlbnRhPC9oMT5cclxuICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwidXNlcm5hbWVcIiB2LW1vZGVsPVwiaW5wdXQudXNlcm5hbWVcIiBwbGFjZWhvbGRlcj1cIlVzdWFyaW9cIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5hbWU9XCJwYXNzd29yZFwiIHYtbW9kZWw9XCJpbnB1dC5lbWFpbFwiIHBsYWNlaG9sZGVyPVwiRW1haWxcIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInVzZXJuYW1lXCIgdi1tb2RlbD1cImlucHV0LnBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJDb250cmFzZcOxYVwiPlxyXG4gICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgbmFtZT1cInBhc3N3b3JkXCIgdi1tb2RlbD1cImlucHV0LnRpcG9cIiBwbGFjZWhvbGRlcj1cIlRpcG9cIj5cclxuICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHYtb246Y2xpY2s9XCJzaWdudXAoKVwiPlJlZ2lzdHJhcjwvYnV0dG9uPlxyXG48L2Rpdj5cclxuPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIG5hbWU6ICdyZWdpc3RlcicsXHJcbmRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlucHV0OiB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcIlwiLFxyXG4gICAgICAgICAgICBlbWFpbDogXCJcIixcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IFwiXCIsXHJcbiAgICAgICAgICAgIHRpcG86IFwiXCJcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LFxyXG5tZXRob2RzOiB7XHJcbiAgICAgICAgICAgIHNpZ251cCgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudXNlcm5hbWUgIT0gXCJcIiAmJiB0aGlzLmlucHV0LnBhc3N3b3JkICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmlucHV0LnVzZXJuYW1lID09IHRoaXMuJHBhcmVudC5tb2NrQWNjb3VudC51c2VybmFtZSAmJiB0aGlzLmlucHV0LnBhc3N3b3JkID09IHRoaXMuJHBhcmVudC5tb2NrQWNjb3VudC5wYXNzd29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KFwiYXV0aGVudGljYXRlZFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlcicsaW5wdXQudXNlcm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5yZXBsYWNlKHsgbmFtZTogXCJzZWN1cmVcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSB1c2VybmFtZSBhbmQgLyBvciBwYXNzd29yZCBpcyBpbmNvcnJlY3RcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkEgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG11c3QgYmUgcHJlc2VudFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBzY29wZWQ+XHJcblxyXG4gICAgLmZvcm11bGFyaW8ge1xyXG4gICAgICAgIHdpZHRoOiA5MCU7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xyXG4gICAgICAgIG1hcmdpbjogYXV0bztcclxuICAgICAgICBtYXJnaW4tdG9wOiAxMCU7XHJcbiAgICAgICAgcGFkZGluZzogMjBweDtcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDUlO1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAuMyk7XHJcbiAgICB9XHJcbiAgICBpbnB1dCwgYnV0dG9ue1xyXG4gICAgICB3aWR0aDogOTAlO1xyXG4gICAgICBoZWlnaHQ6IDQwJTtcclxuICAgICAgbWFyZ2luOiA1cHg7XHJcbiAgICAgIHBhZGRpbmc6IDElO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NzY4cHgpIHtcclxuICAgIC5mb3JtdWxhcmlvIHtcclxuICAgICAgICB3aWR0aDogMzAlO1xyXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDEwJTtcclxuXHJcbiAgICB9XHJcbiAgICBpbnB1dCwgYnV0dG9ue1xyXG4gICAgICB3aWR0aDogOTAlO1xyXG4gICAgICBoZWlnaHQ6IDQwJTtcclxuICAgIH1cclxuXHJcbiAgICBidXR0b257XHJcbiAgICAgICAgcGFkZGluZzogMiU7XHJcbiAgICB9XHJcbn1cclxuPC9zdHlsZT4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgYXR0cnM6IHsgaWQ6IFwicmVnaXN0ZXJcIiB9IH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZvcm11bGFyaW9cIiB9LCBbXG4gICAgICBfYyhcImgxXCIsIFtfdm0uX3YoXCJDcmVhciBjdWVudGFcIildKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5pbnB1dC51c2VybmFtZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaW5wdXQudXNlcm5hbWVcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwidXNlcm5hbWVcIiwgcGxhY2Vob2xkZXI6IFwiVXN1YXJpb1wiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0uaW5wdXQudXNlcm5hbWUgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0uJHNldChfdm0uaW5wdXQsIFwidXNlcm5hbWVcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmlucHV0LmVtYWlsLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJpbnB1dC5lbWFpbFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcInBhc3N3b3JkXCIsIG5hbWU6IFwicGFzc3dvcmRcIiwgcGxhY2Vob2xkZXI6IFwiRW1haWxcIiB9LFxuICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmlucHV0LmVtYWlsIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoX3ZtLmlucHV0LCBcImVtYWlsXCIsICRldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5pbnB1dC5wYXNzd29yZCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaW5wdXQucGFzc3dvcmRcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwidXNlcm5hbWVcIiwgcGxhY2Vob2xkZXI6IFwiQ29udHJhc2XDsWFcIiB9LFxuICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmlucHV0LnBhc3N3b3JkIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoX3ZtLmlucHV0LCBcInBhc3N3b3JkXCIsICRldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5pbnB1dC50aXBvLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJpbnB1dC50aXBvXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJzOiB7IHR5cGU6IFwicGFzc3dvcmRcIiwgbmFtZTogXCJwYXNzd29yZFwiLCBwbGFjZWhvbGRlcjogXCJUaXBvXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5pbnB1dC50aXBvIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoX3ZtLmlucHV0LCBcInRpcG9cIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIF92bS5zaWdudXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW192bS5fdihcIlJlZ2lzdHJhclwiKV1cbiAgICAgIClcbiAgICBdKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYzE3OWY1YjBcIiwgeyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfSlcbiAgfVxufSIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoY29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWMxNzlmNWIwXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2lnbnVwLnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TaWdudXAudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9TaWdudXAudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQge3JlbmRlciBhcyBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zIGFzIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX199IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWMxNzlmNWIwXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU2lnbnVwLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBcImRhdGEtdi1jMTc5ZjViMFwiXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyY1xcXFxjb21wb25lbnRzXFxcXFNpZ251cC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYzE3OWY1YjBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1jMTc5ZjViMFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1lZGljb1wiPlxyXG4gICAgICAgIDxyb3V0ZXItbGluayB0bz1cImFib3V0bWVkXCI+UXVpZW5lcyBzb21vczwvcm91dGVyLWxpbms+XHJcbiAgICAgICAgICA8aW1nIHNyYz1cIi4uLy4uL2Fzc2V0cy9sb2dvLnBuZ1wiIGFsdD1cIkltYWdlbiBpbnZpdGFkb1wiPlxyXG4gICAgICAgICAgPHA+e3sgbWVkLm5vbWJyZSB9fTwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbiAgZXhwb3J0IGRlZmF1bHR7XHJcbiAgICAgIHByb3BzOiB7XHJcbiAgICBtZWQ6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogdHJ1ZSB9XHJcbiAgfSxcclxuICB9XHJcbjwvc2NyaXB0PlxyXG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcIm1lZGljb1wiIH0sXG4gICAgICBbXG4gICAgICAgIF9jKFwicm91dGVyLWxpbmtcIiwgeyBhdHRyczogeyB0bzogXCJhYm91dG1lZFwiIH0gfSwgW1xuICAgICAgICAgIF92bS5fdihcIlF1aWVuZXMgc29tb3NcIilcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiByZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2xvZ28ucG5nXCIpLFxuICAgICAgICAgICAgYWx0OiBcIkltYWdlbiBpbnZpdGFkb1wiXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5tZWQubm9tYnJlKSldKVxuICAgICAgXSxcbiAgICAgIDFcbiAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1mZTNkYjAzY1wiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwidmFyIGRpc3Bvc2VkID0gZmFsc2Vcbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQ2FyZC52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0NhcmQudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQge3JlbmRlciBhcyBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zIGFzIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX199IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWZlM2RiMDNjXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0NhcmQudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxsYXlvdXRcXFxcQ2FyZC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZmUzZGIwM2NcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mZTNkYjAzY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBpZD1cInNlcnZpY2lvc1wiPlxyXG4gICAgPGgxPkhvbGE8L2gxPlxyXG4gICAgPGRpdiB2LWZvcj1cIm0gaW4gbWVkaWNvc1wiIDprZXk9XCJtXCI+XHJcbiAgICAgIDxzdG1lZCA6bWVkPVwibVwiPjwvc3RtZWQ+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBzdG1lZCBmcm9tICcuL2xheW91dC9DYXJkLnZ1ZSdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG5uYW1lOiAnc2VydmljaW9zJyxcclxuY29tcG9uZW50czogeyBzdG1lZCB9LFxyXG5kYXRhKCl7XHJcbiAgcmV0dXJue1xyXG4gIG1lZGljb3M6IFt7XCJub21icmVcIjpcIm1hcmJlbFwiLCBcImVzcGVjaWFsaWRhZFwiOlwiZGVybWF0b2xvZ2lhXCIsIFwiaW1hZ2VuXCI6XCIuLi9hc3NldHMvbG9nby5wbmdcIn1dXHJcbiAgfVxyXG59XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cclxuPHN0eWxlIHNjb3BlZD5cclxuXHJcbjwvc3R5bGU+XHJcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IGF0dHJzOiB7IGlkOiBcInNlcnZpY2lvc1wiIH0gfSxcbiAgICBbXG4gICAgICBfYyhcImgxXCIsIFtfdm0uX3YoXCJIb2xhXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9sKF92bS5tZWRpY29zLCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBfYyhcImRpdlwiLCB7IGtleTogbSB9LCBbX2MoXCJzdG1lZFwiLCB7IGF0dHJzOiB7IG1lZDogbSB9IH0pXSwgMSlcbiAgICAgIH0pXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9XG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWM4YjNkOTMwXCIsIHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH0pXG4gIH1cbn0iLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKGNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1jOGIzZDkzMFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1BvcnRmb2xpby52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vUG9ydGZvbGlvLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vUG9ydGZvbGlvLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1jOGIzZDkzMFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6dHJ1ZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1BvcnRmb2xpby52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gXCJkYXRhLXYtYzhiM2Q5MzBcIlxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcY29tcG9uZW50c1xcXFxQb3J0Zm9saW8udnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWM4YjNkOTMwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtYzhiM2Q5MzBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwiaW1wb3J0IFNlYXJjaCBmcm9tICcuL2NvbXBvbmVudHMvU2VhcmNoLnZ1ZSdcclxuaW1wb3J0IEFib3V0IGZyb20gJy4vY29tcG9uZW50cy9BYm91dC52dWUnXHJcbmltcG9ydCBMb2dpbiBmcm9tICcuL2NvbXBvbmVudHMvTG9naW4udnVlJ1xyXG5pbXBvcnQgU2VjdXJlIGZyb20gJy4vY29tcG9uZW50cy9TZWN1cmUudnVlJ1xyXG5pbXBvcnQgUmVnaXN0ZXIgZnJvbSAnLi9jb21wb25lbnRzL1NpZ251cC52dWUnXHJcbmltcG9ydCBTZXJ2aWNlcyBmcm9tICcuL2NvbXBvbmVudHMvUG9ydGZvbGlvLnZ1ZSdcclxuaW1wb3J0IE1lZCBmcm9tICcuL2NvbXBvbmVudHMvbGF5b3V0L0NhcmQudnVlJ1xyXG5cclxuY29uc3Qgcm91dGVzID0gW1xyXG4gICAgeyBwYXRoOiAnLycsIGNvbXBvbmVudDogU2VhcmNoLCBuYW1lOiAnc2VhcmNoJyB9LFxyXG4gICAgeyBwYXRoOiAnL2Fib3V0JywgY29tcG9uZW50OiBBYm91dCwgbmFtZTogJ2Fib3V0JyB9LFxyXG4gICAgeyBwYXRoOiAnL2xvZ2luJywgY29tcG9uZW50OiBMb2dpbiwgbmFtZTogJ2xvZ2luJyB9LFxyXG4gICAgeyBwYXRoOiAnL3NpZ251cCcsIGNvbXBvbmVudDogUmVnaXN0ZXIsIG5hbWU6ICdyZWdpc3RlcicgfSxcclxuICAgIHsgcGF0aDogJy9zZXJ2aWNlcycsIGNvbXBvbmVudDogU2VydmljZXMsIG5hbWU6ICdzZXJ2aWNlcycgfSxcclxuICAgIHsgcGF0aDogJy9tZWQnLCBjb21wb25lbnQ6IE1lZCwgbmFtZTogJ21lZCcgfSxcclxuICAgIHsgcGF0aDogJy9zZWN1cmUnLCBjb21wb25lbnQ6IFNlY3VyZSwgbmFtZTogJ3NlY3VyZScgfVxyXG5dXHJcblxyXG5leHBvcnQgZGVmYXVsdCByb3V0ZXMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IFZ1ZVJvdXRlciBmcm9tICd2dWUtcm91dGVyJ1xyXG5pbXBvcnQgVnVlUmVzb3VyY2UgZnJvbSAndnVlLXJlc291cmNlJ1xyXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLnZ1ZSdcclxuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcydcclxuXHJcblZ1ZS51c2UoVnVlUm91dGVyKVxyXG5WdWUudXNlKFZ1ZVJlc291cmNlKVxyXG5jb25zdCByb3V0ZXIgPSBuZXcgVnVlUm91dGVyKHsgcm91dGVzIH0pXHJcbm5ldyBWdWUoe1xyXG4gICAgZWw6ICcjYXBwJyxcclxuICAgIHJlbmRlcjogaCA9PiBoKEFwcCksXHJcbiAgICByb3V0ZXJcclxufSkiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///54\\n\")},function(module,exports,__webpack_require__){eval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(16);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\nif(content.locals) module.exports = content.locals;\\n// add the styles to the DOM\\nvar add = __webpack_require__(3).default\\nvar update = add(\\\"5dc5e678\\\", content, false, {});\\n// Hot Module Replacement\\nif(true) {\\n // When the styles change, update the <style> tags\\n if(!content.locals) {\\n   module.hot.accept(16, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { (function() {\\n     var newContent = __webpack_require__(16);\\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\\n     update(newContent);\\n   })(__WEBPACK_OUTDATED_DEPENDENCIES__); });\\n }\\n // When the module is disposed, remove the <style> tags\\n module.hot.dispose(function() { update(); });\\n}\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Qb3J0Zm9saW8udnVlPzllMzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBaVM7QUFDdlQsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUE2RDtBQUMvRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLElBQVU7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLEVBQWlTLEVBQUU7QUFDeFQsc0JBQXNCLG1CQUFPLENBQUMsRUFBaVM7QUFDL1QsdURBQXVELFFBQVM7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWM4YjNkOTMwXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vUG9ydGZvbGlvLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1ZGM1ZTY3OFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWM4YjNkOTMwXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vUG9ydGZvbGlvLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYzhiM2Q5MzBcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Qb3J0Zm9saW8udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///55\\n\")}]);","extractedComments":[]}